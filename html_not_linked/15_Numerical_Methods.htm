<!DOCTYPE HTML>
<html>
    <head>
        <title>15_Numerical_Methods</title>
        <!-- include bootstrap -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
        <!-- include stylesheets -->
        <link rel="stylesheet" href="styles/styles.css" />
        <link rel="stylesheet" href="styles/num-methods-styles.css" />
        <!-- include math -->
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>

<body>
<div>#top_nav#</div>
<div class="nav-obj">#nav_obj#</div>

<div class="content">
  <h1 id="15" align="center">Chapter 15: Numerical Methods</h1>

  <!-- Chapter Objectives -->
  <h1>Chapter Objectives</h1>
  <div class="container">
      <p>This chapter discusses the implementations of four common numerical techniques:</p>
      <ul>
          <li>Interpolating data</li>
          <li>Fitting polynomial curves to data</li>
          <li>Numerical integration</li>
          <li>Numerical differentiation</li>
      </ul>
  </div>

  <!-- Introduction -->
  <h1>Introduction</h1>
  <div class="container">
      <p>Real-world data are rarely in such a form that you can use it immediately. Frequently, the data must be manipulated according to the user's actual needs:</p>
      <ul>
          <li>If the data samples have correct values but are not close enough together to be used directly, we can use interpolation to compute data points between the samples provided.</li>
          <li>There are occasions where the data-gathering facilities add some amount of noise to the data. To minimize the effects of the noise, we can compute the coefficients of a polynomial function that best matches the data.</li>
          <li>There are also times when the data must be integrated or differentiated to derive the quantities of interest.</li>
      </ul>
  </div>

  <div class="chp-section" data-sect-num="1" data-sect-name="Interpolation">
    <!-- Interpolation -->
    <h2 id="15_1">15.1  Interpolation</h2>
    <div class="container clearfix">
      <div class="float-sm-right card">
          <img src="..\Images\Fig_15_1.JPG" alt="Figure 15.1" class="fig card-image">
          <p class="figure-name card-title">Figure 15.1: The Interpolation Problem</p>
      </div>
      <p>If our data samples have correct values but are not close enough to be used directly, we can use either linear or cubic interpolation to compute data points between the samples provided. For example, plotting functions use linear interpolation to draw the lines between data points. In general, interpolation is a technique by which we estimate a variable's value between known values. In this section, we present the two most common types of interpolation: <b>linear interpolation</b> and <b>cubic spline interpolation</b>. In both techniques, we assume that we have a set of data points that represents x-y coordinates for which \(y\) is a function of \(x\); that is,</p>
      $$ y = f(x) $$
      <p>We then have a value of \(x\) that is not part of the data set for which we want to find the \(y\) value. Figure 15.1 illustrates the definition of the interpolation problem.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Linear Interpolation">
      <!-- Linear Interpolation -->
      <h3 id="15_1_1">15.1.1 Linear Interpolation</h3>
      <div class="container">
          <p>Linear interpolation is one of the most common techniques for estimating data values between two given data points. With this technique, we assume that the function between the points can be represented by a straight line drawn between the points, as shown in Figure 15.2.</p>
          <p>Since we can find the equation of a straight line defined by the two known points, we can find \(y\) for any value of \(x\). The closer the points are to each other, the more accurate our approximation is likely to be. Of course, we could use this equation to extrapolate points past our collected data. This is rarely wise, however, and often leads to significant errors. The function that performs linear interpolation is as follows:</p>
          <p><code>new_y = interp1(x, y, new_x)</code></p>
          <p>where the vectors <code>x</code> and <code>y</code> contain the original data values and the vector <code>new_x</code> contains the point(s) for which we want to compute interpolated <code>new_y</code> values. The <code>x</code> values should be in ascending order, and the <code>new_x</code> values should be within the range of the original <code>x</code> values. Note that the last character in the name <code>interp1</code> is the numeric 1 (one), not a lowercase L.</p>
          <div class="card-deck">
              <div class="card">
                  <img src="..\Images\Fig_15_2.JPG" alt="Figure 15.2" class="fig card-image">
                  <p class="figure-name card-title">Figure 15.2: Interpolation Raw Data</p>
              </div>
              <div class="card">
                  <img src="..\Images\Fig_15_3.JPG" alt="Figure 15.3" class="fig card-image">
                  <p class = "figure-name card-title">Figure 15.3: Linear Interpolation</p>
              </div>
          </div>
          <p>The use of <code>interp1(...)</code> is demonstrated in Listing 15.1.</p>
          <div id="listing_15_1" class="listing">#listing_15_1#</div>
          <p>The MATLAB language allows us to provide a fourth parameter to the interp1(...) function that must be a string that modifies its behavior. The choices are as follows:</p>
          <ul style="list-style-type:none">
              <li><code>'nearest'</code> nearest neighbor interpolation </li>
              <li><code>'1inear'</code> linear interpolationâ€”the default</li>
              <li><code>'spline'</code> piecewise cubic spline interpolation (see Section 15.1.2)</li>
              <li><code>'pchip'</code> shape-preserving piecewise cubic interpolation</li>
              <li><code>'cubic'</code> same as <code>'pchip'</code></li>
              <li><code>'v5cubic'</code> cubic interpolation that does not extrapolate, and uses <code>'spline'</code> if <code>x</code> is not equally spaced </li>
          </ul>
          <p>The MATLAB language also provides for two-dimensional (<code>interp2(...)</code>) and three-dimensional (<code>interp3(...)</code>) interpolation functions, which are not discussed here.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Cubic Spline Interpolation">
      <!-- Cubic Spline Interpolation -->
      <h3 id="15_1_2">15.1.2	Cubic Spline Interpolation</h3>
      <div class="container clearfix">
          <p>A <b>cubic spline</b> is a smooth curve constructed to go through a set of points. The curve between each pair of  points is a third-degree polynomial that has the general form:</p>
          $$ {x = a_{x0}{t^3} + a_{x1}{t^2} + a_{x2}{t} + a_{x3}} and {y = a_{y0}{t^3} + a_{y1}{t^2} + a_{y2}{t} + a_{y3}} $$
          <p>where <code>t</code> is a parameter ranging from 0 to 1 between each pair of points. The coefficients are computed so that this provides a smooth curve between pairs of points and a smooth transition between the adjacent curves. Figure 15.4 shows a cubic spline smoothly connecting six points using a total of five different cubic equations.</p>
          <p>The function that performs linear interpolation is as follows:</p>
          <p><code>new_y = spline(x, y, new_x);</code></p>
          <p>where the vectors <code>x</code> and <code>y</code> contain the original data values, and the vector <code>x_new</code> contains the point(s) for which we want to compute interpolated <code>y_new</code> values. The <code>x</code> values should be in ascending order, and while the <code>x_new</code> values should be within the range of the <code>x</code> values, this function will attempt to extrapolate outside that range.</p>
          <p>The curve in Figure 15.4 was created using the code shown in Listing 15.2.</p>
          <div class="card-deck">
              <div class="card col-sm-6">
                  <img src="..\Images\Fig_15_4.PNG" alt="Figure 15.4" class="fig card-image">
                  <p class="figure-name card-title">Figure 15.4: Cubic Spline Interpolation</p>
              </div>
                <!-- Style Points -->
                <div class="card col-sm-6 style-points style-points-col">
                  <p class="card-title">Style Points 15.1</p>
                  <p class="card-text">
                      <p>A good convention to adopt is shown in Figure 15.4:</p>
                      <ul>
                          <li>Use symbols to plot data points that are real values with no associated information connecting them.</li>
                          <li>Draw lines between data points only when there is an analytic relationship that connects the data points.</li>
                      </ul>
                      <p>Here, we use a circle symbol for the raw data to emphasize the original source of the information, and a smooth line for the spline curve to indicate that we are assuming a possibly erroneous but continous relationship between data points.</p>
                  </p>
              </div>
          </div>
          <div id="listing_15_2" class="listing">#listing_15_2#</div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Extrapolation">
      <!-- Extrapolation -->
      <h3 id="15_1_3">15.1.3	Extrapolation</h3>
      <div class="container">
        <p>A note of caution about extrapolation - attempting to infer the values of data points outside the range of data provided is problematic at best and usually gives misleading results. Although logically your code may allow you to, you should never do it. The interp1(...) and spline(...) functions behave differently in this respect. As we saw previously, the interp1(...) function refuses to supply results outside the range of the original <code>x</code> data. If you try, for every <code>new_x</code> value outside the range of the original <code>x</code> values, it will return <code>NaN</code> - not a number.</p>
        <p>This is actually quite nice because if you accidentally request interpolated data like this, the plot programs ignore <code>NaN</code> values. The spline function, however, has no such scruples and allows you to request any <code>x</code> values you want, using the equation of the closest line segment. So considering Figure 15.4, if you asked for the value at <code>x = -3</code>, it would use the segment between 0 and 1, which has a violent upswing at the lower end (see Exercise 15.1).</p>
        <p>This might be what you want, but it looks odd! Chances are the data are not as accurate as you thought, and you probably need to fit a curve to the data, as explained in the following section.</p>
        <div class="exercise">#exercise_15_1#</div>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="2" data-sect-name="Curve Fitting">
    <!-- Curve Fitting -->
    <h2 id="15_2">15.2 Curve Fitting</h2>
    <div class="container">
        <p>There are occasions where the data acquisition facilities add some amount of noise to the data. To minimize the effects of the noise, we can smooth the data by computing the coefficients of a polynomial function that best match the data. The choice of the order of the polynomial must be made by the users, depending upon their understanding of the underlying physics that generated the data.</p>
        <p>For example, assume that we have a set of data points collected from an experiment. After plotting the data points, we find that they generally fall in a straight line. However, if we were to try to draw a straight line through the points, probably only a couple of the points would fall exactly on the line. A least squares curve fitting method could be used to find the straight line that is the closest to the points, by minimizing the distance from each point to the straight line. Although this line can be considered a "best fit" to the data points, it is possible that none of the points would actually fall on the line of best fit. (Note that this method is different from interpolation, because the lines used in interpolation actually fall on all of the original data points.)</p>
        <p>In the following section, we will discuss fitting a straight line to a set of data points, and then we will discuss fitting a polynomial of higher order.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Linear Regression">
      <!-- Linear Regression -->
      <h3 id="15_2_1">15.2.1 Linear Regression</h3>
      <div class="container clearfix">
          <div class="float-sm-right">
              <div class="card">
                  <img src="..\Images\Fig_15_5.PNG" alt="Figure 15.5" class="fig card-image">
                  <p class="figure-name card-title">Figure 15.5: An eyeball estimate of a linear fit</p>
              </div>
              <div class="card">
                  <img src="..\Images\Fig_15_6.PNG" alt="Figure 15.6" class="fig card-image">
                  <p class="figure-name card-title">Figure 15.6: Linear Curve Fit</p>
              </div>
          </div>
          <p>Linear regression is the process that determines the linear equation that is the best fit to a set of data points in terms of minimizing the sum of the squared distances between the line and the data points. To understand this process, first we consider the same set of data values used previously and attempt to "eyeball" a straight line through the data. Assume, for example, that \(y = 20x\) is a good estimate of the curve. Listing 15.3 shows the code to plot the points and this estimate.</p>
          <p>Looking at the results in Figure 15.5, it appears that \(y = 20x\) is a reasonable estimate of a line through the points.</p>
          <p>We really need the ability to compare the quality of the fit of this line to other possible estimates, so we compute the difference between the actual y value and the value calculated from the estimate:</p>
          <p><code>>> dy = [0, 0, 20, 8, -3, 10]</code></p>
          <p>It turns out that the best way to make this comparison is by the <b>least squares technique</b>, whereby the measure of the quality of the fit is the sum of the squared differences between the actual data points and the linear estimates. This sum can be computed with the following command:</p>
          <p><code>>> sum_sq = sum(dy.^2)</code></p>
          <p>For the above set of data, the value of <code>sum_sq</code> is <code>573</code>. As we will see, MATLAB can automatically produce the best linear fit shown in Figure 15.6 whose sum of squares is <code>356.82</code>, a significant improvement over our original guess. This result was achieved by running Exercise 15.2.</p>
        </div>
        <div id="listing_15_3" class="listing">#listing_15_3#</div>
        <div class="exercise">#exercise_15_2#</div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Polynomial Regression">
      <!-- Polynomial Regression -->
      <h3 id="15_2_2">15.2.2	Polynomial Regression</h3>
      <div class="container">
          <p>Linear regression is a special case of the polynomial regression technique. Recall that a polynomial with one variable can be written by using the following formula:</p>
          $$ f(x) = a_0{x^n} + a_1{x^{n-1}} + a_2{x^{n-2}} + a_3{x^{n-3}} + ... a_{n-1}x + a_n $$
          <p>The degree of a polynomial is equal to the largest value used as an exponent. MATLAB provides a pair of functions to compute the coefficients of the best fit to a set of data and then interpolate on those coefficients to produce the data to plot:</p>
          <ul>
              <li><code>coef = polyfit(x, y, n)</code> computes the coefficients of the polynomial of degree <code>n</code> that best matches the given <code>x</code> and <code>y</code> values. The function returns the coefficients, <code>coef</code>, in descending powers of <code>x</code>. For the least squares calculation to work, the length of <code>x</code> should be greater than <code>n - 1</code>. If this is not the case, the coefficients are still computed, but the curve passes through all the data points.</li>
              <li><code>new_y = polyval(coef, new_x)</code> can then be used to interpolate the polynomial defined by these coefficients for the <code>new_y</code> value(s) corresponding to any <code>new_x</code> value(s).</li>
          </ul>
          <p>Note that there is nothing to prevent you from using these coefficients for extrapolation.</p>
          <p>Exercise 15.2 illustrates fitting the best straight line to the data used in Section 15.1.1, indicating that the first-order polynomial that best fits our data is as follows:</p>
          $$ f(x) = 20.8286x + 3.7169 $$
          <p>We could interpolate the values of new_x with: <code>new_y = coef(1) * new_x + coef(2)</code> or we could use the function polyval: <code>new_y = polyfit(coef, new_x)</code> </p>
          <p>We can use our new understanding of the <code>polyfit</code> and <code>polyval</code> functions to write a program to study the improvement in the curve fit as <code>n</code> increases, as shown in Listing 15.4.</p>
          <div id="listing_15_4" class="listing">#listing_15_4#</div>
          <p>The results are shown in Figure 15.7. Notice that with six points, the fifth-order fit goes through all the data points.</p>
          <div class="card">
              <img src="..\Images\Fig_15_7.PNG" alt="Figure 15.7" class="fig-wide card-image">
              <p class="figure-name card-title">Figure 15.7: Higher-order polynomial fits</p>
          </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Practical Application">
      <!-- Practical Application -->
      <h3 id="15_2_3">15.2.3 Practical Application</h3>
      <div class="container">
          <p>We return briefly to the problem of replacing the blue sky in Chapter 13. The sky we used to replace the gray skies of Vienna has a power line we need to remove. We can use polynomial curve fitting to create an artificial sky with exactly the same color characteristics as the blue sky in the cottage picture, but without the wire. This is possible because each row of the image has so much data that define its color profile that the presence of the wire is a minor amount of "noise." We merely need to process each row of the sky, fit a second-order curve to it, interpolate a new sky row from the parameters, and replace the row in the sky. The code to perform this is shown in Listing 15.5.</p>
          <div id="listing_15_5" class="listing">#listing_15_5#</div>
          <div class="card-deck">
              <div class="card">
                  <img src="..\Images\sky.jpg" alt="Figure 15.8" class="fig card-image">
                  <p class="figure-name card-title">Figure 15.8: Updated Sky</p>
              </div>
              <div class="card">
                  <img src="..\Images\newnewVienna.jpg" alt="Figure 15.9" class="fig card-image">
                  <p class="figure-name card-title">Figure 15.9: Updated Picture</p>
              </div>
          </div>
          <p>Figure 15.8 shows the cottage picture updated with a smooth sky. Notice that the chimneys have been smeared off, but this does not affect the part of the sky needed for the Vienna picture. This synthetic sky is ready to be used in the script to replace the original sky (see Listing 13.1). Figure 15.9 shows the Vienna picture with a clear blue synthetic sky.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="3" data-sect-name="Numerical Integration">
    <!-- Numerical Integration -->
    <h2 id="15_3">15.3 Numerical Integration</h2>
    <div class="container clearfix">
        <div class="card float-right">
          <img src="..\Images\Fig_15_10.JPG" alt="Figure 15.10" class="fig card-image">
          <p class="figure-name card-title">Figure 15.10: Integration of \(f(x)\)</p>
        </div>
        <p>The integral of a function \(f(x)\) over the interval \([a, b]\) is defined to be the area under the curve of \(f(x)\) between \(a\) and \(b\), as shown in Figure 15.10. If the value of this integral is \(K\), the notation to represent the integral of \(f(x)\) between \(a\) and \(b\) is as follows:</p>
        $$ K = \int\limits_a^b f(x) dx $$
        <p>For many functions, this integral can be computed analytically. However, for a number of functions, this is not possible, and we require a numerical technique to estimate its value. We look at two different scenarios:</p>
        <ul>
            <li>Two different techniques for computing the complete integral with various degrees of accuracy</li>
            <li>A technique for evaluating the continuous integral of \(f(x)\)</li>
        </ul>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Determination of the Complete Integral">
      <!-- Determination of the Complete Integral -->
      <h3 id="15_3_1">15.3.1 Determination of the Complete Integral</h3>
      <div class="container clearfix">
          <div class="card float-right">
              <img src="..\Images\Fig_15_11.PNG" alt="Figure 15.11" class="fig card-image">
              <p class="figure-name card-title">Figure 15.11: Discrete Integration</p>
          </div>
          <p>Two of the most common numerical integration techniques estimate \(f(x)\) either with a set of piecewise linear functions or with a set of piecewise parabolic functions. If we use piecewise linear functions, we can compute the area of the trapezoids that compose the area under the piecewise linear function. This technique is called the <b>trapezoidal rule</b>. If we use piecewise quadratic functions, we can compute and add the areas of these components. This technique is called <b>Simpson's rule</b>.</p>
      </div>
      <!-- Trapezoidal -->
          <p><b>The Trapezoidal Rule</b> If we represent the area under a curve by trapezoids, as illustrated in Figure 15.11, and if the interval \([a, b]\) is divided into \(n\) equal sections, then the area can be approximated by the following formula:</p>
          $$ K_t = {\frac{b - a}{2n}}{(f(x_0) + 2f(x_1) + 2f(x_2) + ... + 2f(x_{n-1} + f(x_n))} $$
          <p>where the \(x_i\) values  represent  the  end  points  of  the  trapezoids  and where \(x_0 = a\) and \(x_n = b\). Listing 15.6 shows a function that computes this integral.</p>
          <div id="listing_15_6" class="listing">#listing_15_6#</div>
      <!-- Simpsons -->
          <p><b>Simpson's Rule</b> If the area under a curve is represented by areas under quadratic sections of a curve, and if the interval \([a, b]\) is divided into \(2n\) equal sections, then the area can be approximated by the formula (Simpson's rule):
          $$ K_s={\frac{h}{3}}{(f(x_0)+4f(x_1)+2f(x_2)+4f(x_3)+...+2f(x_{2n-2})+4f(x_{2n-1})+f(x_{2n}))} $$
          <br>where the \(x_i\) values represent the end points of the sections, \(x_0 = a\) and \(x_{2n} = b\), and \(h = (b-a) / (2n)\). Listing 15.7 shows a function to integrate using Simpson's rule.</p>
          <div id="listing_15_7" class="listing">#listing_15_7#</div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Continuous Integration Problems">
      <!-- Continuous Integration Problems -->
      <h3 id="15_3_2">15.3.2 Continuous Integration Problems</h3>
      <div class="container">
          <p>We now consider a slightly different scenario. If \(f(t)\) is the rate of change of \(F(t)\) defined as \(f(t) = dF(t)/dt\), then given \(f(t)\), we can find the indefinite integral \(F(t)\) according to the following formula:</p>
          $$ F(t) = \int\limits_{t_0}^t f(x) dt $$
          <p>For example, we might be given data that represent the velocity of a sounding rocket, such as is plotted in Figure 15.12. We need to approximate the altitude of the rocket over time by integrating this data.</p>
          <p>To perform this kind of integral, the MATLAB language provides the function <code>F = cumsum(f)</code> that computes the cumulative sum of the vector <code>f</code>. The result, <code>F</code>, is a vector of the same length as <code>f</code> where <code>F(i)</code> is the sum of <code>f(1:i)</code>. If the data values, <code>f</code>, are regularly sampled at a rate <code>&Delta;t</code>, the integral is found by multiplying <code>cumsum(f)</code> by the time interval, <code>&Delta;t</code>. If they are not regularly sampled, you have to compute the <code>cumsum(...)</code> of the scalar product of <code>f</code> and the vector of time differences.</p>
          <p>To compute a more accurate integral, especially if the samples are not regularly spaced along the independent axis, MATLAB also provides the function <code>cumtrapz(t, f)</code> where <code>t</code> is the independent parameter and <code>f</code> the dependent parameter. The function uses trapezoidal integration to calculate the indefinite integral <code>F(t)</code>.</p>
          <div class="card-deck">
              <div class="card">
                  <img src="..\Images\Fig_15_12.PNG" alt="Figure 15.12" class="fig card-image">
                  <p class="figure-name card-title">Figure 15.12: Velocity of a rocket</p>
              </div>
              <div class="card">
                  <img src="..\Images\Fig_15_13.PNG" alt="Figure 15.13" class="fig card-image">
                  <p class="figure-name card-title">Figure 15.13: Rocket velocity and amplitude</p>
              </div>
          </div>
          <p>Listing 15.8 shows the function that computes this continuous integral, making use of <code>cumsum(...)</code>.</p>
          <p>Figure 15.13 shows the resulting plot. The results displayed in the Command window are:</p>
          <p><code>cumsum height: 1848.5 <br>trapezoidal height: 1811.85 <br>Simpson's Rule height: 1811.14</code></p>
          <p>The continuous integration produces results within 2% of the "accurate" integration techniques.</p>
          <div id="listing_15_8" class="listing">#listing_15_8#</div>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="4" data-sect-name="Numerical Differentiation">
    <!-- Numerical Differentiation -->
    <h2 id="15_4">15.4  Numerical Differentiation</h2>
    <div class="container">
        <p>The derivative of a function \(f(x)\) is defined to be a function \(f'(x)\) that is equal to the rate of change of \(f(x)\) with respect to \(x\). The derivative can be expressed as a ratio, with the change in \(f(x)\) indicated by \(df(x)\) and the change in \(x\) indicated by \(dx\), giving us the following:</p>
        $$ f'(x) = \frac{df(x)}{dx} $$
        <p>There are many physical processes for which we want to measure the rate of change of a variable. For example, velocity is the rate of change of position (as in meters per second), and acceleration is the rate of change of velocity (as in meters per second squared).</p> <p>The derivative \(f'(x)\) can be described graphically as the slope of the function \(f(x)\), which is defined to be the slope of the tangent line to the function at the specified point. Thus, the value of \(f'(x)\) at the point \(a\) is \(f'(a)\), and it is equal to the slope of the tangent line at the point \(a\).</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Difference Expressions">
      <!-- Difference Expressions -->
      <h3 id="15_4_1">15.4.1	Difference Expressions</h3>
      <div class="container">
          <p>In general, numerical differentiation techniques estimate the derivative of a function at a point \(x_k\) by approximating the slope of the tangent line at \(x_k\) using values of the function at points near \(x_k\). The approximation of the slope of the tangent line can be done in several ways, as shown in Figure 15.14.</p>
          <ul>
              <li><i>Backward Difference:</i> Figure 15.14(a) assumes that the derivative at \(x_k\) is estimated by computing the slope of the line between \(f(k_{x - 1})\) and \(f(x_k)\)</li>
              <li><i>Forward Difference:</i> Figure 15.14(b) assumes that the derivative at \(x_k\) is estimated by computing the slope of the line between \(f(x_k\) and \(f(x_{k + 1}\)</li>
              <li><i>Central Difference:</i> Figure 15.14(c) assumes that the derivative at \(x_k\) is estimated by computing the slope of the line between \(f(x_{k-1})\) and \(f(x_{k+1})\)</li>
          </ul>
          <p>The quality of all of these types of derivative computations depends on the distance between the points used to estimate the derivative; the estimate of the derivative improves as the distance between the two points decreases.</p>
          <div class="card">
            <img src="..\Images\Fig_15_14.PNG" alt="Figure 15.14" class="fig-wide card-image">
            <p class="figure-name card-title">Figure 15.14: Difference Techniques</p>
          </div>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="5" data-sect-name="Analytical Operations">
    <!-- Analytical Operations -->
    <h2 id="15_5">15.5 Analytical Operations</h2>
    <div class="container">
        <p>We return to the discussion of fitting a polynomial to some raw data in Section 15.2.2. We approximated a polynomial fit with the following expression:</p>
        $$ f(x) = a_0{x^n} + a_1{x^{n-1}} + a_2{x^{n-2}} + a_3{x^{n-3}} + ... + a_{n-1}{x} + a_n $$
        <p>Since this is an analytical expression, even if some or all of the coefficients are complex, we can integrate it to estimate the integral of the raw data and differentiate it to estimate the slope of the raw data.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Analytical Integration">
      <!-- Analytical Integration -->
      <h3 id="15_5_1">15.5.1	Analytical  Integration</h3>
      <div class="container">
          <p>The expression for F(x), the integral of f(x) with respect to x, is given by:</p>
          $$ F(x) = a_0{x^{n+1}}/{n+1} + a_1{x^n}/n + a_2{x^{n-1}}/{n-1} + a_3{x^{n-2}}/{n-2} + ... + a_{n-1}{x^2}/2 + a_n{x} + K $$
          <p>Note that an arbitrary constant, K, is always required for analytical integration representing the starting value F(0).</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Analytical Differentiation">
      <!-- Analytical Differentiation -->
      <h3 id="15_5_2">15.5.2	Analytical Differentiation</h3>
      <div class="container">
          <p>The expression for fâ€™(x), the integral of f(x) with respect to x, is given by:</p>
          $$ f'(x) = na_0{x^{n-1}} + (n-1)a_1{x^{n-2}} + (n-2)a_2{x^{n-3}} + (n-3)a_3{x^{n-4}} + a_{n-1} $$
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="6" data-sect-name="Implementation">
    <!-- Implementation -->
    <h2 id="15_6">15.6  Implementation</h2>
    <div class="container clearfix">
        <div class="float-sm-right card">
            <img src="..\Images\Fig_15_15.PNG" alt="Figure 15.15" class="fig card-image">
            <p class="figure-name card-title">Figure 15.15: Differentiation</p>
        </div>
        <p>To facilitate differentiation, the MATLAB language defines the <code>diff(...)</code> function, which computes differences between adjacent values in a vector, generating a new vector with one less value than the original:</p>
        <p><code>dv = diff(V) returns [V(2)-V(1), V(3)-V(2), ..., V(n)-V(n-1)]</code></p>
        <p>An approximate derivative \(dy/dx\) can be computed by using <code>diff(y)./ diff(x)</code>. Depending on the application, this can be used to compute the forward, backward, or central difference approximation. The solution to the forward difference is shown in Listing 15.9.</p>
        <p>The results are shown in Figure 15.15. Since the original data were generated from a series of coefficients, we could also plot the exact value of the slope using the result of Section 15.5.2.</p>
    </div>
    <div id="listing_15_9" class="listing">#listing_15_9#</div>
  </div>

  <div class="chp-section" data-sect-num="7" data-sect-name="Engineering Example - Shaping the Synthesizer Notes">
    <!-- Engineering Example -->
    <h2 id="15_7">15.7  Engineering Example - Shaping the Synthesizer Notes</h2>
    <div class="container clearfix">
        <div class="card float-sm-right">
          <img src="..\Images\Fig_15_16.PNG" alt="Figure 15.16" class="fig card-image">
          <p class="figure-name card-title">Figure 15.16: Piano note time history</p>
        </div>
        <p>As discussed in Chapter 14, we can synthesize the frequency content of an instrument by selecting an appropriate number of coefficients from the energy spectrum, multiplying each by an appropriate sine or cosine wave and summing the results. This gives a time trace with constant amplitude, which is fine for an instrument like a trumpet, but notes played on other instruments like a piano have a very non-linear time profile as shown in Figure 15.16. That same figure has two overlays indicating how to develop the decay profile typical of a piano note. First, we choose a modest number of samples that describe the envelope of the sound (marked by red * symbols). Then, we perform a high-order curve fit on that data and check its accuracy by plotting it as the solid line on the same figure.</p>
        <p>To demonstrate the essence of this capability, we begin with Listing 14.6 from Chapter 14, reading the file 'instr_piano.wav' instead of 'instr_tpt.wav.' Now, we insert the code in Listing 15.10 in place of the last two lines of Listing 14.6.</p>
    </div>
        <div id="listing_15_10" class="listing">#listing_15_10#</div>
        <p>In conclusion, with these two engineering examples, we have shown how the essence of the sound of a musical instrument can be derived from the actual sound of an instrument and captured as a small set of complex amplitudes with their frequency value and an even smaller set of real coefficients of the function that multiplies the amplitude over time.</p>
        <p>To construct from these data a real music synthesizer, one need only to detect that a keyboard note has been pressed, determine the required frequency, and play the synthesized note until the key is released. If the synthesizer is equipped to specify that the sustain pedal is depressed, the piano sound should not be cut off, but allowed to fade into silence.</p>
  </div>

  <!-- Chapter Summary -->
  <h2 id="15_Chapter_Summary">Chapter Summary</h2>
  <div class="container">
      <p><i>In this chapter, we saw the implementations of four common numerical techniques:</i></p>
      <ul>
          <li>We can estimate data points between given data values using linear <code>(interp1(...)/interp2(...)/interp3(...))</code> or spline(...) interpolation</li>
          <li>We can smooth noisy data by fitting polynomial curves of suitable order to the raw data</li>
          <li>Given, for example, the velocity of an object over time, we can determine its position by integrating using <code>cumtrapz(...)</code> or <code>cumsum(...)</code></li>
          <li>We can differentiate to generate its acceleration</li>
      </ul>
  </div>
<h2>Self Test</h2>
<div class="container">

Use the following questions to check your understanding of the material in this
chapter:
<h3>True or False</h3>
<ol>
<li>All MATLAB functions permit extrapolation beyond the limits of
the original independent variable.</li>
          <li>The cubic spline is a series of parametric curves.</li>
          <li>You cannot extrapolate the equations generated by curve fitting.</li>
          <li>You should always match the order of a parametric curve fit to the
underlying physics of the data.</li>
          <li>Simpsonâ€™s rule is more accurate than the trapezoidal rule for
integrating a function.</li>
          <li>Numerical differentiation produces a vector that is the same length
as the original vector.</li>
</ol>
<h3>Fill in the Blanks</h3>
<ol>
<li>___________ is the technique by which we estimate a variableâ€™s
value between known values.</li>
          <li>Nth-order polynomial regression determines the ____________ of
order n that minimize the ______________ between the line and the
data points.</li>
          <li>The ___________________makes the slope at x(k) the ______________
of the line between x(k-1) and x(k+1).</li>
          <li>To compute the continuous integral of a data set that is not regularly
sampled, you have to compute the _________________ of the
_______________ of ________________ and __________________.</li>
          <li>If a(n) ____________ is defined by its polynomial coefficients, you
can integrate or differentiate it by _______________ the vector of
coefficients.</li>
</ol>

<h3>Programming Projects</h3>
<ol>
<li>Do the following basic exercises with numerical methods.
<ol type="a">
<li>Define two vectors xi and yi of the same length where the xi
values are monotonically increasing and the yi values are
somehow related to the xi values. Then define a new vector x
with closer spacing than xi and extending below and above the
range of xi . Find the y values corresponding to the x values in xi
by linear interpolation. On the same figure, plot the original yi
vs. xi as red circles, and y vs. x as a black line. What do you
observe about the visible range of the x values?</li>
          <li>Repeat the exercise in part a using the spline(...) function to
interpolate. Explain the difference in the range of the resulting y
vs. x plot.</li>
          <li>Use polyfit(...) to find the coefficients of the third-order
polynomial that best fits the points represented by vectors xi and
yi and then use polyval(...) to evaluate that curve at the x points.
As before, plot yi vs. xi as red circles and y vs. x as a black line.</li>
          <li>Approximate the derivative, dxy = dy/dx, for the vectors xi and
yi using the diff(...) function and plot yi vs. xi . Since
diff(...) reduces the length of the vector by one, you will have
to plot dxy vs. either xi(1:end-1), xi(2:end) or compute xm , the
mid-points of xi.</li>
          <li>Find yp, the cumulative sum of the elements in dxy, and add this
to the plot of part d. With the exception of a constant offset, this
curve ought to track the original plot of yi vs. xi.</li>
          <li>Use cumtrapz to find the area under the curve represented by yp
vs. xi with the trapezoidal method of approximation. Compare
this result to the ending value of the yp curve.</li>
</ol>
          <li>Write a function, bestFit, that takes in a vector of x-coordinates and
a vector of y-coordinates. Your function should fit a polynomial
curve to the data. The degree of the polynomial should be the
smallest degree polynomial with an average error (the average of
the absolute value of the difference between the new y-coordinates
and the original y-coordinates) less than 2. Your function should
return:
<ol type="a">
<li>the vector of coefficients of your polynomial</li>
          <li>the vector of new y-coordinates, which is the polynomial
evaluated at the original x-coordinates, and</li>
          <li>the vector of the error magnitudes of your polynomial.
		  </ol>
Write a test program to provide reasonable data to your function
and plot the original data (in blue), the curve-fitted data (in green),
and the error (in red) on one figure. Title your plot and label your
axes accordingly, including a legend.</li>
          <li>You have been approached by the Rambling Wreck club to test the
performance of the Rambling Wreck. You are provided with the test
results of the car for 10 trial runs in the form of a vector d that
contains the displacement of the car from the origin at that second.
The first element is the displacement at the 0th second, the second
element is the displacement at the 1st second, and so on. Write a
script called testWreck that displays a plot of the speed of the
Rambling Wreck over time during the test run. You could test your
script using:
d = [0 20 35 50 60 55 30 25 15 5];.</li>
          <li>Engineers often use tabulated data for various calculations. An
important method that any good engineer should be able to apply
to tabulated data is interpolation. In thermodynamics, the properties
of a gas can be known when two of its properties have been fixed.
You are required to come up with a continuous function being given
the tabulated data below measured where the pressure is 0.10 MPa:
<table>
<tr><th>Temperature (deg C)</th><th>Specific Volume (cu meters/Kg)</th></tr>
<tr><td>99.63</td><td>1.694</td></tr>
<tr><td>100</td><td>1.696</td></tr>
<tr><td>120</td><td>1.793</td></tr>
<tr><td>160</td><td>1.984</td></tr>
<tr><td>200</td><td>2.172</td></tr>
<tr><td>240</td><td>2.359</td></tr>
<tr><td>280</td><td>2.546</td></tr>
<tr><td>320</td><td>2.732</td></tr>
<tr><td>360</td><td>2.917</td></tr>
<tr><td>400</td><td>3.103</td></tr>
<tr><td>440</td><td>3.288</td></tr>
<tr><td>500</td><td>3.565</td></tr>
</table>
Write a function called lookup that consumes three parameters: the
above table in an array, a number value, and a logical control value
getTemp. If getTemp is true, the function interpolates the value as a
specific volume and returns the corresponding temperature.
Otherwise, it interpolates the value as a temperature and returns the
corresponding specific volume.<br>
Your function must not extrapolate the data (i.e., it should return NaN 
if the user tries to obtain values
outside the range of the table values).</li>
          <li>Mathematically speaking, a critical point occurs when the derivative
of a function equals zero. It is possible that a local minimum or a
local maximum occurs at a critical point. A local minimum is a point
where the function's value to the left and right of it is larger, and a
local maximum is a point where the function's value to the left and
right of it is smaller. You are going to write a function that finds the
local minimum and maximum points of a set of data. Call the
function find_points . It should take in vectors of x and y values and
return two vectors. The first vector should contain the x values
where the minimum points occur, while the second vector should
contain the x values where the maximum points occur.<br>
For example:<br>
If x=linspace(-8,2,1000) and y=x.^2+6*x+3;<br>
[min_p max_p]=find_points(x,y) should return<br>
min_p = -3, max_p = []<br>
If x=linspace(-5,5,1000) and y=x.^3-12*x;<br>
[min_p max_p]=find_points(x,y) should return:<br>
min_p = 2, max_p = -2<br>
You should plot x and y to confirm the answers..</li>
          <li>Now that we used the derivative it only makes sense that you are
going to write a function that finds integrals. Call your function
find_integral . Your function should take in a vector of x and y
values as Problem 15.5 does and should plot the integral and also
return the total area under the function. You are to use the
trapezoidal rule to find the integrals.<br>
For example:<br>
If x=linspace(0,5,1000); and y=2*x+5;<br>
find_integral(x,y) should return 50.0000<br>
 
</ol>
</div>
</div>


</body>
</html>
