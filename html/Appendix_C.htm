<!DOCTYPE HTML>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="styles/styles.css" />
  <script async src="./javascript/index.js"></script>
<title>Appendix C</title>
</head>
<body>
<div>#top_nav#</div>
<div class="nav-obj">#nav_obj#</div>

<div class="content">
  <h1 align="center" id="1">Appendix C - Internal Number Representation</h1>
<p>There are two different techniques whereby most computers today store
the values of<a id="18660"></a> numbers<a id="18638"></a>: integer and<a id="18619"></a> floating-point. Integer storage has the
nice property that it represents the exact value<a id="18686"></a> of<a id="18661"></a> the number stored;
floating-point storage only guarantees a certain number of<a id="18662"></a> digits of<a id="18663"></a>
precision. There is an upper limit to<a id="18646"></a> the values that can be stored in both
integer and<a id="18620"></a> floating-point form. However, significantly larger numbers<a id="18639"></a> can
be stored in floating-point storage than in integer storage.
By default, MATLAB<a id="18628"></a> sets the storage of<a id="18664"></a> numbers<a id="18640"></a> to<a id="18647"></a> double-precision
floating-point representation. However, operations<a id="18659"></a> like reading<a id="18615"></a> images<a id="18613"></a>
into MATLAB<a id="18629"></a> present the large volume of<a id="18665"></a> data<a id="18632"></a> in the more compact
unsigned integer form.</p>
<h2>Integers</h2>
<p>Integers are represented in computer memory by blocks of<a id="18666"></a> data<a id="18633"></a> bits of<a id="18667"></a>
various sizes. Memory is allocated in 8-bit increments, usually referred to<a id="18648"></a>
as bytes; therefore, it is not surprising that integer storage comes in the
same size<a id="18691"></a> increments. For a given size<a id="18692"></a>, the values of<a id="18668"></a> the data<a id="18634"></a> bits are
represented in two different ways—signed or unsigned. Normally, of<a id="18669"></a>
course, we expect a number to<a id="18649"></a> have both positive and<a id="18621"></a> negative values, and<a id="18622"></a>
when the number of<a id="18670"></a> bits is large, this does not seem to<a id="18650"></a> have much impact.
However, when a small number of<a id="18671"></a> bits are used to<a id="18651"></a> store a value<a id="18687"></a>, one of<a id="18672"></a>
those bits must be used to<a id="18652"></a> show that the number is positive or negative. The
range of<a id="18673"></a> numbers<a id="18641"></a> that can be stored is therefore reduced by 1 bit, a factor of<a id="18674"></a>
2. The following figure illustrates the internal storage of<a id="18675"></a> 8-bit unsigned and<a id="18623"></a>
signed values.
Clearly, for<a id="18695"></a> 8 bits, the maximum value<a id="18688"></a> is 127 signed, or 255 unsigned. If
this is not sufficient storage, numbers<a id="18642"></a> can be stored in 16-, 32-, or 64-bit
words, with<a id="18627"></a> the corresponding increase in the maximum stored size<a id="18693"></a>.</p>
<h2>Floating-Point Numbers</h2>
Floating-point numbers<a id="18643"></a> are stored in single precision (32 bits) or double
precision (64 bits) using the IEEE 754 standard. As the name suggests, the
storage format<a id="18614"></a> includes a mantissa and<a id="18624"></a> an exponent, each expressed
internally in a manner similar to<a id="18653"></a> integer storage. The fixed size<a id="18694"></a> of<a id="18676"></a> the
mantissa leads to<a id="18654"></a> the fixed amount of<a id="18677"></a> precision of<a id="18678"></a> each storage type. The
float data<a id="18635"></a> type gives 7 significant decimal digits; the double data<a id="18636"></a> type gives
15 significant decimal digits.<br>
 Note that although this seems to<a id="18655"></a> be a large amount of<a id="18679"></a> precision, you must always
design your programs to<a id="18656"></a> preserve that precision. If, for<a id="18696"></a> example<a id="18685"></a>, you were to<a id="18657"></a> subtract
two numbers<a id="18644"></a> almost equal<a id="18612"></a> in value<a id="18689"></a>, the precision of<a id="18680"></a> the result would be significantly
worse than that of<a id="18681"></a> the original numbers<a id="18645"></a>.
For details of<a id="18682"></a> these storage types<a id="18616"></a>, search the Web for<a id="18697"></a> “IEEE 754 standard.”
At the time of<a id="18683"></a> writing<a id="18618"></a>, there was a good explanation at: http://www.
geocities.com/SiliconValley/Pines/6639/docs/fp_summary<a id="18658"></a>.html
Parameters of<a id="18684"></a> Each Storage Type
The following table describes the most commonly used storage types<a id="18617"></a>
available in MATLAB<a id="18630"></a>, their minimum<a id="18637"></a> and<a id="18625"></a> maximum values, and<a id="18626"></a> their
equivalent names<a id="18690"></a> in C.

<table>
<tr><th>MATLAB<a id="18631"></a> Name</th><th>Size (Bytes)</th><th>Minimum Value</th><th>Maximum Value</th><th>C Name</th></tr>
<tr><td>uint8</td><td>1</td><td>0</td><td>255</td><td>unsigned char</td></tr>
<tr><td>int8</td><td>1</td><td>−128</td><td>127</td><td>char</td></tr>
<tr><td>uint16</td><td>2</td><td>0</td><td>65,536</td><td>unsigned short</td></tr>
<tr><td>int16</td><td>2</td><td>−32,768</td><td>32,767</td><td>short</td></tr>
<tr><td>uint32</td><td>4</td><td>0</td><td>4,294,967,295</td><td>unsigned int</td></tr>
<tr><td>int32</td><td>4</td><td>−2,147,483,648</td><td>2,147,483,647</td><td>int</td></tr>
<tr><td>float</td><td>4</td><td>~−3.4x10<sup>38<sup></td><td>~3.4x10<sup>38</sup></td><td>float</td></tr>
<tr><td>double</td><td>8</td><td>~<sup>−1.7x10<sup>308</sup></td><td>~1.7x10<sup>308</sup></td><td>double</td></tr>

</table>
 </div>


</body>
</html>


