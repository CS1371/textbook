<!DOCTYPE HTML>
<html>
<head>
<title>17_Graphs</title>
<!-- include bootstrap -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
<!-- include stylesheets -->
<link rel="stylesheet" href="styles/styles.css" />
<script async src="./javascript/index.js"></script>
</head>
<body>
<div>#top_nav#</div>
<div class="nav-obj">#nav_obj#</div>

<div class="content">
  <h1 align="center">Chapter 17: Graphs</h1>

  <!-- Chapter Objectives -->
  <h1>Chapter Objectives</h1>
  <div class="container">
      <p>This chapter demonstrates two algorithms that solve two problems that frequently occur in engineering<a id="5422"></a>:</p>
      <ul>
          <li>finding the minimum<a id="5460"></a> spanning tree for a graph and</li>
          <li>finding the best path through a graph.</li>
      </ul>
      <p>However, before we can approach these algorithms, we need to understand the following:</p>
      <ul>
          <li>How to construct and use three special forms of data collection: stacks, queues and priority<a id="5509"></a> queues<li>How to build a model of a graph, and</li>
          <li>How to traverse and search a graph.</li>
      </ul>
  </div>

  <!-- Introduction -->
  <h1>Introduction</h1>
  <div class="container clearfix">
      <div class="float-sm-right card">
        <img src="..\Images\Fig_17_1.JPG" alt="Figure 17.1" class="fig card-image">
        <p class="figure-name card-title">Figure 17.1: Street Map of Atlanta</p>
      </div>
      <p>We first consider the nature of a graph by considering Figure 17.1, a simplified street map of the city of Atlanta taken with permission from the OpenStreetMap project. The data storage tools we have considered so far - vectors, arrays, structure<a id="5590"></a> arrays, and cell arrays<a id="5370"></a> - have essentially been collections<a id="5372"></a> whose elements are linearly related to each other by being organized in rows and columns. However, practical engineering<a id="5423"></a> frequently meets data that are not organized so easily. Graphs are one such data set. The ultimate goal of this chapter is to discuss this most general form of data structure<a id="5591"></a>. We need first to resolve the semantic problem of the name "graph." We typically think of a graph as a plot. However, in computer science, a graph is a collection of nodes connected by edges<a id="5393"></a>. A street map might be a useful mental model of a graph where the streets are the edges<a id="5394"></a> and the intersections are the nodes. To process graphs<a id="5437"></a> effectively, we must first consider three simpler concepts: stacks, queues in general and priority<a id="5510"></a> queues in particular.</p>
  </div>

  <div class="chp-section" data-sect-num="1" data-sect-name="Stacks">
    <!-- Stacks -->
    <h2 id="17_1">17.1  Stacks</h2>
    <div class="container">
        <p>We briefly discussed the concept of stacks in Chapter 9 where a specific kind of stack<a id="5563"></a>, the Activation Stack, is used to manage the workspace of each function<a id="5430"></a> currently active in Matlab. We first consider the general nature and implementation of stacks as special collections<a id="5373"></a> that enable us to process graphs<a id="5438"></a> efficiently. We experience the concept of a stack<a id="5564"></a> every day of our lives. We reproduce here the illustration from Chapter 9 of the plates in the cafeteria.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="The Nature of a Stack">
      <!-- The Nature of a Stack -->
      <h3 id="17_1_1">17.1.1	The Nature of a Stack</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
            <img src="..\Images\Fig_9_1.JPG" alt="Figure 17.2" class="fig card-image">
            <p class="figure-name card-title">Figure 17.2: A Typical Stack</p>
          </div>
          <p>Formally, we refer to a stack<a id="5565"></a> as a Last In/First Out (LIFO) collection, as illustrated in Figure 17.2. The most general form of a stack<a id="5566"></a> is permitted to contain any kind of object, that is, an instance of any data type or class. The plates in the illustration are surrogates for literally anything that could be stored in a Matlab variable<a id="5598"></a>. A cell array<a id="5337"></a>, therefore, would be a good underlying structure<a id="5592"></a> upon which to build stack<a id="5567"></a> behavior. Typically, operations<a id="5477"></a> on a stack<a id="5568"></a> are restricted to the following:</p>
          <ul>
              <li><b>push</b>: puts an object onto the top of the stack<a id="5569"></a>,</li>
              <li><b>dequeue</b>: removes an object from the top of the stack<a id="5570"></a></li>
              <li><b>peek</b>: copies the first object from the stacck without removing it, and</li>
              <li><b>isempty</b> determines whether the stack<a id="5571"></a> is empty<a id="5405"></a>.</li>
          </ul>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Implementing Stacks">
      <!-- Implementing Stacks -->
      <h3 id="17_1_2">17.1.2	Implementing Stacks</h3>
      <div class="container">
          <p>Although there are many ways to implement a stack<a id="5572"></a>, a cell array<a id="5338"></a> is a good choice because it is a linear<a id="5451"></a> collection of objects<a id="5469"></a> that may be of any type and can be extended or shortened without any apparent effort. If we establish a stack<a id="5573"></a> using a cell array<a id="5339"></a>, the implementation of the above behavior is almost trivial. One rather strange characteristic is the need to return the modified stack<a id="5574"></a> to the user. The Matlab tools are:</p>
          <ul>
              <li><code>stk = push(stk, item)</code> concatenates data at the end<a id="5409"></a> of the cell array<a id="5340"></a> returning the new stack<a id="5575"></a> to the user</li>
              <li><code>[stk, item] = pop(stk)</code>: removes the item from the end<a id="5410"></a> of the cell array<a id="5341"></a> and returns that item and the modified stack<a id="5576"></a> to the user</li>
              <li><code>item = peek(<a id="5501"></a>stk)</code>: merely returns the end<a id="5411"></a> item in the cell array<a id="5342"></a> not returning the stack<a id="5577"></a> because it doesn't changed</li>
              <li><code>res = isempty(<a id="5447"></a>stk)</code>: is the standard MATLAB<a id="5458"></a> test for the empty<a id="5406"></a> vector.</li>
          </ul>
          <p>Clearly, because all the cell array<a id="5343"></a> operations<a id="5478"></a> are also accessible to the programmer, nothing prevents an unscrupulous programmer from using other operations<a id="5479"></a> on the stack<a id="5578"></a> — for example, adding an item elsewhere that the top of the stack<a id="5579"></a>. There are computer tools in Object-Oriented Programming that completely encapsulate the data and only permit the specified functions, but the author recommends that a computer language other than Matlab would be more appropriate if you must have this kind of security in your data.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="2" data-sect-name="Queues">
    <!-- Queues -->
    <h2 id="17_2">17.2  Queues</h2>
    <div class="container">
        <p>We first consider the nature and implementation of queue<a id="5524"></a> that, like a stack<a id="5580"></a>, provides special collections<a id="5374"></a> that enable us to process graphs<a id="5439"></a> efficiently. We experience the concept of a queue<a id="5525"></a> every day of our lives. A line of cars waiting for the light to turn green is a queue<a id="5526"></a>; when we stand in line at a store or send a print job to a printer, we experience typical queue<a id="5527"></a> behavior. In general, the first object entering a queue<a id="5528"></a> is the first one to exit the other end<a id="5412"></a>.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="The Nature of a Queue">
      <!-- The Nature of a Queue -->
      <h3 id="17_2_1">17.2.1	The Nature of a Queue</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
            <img src="..\Images\Fig_17_3.JPG" alt="Figure 17.3" class="fig card-image">
            <p class="figure-name card-title">Figure 17.3: A Typical Queue - Rabbits at Starbucks</p>
          </div>
          <p>Formally, we refer to a queue<a id="5529"></a> as a first in/first out (FIFO) collection, as illustrated in Figure 17.3. As with stacks, the most general form of a queue<a id="5530"></a> is permitted to contain any kind of object. Typically, operations<a id="5480"></a> on a queue<a id="5531"></a> are restricted to the following:</p>
          <ul>
              <li><b>enqueue</b> puts an object onto the queue<a id="5532"></a></li>
              <li><b>dequeue</b> removes an object from the queue<a id="5533"></a></li>
              <li><b>peek</b> copies the first object out of the queue<a id="5534"></a> without removing it, and</li>
              <li><b>isempty</b> determine whether the queue<a id="5535"></a> is empty<a id="5407"></a>.</li>
          </ul>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Implementing Queues">
      <!-- Implementing Queues -->
      <h3 id="17_2_2">17.2.2	Implementing Queues</h3>
      <div class="container">
          <p>As with stacks, a cell array<a id="5344"></a> is a good choice upon which to build a queue<a id="5536"></a> because it is a linear<a id="5452"></a> collection of objects<a id="5470"></a> that may be of any type and can be extended or shortened without any apparent effort. If we establish a queue<a id="5537"></a> using a cell array<a id="5345"></a>, the implementation of the above behavior is trivial:</p>
          </ul>
              <li><code>q = enqueue(<a id="5426"></a>q, item)</code> concatenates data at the end<a id="5413"></a> of the cell array<a id="5346"></a></li>
              <li><code>[q item] = dequeue(<a id="5381"></a>q)</code> removes the item from the front of the cell array<a id="5347"></a> and returns that item to the user</li>
              <li><code> item = peek(<a id="5502"></a>q)</code> merely accesses the first item in the cell array<a id="5348"></a></li>
              <li><code> res = isempty(<a id="5448"></a>q)</code> is the standard MATLAB<a id="5459"></a> test for the empty<a id="5408"></a> vector</li>
          </ul>
          <p>As with stacks, in a real application, you might want to implement your queue<a id="5538"></a> with a tool set that protects the integrity of the data, and as with stacks, Matlab is physically incapable of providing this service.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Priority Queues">
      <!-- Priority Queues -->
      <h3 id="17_2_3">17.2.3 Priority Queues</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
            <img src="..\Images\Fig_17_4.JPG" alt="Figure 17.4" class="fig card-image">
            <p class="figure-name card-title">Figure 17.4: A Priority Queue</p>
          </div>
          <p>There are times when we wish ordinary queues were priority<a id="5511"></a> queues. For example, at the printer where you wait an hour for one page while<a id="5601"></a> someone prints large sections of an encyclopedia and you wonder why the print queue<a id="5539"></a> can’t put really small jobs ahead of really large jobs.  The only difference between an ordinary queue<a id="5540"></a> and a priority<a id="5512"></a> queue<a id="5541"></a> is that the objects<a id="5471"></a> on the queue<a id="5542"></a> emerge in a specified order. The rabbits in Figure 14.4 are sorted  by the expected time to prepare the drink they want. This sorting<a id="5562"></a> may be accomplished either as the items are enqueued as illustrated below, or by searching<a id="5561"></a> for the "best" item when performing a dequeue operation<a id="5476"></a>.  The efficiency will be the same.</p>
          <p>In our mechanization of a priority<a id="5513"></a> queue<a id="5543"></a>, the enqueue function<a id="5431"></a> involves adding the new item in order to the queue<a id="5544"></a>. For this to happen, there must be a means of comparing two objects<a id="5472"></a>. Here, we use the function<a id="5432"></a> <code>is_before</code> that generally should be able to compare any two objects<a id="5473"></a>.  In this implementation, it is sufficient to be able to compare numbers<a id="5467"></a>, strings or structures that contain either the <code>fields</code> key or NaN<a id="5463"></a>. Clearly, this function<a id="5433"></a> can be extended as necessary to compare any two objects<a id="5474"></a>.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="3" data-sect-name="Testing Stacks and Queues">
    <!-- Testing Stacks and Queues -->
    <h3 id="17_3">17.3 Testing Stacks and Queues</h3>
    <div class="container">
        <p>It is always advisable to test utility functions thoroughly before using them in complex algorithms. Listing 17.1 shows a script that tests a stack<a id="5581"></a>, a queue<a id="5545"></a> and a priority<a id="5514"></a> queue<a id="5546"></a>.  Following that script as helper<a id="5443"></a> functions are the simple functions that implement all the necessary tools.</p>
        <div class="listing">#listing_17_1#</div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="4" data-sect-name="Graphs">
    <!-- Graphs -->
    <h2 id="17_4">17.4 Graphs</h2>
    <div class="container">
        <p> This chapter focuses on processing a graph — the most general form of dynamic data structure<a id="5593"></a>, an arbitrary collection of nodes connected by edges<a id="5395"></a>. The edges<a id="5396"></a> may be directional<a id="5390"></a> to indicate that the graph can be traversed along that edge in only one direction (like a one-way street). The edges<a id="5397"></a> may also have a value<a id="5597"></a> associated with them to indicate, for example, the cost of traversing that edge. We refer to this as a weighted<a id="5599"></a> graph. For a street map, this cost could either be the distance, or in a more sophisticated system, the travel time—a function<a id="5434"></a> of the distance, the speed limit, and the traffic congestion. Graphs are not required to be completely connected, and they may contain cycles<a id="5377"></a> - closed loops in which the unwary algorithm<a id="5289"></a> could become trapped. Graphs also have no obvious starting and stopping points. Finally, a path on a graph is a connected list of edges<a id="5398"></a> that is the result of traversing a graph.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Graph Examples">
      <!-- Graph Examples -->
      <h3 id="17_4_1">17.4.1 Graph Examples</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
              <img src="..\Images\Fig_17_5.JPG" alt="Figure 17.5" class="fig card-image">
              <p class="figure-name card-title">Figure 17.5: A Simple Graph</p>
          </div>
          <p>A simple graph is shown in Figure 17.5. In the figure, the connection points 0 ... 10 are the nodes and the edges<a id="5399"></a> are the interconnecting lines, which in this example are not directional<a id="5391"></a> but are weighted<a id="5600"></a>. Graphs occur frequently in everyday life, as illustrated by the street map shown in Figure 17.1. Street maps can be conveniently represented as graphs<a id="5440"></a> where intersections are the nodes and streets are the edges<a id="5400"></a>. Streets can be directional<a id="5392"></a> (one-way), and they may have weights associated with them - either the transit time (a function<a id="5435"></a> of the length of the street and its speed limit) or, with access to real-time traffic information, a more complex estimate of the transit time.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Processing Graphs">
      <!-- Processing Graphs -->
      <h3 id="17_4_2">17.4.2	Processing Graphs</h3>
      <div class="container">
        <p>In designing algorithms that operate on graphs<a id="5441"></a> in general, we need to consider the following constraints:</p>
        <ul>
            <li>With cycles<a id="5378"></a> permitted in the data, there is no natural starting point like the beginning of a cell array<a id="5349"></a>. Consequently, the user must always specify a place on the graph to start as well as the place to stop.</li>
            <li>There are no natural “leaf nodes” where a search might have to stop and back up. Consequently, an algorithm<a id="5290"></a> processing a graph must have a means of determining that being at a given node is the “end<a id="5414"></a> of the line.” Typically, this is accomplished by maintaining a collection of visited nodes as it progresses around the graph. Each time a node is considered, the algorithm<a id="5291"></a> must check to see whether that node is already in the visited collection. If so, it refuses to return to that node. The algorithm<a id="5292"></a> must backtrack if it reaches a node from which there is no edge to a node that has not already been visited.</li>
            <li>Whereas on a cell array<a id="5350"></a> there is only one feasible path from one node to another, there may be many possible paths<a id="5483"></a> between two nodes on a graph. The best algorithms that search for paths<a id="5484"></a> must take into account a comparison between paths<a id="5485"></a> to determine the best one.  For a simple, consistent example, consider the graph shown in Figure 17.5. We will use this simple example to demonstrate minimum<a id="5461"></a> spanning trees (MSTs) and finding paths<a id="5486"></a> through the graph.</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="5" data-sect-name="Minimum Spanning Trees">
    <!-- Minimum Spanning Trees -->
    <h2 id="17_5">17.5 Minimum Spanning Trees</h2>
    <div class="container clearfix">
        <p>A Spanning Tree (MST) is a set of edges<a id="5401"></a> identified for a graph that touches all of the nodes of the graph. For example, on a circuit board, power must be distributed to all of the chips on the board. The routing of a power trace to all the power pins would be a spanning tree. More often that not, it is important to have a spanning tree whose length is as short as possible. Finding the shortest spanning tree is referred to as the Minimum Spanning Tree (MST) problem. There may well be multiple spanning trees with the same overall cost and any one of those would satisfy the requirement. There are two practical algorithms commonly used to solve the MST problem:</p>
        <ul>
            <li> Kruscals algorithm<a id="5293"></a>
            <li> Prims<a id="5503"></a> algorithm<a id="5294"></a>
        </ul>
        <div class="float-sm-right card">
          <video controls class="card-image"><source src="..\Images\MST.mp4" type="video/mp4">Fig 17.6 Animation of Prims<a id="5504"></a> MST Algorithm</video>
          <p class="figure-name card-title">Fig 17.6: Animation of Prims<a id="5505"></a> MST Algorithm</p>
        </div>
        <p>Since they are both very similar in concept and produce the correct answer, we will only consider one: Prims<a id="5506"></a> algorithm<a id="5295"></a>.</p>
        <p>Prims<a id="5507"></a> algorithm<a id="5296"></a> finds the subset of the edges<a id="5402"></a> of the graph that connect every node exactly once whose total cost is not greater than that of any other spanning tree. The algorithm<a id="5297"></a> continuously increases the size of a tree, one edge at a time, starting with a tree consisting of a single node, until it spans all the nodes. Specifically, given a graph as defined in Figure 17.5, Prim’s algorithm<a id="5298"></a> proceeds as shown in Listing 17.2.</p>
        <p>Figure 17.6 is a pair of animations of Prims<a id="5508"></a> algorithm<a id="5299"></a> applied to a small graph and then a larger, but still manageable graph.</p>
    </div>
    <div class="listing">#listing_17_2#</div>
</div>

  <div class="chp-section" data-sect-num="6" data-sect-name="Finding Paths through a Graph">
    <!-- Finding Paths through a Graph -->
    <h2 id="17_6">17.6 Finding Paths through a Graph</h2>
    <div class="container">
        <p>This section discusses four algorithms for finding a path from one node on the graph to another. The first three algorithms exhaustively search the graph to find the absolute best path between node pairs by different criteria. These differences of behavior are created by selecting a stack<a id="5582"></a>, a queue<a id="5547"></a> or a priority<a id="5515"></a> queue<a id="5548"></a> as the dynamic container for interim solutions.  The fourth is one of many approximation algorithms typically used to compute a good enough route in circumstances where an exact solution is not feasible.</p>
        <p>Listing 17.3 shows a template for the three exact algorithms.</p>
        <div class="listing">#listing_17_3#</div>
        <p>In this listing, we will use a generic <code>&lt;collection&gt;</code> to substitute for the specific collections<a id="5375"></a> used in the detailed algorithms to follow. We will also use the generic operations<a id="5481"></a> <code>&lt;add(...)&gt;</code> and <code>&lt;remove(...)&gt;</code> as surrogates for the actual operations<a id="5482"></a> on the chosen <code>&lt;collection&gt;</code>. Our objective will be to return a <code>&lt;path&gt;</code> consisting of a sequence of 1 or more nodes.  We will also need the concept of <code>&lt;children&gt;</code> which is a collection of edges<a id="5403"></a> [u,v] where u is the end<a id="5415"></a> of the path and v is not on the current path to prevent cycles<a id="5379"></a> in the path. When choosing which child node to process first, we need a consistent rule. Since our nodes are all numbered, it makes sense to process the child nodes in increasing numerical<a id="5468"></a> order. This will be the rule for all the specific examples to follow.</p>
        <p>For the following three algorithms, we will see two artifacts:</p>
        <ul>
            <li> animations on two graphs<a id="5442"></a> showing how the algorithm<a id="5300"></a> works.  The algorithms on first, small graph will always start at node 1 and stop at node 7. On the larger graph, they start at node 121 and stop at node 1. Comparing these animations will illustrate the relative computational cost of each algorithm<a id="5301"></a>. However, as we will see in section 17.6.4, none of these algorithms are fast enough to handle a graph of any serious size.</li>
            <li> the contents of the collection at the end<a id="5416"></a> of each of the algorithms in the simple case<a id="5365"></a>.</li>
        </ul>
        <p>A serious student will want to trace through the template in Listing 17.3 referring to the animations in order to construct the contents of each collection.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Depth-First Search">
      <!-- Depth-First Search -->
      <h3 id="17_6_1">17.6.1	Depth-First Search (DFS)</h3>
      <div class="container">
          <p>The depth-first path search algorithm<a id="5302"></a> uses a stack<a id="5583"></a> for the <code>&lt;collection&gt;</code> and <code>&lt;push(...)&gt;</code> and <code>&lt;pop(...)&gt;</code> as the functions to add and remove a path from the stack<a id="5584"></a>. As we observe the behavior of the DFS algorithm<a id="5303"></a>, it is clearly the fastest of the three algorithms, but makes no claim at all about the efficiency of the resulting path. As long as there is any connectivity between the starting and ending nodes,<a id="5464"></a> this will find a path.</p>
          <p>As you study the small graph, you would be right to "ask why bother with the stack<a id="5585"></a> at all?" since at every cycle through the template, the algorithm<a id="5304"></a> always takes the last element pushed onto the stack<a id="5586"></a>. As you will see on a careful study of the DFS algorithm<a id="5305"></a> on the larger graph, the stack<a id="5587"></a> is there to resolve the problem of cul-de-sacs. As in real streets that have no outlet, a cul-de-sac can be a physical constraint. However, there can also be logical<a id="5455"></a> cul-de-sacs where a street closes a loop and has no other outlet. The rule to eliminate cycles<a id="5380"></a> will also see this geometry as a virtual cul-de-sac.  In either case<a id="5366"></a>, the paths<a id="5487"></a> on the stack<a id="5588"></a> can be popped off until the algorithm<a id="5306"></a> reaches a node with an alternative path to proceed. The logic<a id="5454"></a> of template in Listing 17.3 will exit from the while<a id="5602"></a> loop if there are no more feasible paths<a id="5488"></a> on the stack<a id="5589"></a>.</p>
          <div class="card-deck">
              <div class="col-sm-7 card">
                  <video controls class="card-image"><source src="..\Images\DFS.mp4" type="video/mp4">Fig 17.7 Animation of DFS Algorithm</video>
                  <p class="figure-name card-title">Fig 17.7: Animation of the DFS Algorithm</p>
              </div>
              <div class="col-sm-5 card">
                  <div class="fig-long">
                      <img src="..\Images\DFS.jpg" alt="Figure 17.8" class="fig card-image">
                  </div>
                  <p class="figure-name card-title">Figure 17.8: Stack after the first DFS search</p>
              </div>
          </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Breadth-First Search">
      <!-- Breadth-First Search -->
      <h3 id="17_6_2">17.6.2	Breadth-First<a id="5363"></a> Search (BFS)</h3>
      <div class="container clearfix">
          <p>Frequently, we actually need the path with the smallest number of nodes between the starting and ending nodes. For example, because changing trains involves walking and waiting, the best path on an urban transit system map is that with the fewest changes, even if the resulting path is longer. To search for the path with the least nodes,<a id="5465"></a> we need an algorithm<a id="5307"></a> that performs a Breadth-First<a id="5364"></a> Search (BFS) on a graph. We will use the template in Listing 17.3 where the <code>&lt;collection&gt;</code> is a <code>&lt;queue<a id="5549"></a>&gt;</code>, the <code>&lt;add&gt;</code> method is <code>&lt;enqueue(<a id="5427"></a>...)&gt;</code> and the &lt;remove(...)&gt; method is <code>&lt;dequeue(<a id="5382"></a>...)&gt;</code>.</p>
          <p>As you observe the animations in Figure 17.9, especially the larger graph, you will see a characteristic rotating search mimicking the ripples on a pond when a pebble is dropped in. This behavior is caused by using the <code>&lt;queue(...)&gt;</code> and will result in the path with the least number of nodes although it may not be the shortest one.  In fact, on the small graph animation, while<a id="5603"></a> there is a path with lower cost that uses one more node, the BFS<a id="5351"></a> algorithm<a id="5308"></a> can't find it. Figure 17.9 shows animations of the same two problems using the BFS<a id="5352"></a> algorithm<a id="5309"></a> - a better approach in that it computes the path with the least number of nodes,<a id="5466"></a> but does not guarantee the best cost.  In fact, neither DFS nor BFS<a id="5353"></a> take cost into account, but merely use it as an observer.  Figure 17.10 shows to state of the queue<a id="5550"></a> at the end<a id="5417"></a> of the first animation.</p>
          <div class="card-deck">
              <div class="col-sm-7 card">
                  <video controls class="card-image"><source src="..\Images\BFS.mp4" type="video/mp4">Fig 17.9: Animation of the BFS<a id="5354"></a> Algorithm</video>
                  <p class="figure-name card-title">Fig 17.9: Animation of the BFS<a id="5355"></a> Algorithm</p>
              </div>
              <div class="col-sm-5 card">
                  <div class="fig-long">
                      <img src="..\Images\BFS.JPG" alt="Figure 17.10" class="fig card-image">
                  </div>
                  <p class="figure-name card-title">Fig 17.10: Queue after the first BFS<a id="5356"></a> search</p>
              </div>
          </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Dijkstras Algorithm">
      <!-- Dijkstras Algorithm -->
      <h3 id="17_6_3">17.6.3	Dijkstras<a id="5383"></a> Algorithm</h3>
      <div class="container">
          <p>Although the minimal number of nodes is sometimes the right answer, frequently there is a path that uses more nodes but has a smaller overall cost. This is evident from a quick glance at Figure 17.5: the path 1-0-5-6-7 has a lower cost than the path 1-0-4-7 found by the BFS<a id="5357"></a> algorithm<a id="5310"></a>, which actually ignores the edge weights. Many algorithms exist for finding the optimal path through a graph. Here we illustrate the algorithm<a id="5311"></a> attributed to the Dutch computer scientist Dr. Edsger Dijkstra. Perhaps it is not the most efficient algorithm<a id="5312"></a>; but for our purposes, this approach has the virtue of being a minor extension to the while<a id="5604"></a> loop algorithm<a id="5313"></a> described in Listing 17.3.  The major differences arise from the use of a priority<a id="5516"></a> queue<a id="5551"></a> in place of the normal queue<a id="5552"></a> used in the BFS<a id="5358"></a> algorithm<a id="5314"></a>.</p>
          <ul>
              <li> As previously noted, priority<a id="5517"></a> queues differ from basic queues only to the extent that the <code>&lt;enqueue(<a id="5428"></a>...)&gt;</code> method puts the data in order, rather than at the tail of the queue<a id="5553"></a>. The ordering criterion required by the algorithm<a id="5315"></a> is to place the paths<a id="5489"></a> in increasing order of path cost. While we have not explicitly dealt with the Big<a id="5361"></a> O of these algorithms, it is clear<a id="5371"></a> in the micro sense that inserting<a id="5444"></a> at the end<a id="5418"></a> of a queue<a id="5554"></a> is O(1) while<a id="5605"></a> inserting<a id="5445"></a> in order in a priority<a id="5518"></a> queue<a id="5555"></a> is O(N) where N is the worst case<a id="5367"></a> of queue<a id="5556"></a> length.</li>
              <li>The objects<a id="5475"></a> contained in the priority<a id="5519"></a> queue<a id="5557"></a> need to contain not only the path, but also the total path weight.</li>
              <li> we have to change the exit strategy in the template shown in Listing 17.2.  For DFS and BFS<a id="5359"></a>, once a path has been added to their collections<a id="5376"></a>, there is no possibility of a "better" path being inserted ahead of that result. Hence, it is fine to perform the exit test when inserting<a id="5446"></a> each child node.  However, this is not the case<a id="5368"></a> for Dijkstras<a id="5384"></a> algorithm<a id="5316"></a>; better paths<a id="5490"></a> can be inserted before any of the paths<a id="5491"></a> entered. In a formal<a id="5429"></a> sense, it is safe to perform the exit test when a path is dequeued. However, when preparing the somewhat intimidating view of the priority<a id="5520"></a> view when the algorithm<a id="5317"></a> completed, we shortened that queue<a id="5558"></a> by realizing that the algorithm<a id="5318"></a> may be stopped when a path of cost N to the end<a id="5419"></a> is enqueued if it is logically impossible for the next step on any of the surviving shorter paths<a id="5492"></a> to reach the ending node with a cost less<a id="5449"></a> than N.</li>
          </ul>
          <p>Figures 17.11 and 17.12 show the animations for the same two problems and the resulting priority<a id="5521"></a> queue<a id="5559"></a> for the smaller case<a id="5369"></a>. While this algorithm<a id="5319"></a> does compute the path with the lowest cost, it does so at considerable extra computation cost, as is evident from the run time of the second animation, the increased Big<a id="5362"></a> O if the enqueue method and the enormous amount of extra stuff packed into the priority<a id="5522"></a> queue<a id="5560"></a> in Figure 17.12.</p>
          <div class="card-deck">
              <div class="col-sm-7 card">
                  <video controls class="card-image"><source src="..\Images\Optimal.mp4" type="video/mp4">Fig 17.11: Animation of Dijkstras<a id="5385"></a> Algorithm</video>
                  <p class="figure-name card-title">Fig 17.11: Animation of Dijkstras<a id="5386"></a> Algorithm</p>
              </div>
              <div class="col-sm-5 card">
                  <div class="fig-long">
                      <img src="..\Images\Opt_p_q.jpg" alt="Figure 17.12" class="fig card-image">
                  </div>
                  <p class="figure-name card-title">Fig 17.12: Priority Queue after the first search</p>
              </div>
          </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="4" data-sub-name="An Approximation Algorithm">
      <!-- An Approximation Algorithm -->
      <h3 id="17_6_4">17.6.4	An Approximation Algorithm</h3>
      <div class="container clearfix">
          <p>As we progressed from DFS to BFS<a id="5360"></a> to Dijkstras<a id="5387"></a> algorithm<a id="5320"></a>, the answers became more precise, but the computational cost was increasing.  Even for a really small proportion of the streets in the Atlanta metropolitan area, the solution became unpleasantly slow. Yet, the Satellite Navigation system on any car  can compute the route from somewhere in the Atlanta, Georgia area to the suburbs of Los Angeles, California in a second or less<a id="5450"></a>. To understand how this can work, we need to look at a fundamental change in the path computation algorithm<a id="5321"></a> and then, in Section 17.6.5 examine some additions to that algorithm<a id="5322"></a> to improve the efficiency and remove some occasional strange behavior.</p>
          <div class="float-sm-right">
              <div class="card">
                  <video controls class="card-image"><source src="..\Images\Greedy.mp4" type="video/mp4">Fig 17.13: Animation of a Greedy Algorithm</video>
                  <p class="figure-name card-title">Fig 17.13: Animation of a Greedy Algorithm</p>
              </div>
              <div class="card">
                  <img src="..\Images\greedy.jpg" alt="Figure 17.14" class="fig card-image">
                  <p class="figure-name card-title">Figure 17.14: Greedy Algorithm at Work</p>
              </div>
          </div>
          <p>First, we change the fundamental algorithm<a id="5323"></a> - we will give up the desire for an exact solution and settle for a strategy that gives us a good enough answer most of the time.  There are many such algorithms that are collectively referred to as "Greedy" algorithms. A greedy algorithm<a id="5324"></a> will produce a solution as long as the graph has sufficient continuity, but is not guaranteed to produce the best. In addition to the cost of each edge, it also requires that each node be aware of its geographic<a id="5436"></a> location. Figure 17.13 shows the usual animations using a crude greedy algorithm<a id="5325"></a>.  Don't blink - you might miss it all.</p>
          <p>The algorithm<a id="5326"></a> is quite simple:</p>
          <ol>
              <li>Beginning at the starting node, it evaluates the result of traveling along each of the feasible edges<a id="5404"></a> to a child node eliminating cyclic paths<a id="5493"></a>. The evaluation takes the form of summing the cost of that edge and an estimate of the cost from that node to the destination. On a street map, for example, the estimated cost of each step would be the length of the edge and the straight-line distance from the new node to the destination.</li>
              <li>It selects the step with the least cost, adds the node reached to the path, and repeats step 1 until the destination is reached, only back-tracking when it hits a physical or logical<a id="5456"></a> cul-de-sac.</li>
              <li>Back-tracking is sometimes necessary if a node is reached from which there are no feasible paths<a id="5494"></a>, such as driving into a physical or logical<a id="5457"></a> cul-de-sac.</li>
              <li>Complete failure is possible, as it is for the other algorithms, if no physical path exists between the origin and destination nodes.</li>
              <li> it is also possible to produce a really silly answer. For example, consider the local street situation shown in Figure 17.14. This is a caricature of my first experiment on the first car I bought that had GPS. Suppose I were to ask for a route from my home to some destination to the South. The path would start with A - D, and it would try and reject B and C when they reached their respective cul-de-sacs. To choose between the remaining children E and J, it would choose E because with any destination to the South, D - E plus E to the destination is shorter. But what about a destination to the North? D - J is then better than D - E, so on my first test of my new Nav system, the stupid thing wants me to go around the loop D - J - K - L - F ...!</li>
          </ol>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="5" data-sub-name="Serious Path Finding Algorithms">
      <!-- Serious Path Finding Algorithms -->
      <h3 id="17_6_5">17.6.5	Serious Path Finding Algorithms</h3>
      <div class="container">
          <p>We have seen earlier that theoretical algorithms are OK for small problems, but for commercial algorithms that process large quantities of data, much care must be taken to ensure that the algorithm<a id="5327"></a> is fast enough and covers the nasty cases that make algorithms look foolish.</p>
          <ul>
              <li><b>"Layering" the problem</b>: Returning to the Sat Nav problem of finding a path from a house in Atlanta to a house in Los Angeles, if you were personally planning that route, you would not need to consider all the surface<a id="5595"></a> streets across the country. Rather, you would probably use a greedy algorithm<a id="5328"></a> to compute the route from the starting place to the nearest expressway on ramp, and from the destination to the nearest off ramp. The remains of the trip would be taken care of with a greedy algorithm<a id="5329"></a> on expressways only from the selected on ramp to the selected off ramp, and then stitch the three paths<a id="5495"></a> together.</li>
              <li><b>Informed Search</b>: A number of researchers have enhanced the basic greedy algorithm<a id="5330"></a> to avoid the silly solutions.  A* is one such algorithm<a id="5331"></a>. It uses heuristics to maintain a small number of competing paths<a id="5496"></a> until they either became too costly or merged to a point where the best can be selected. One aspect of the algorithm<a id="5332"></a> design is choosing how many paths<a id="5497"></a> to maintain. This becomes a trade-off between computational speed and the need to avoid ridiculous behavior.  A normal greedy algorithm<a id="5333"></a> is the fast end<a id="5420"></a> of that spectrum and algorithms like Dijkstras<a id="5388"></a> is the slow end<a id="5421"></a>.</li>
          </ul>
      </div>
    </div>
  </div>
Summary
  <div class="chp-section" data-sect-num="7" data-sect-name="Engineering Applications">
    <!-- Engineering Applications -->
    <h2 id="17_7">17.7	Engineering Applications</h2>
    <div class="container">
        <p>Many practical engineering<a id="5424"></a> problems can be characterized as graph search problems.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Simple Applications">
       <!-- Simple Applications -->
      <h3 id="17_7_1">17.7.1	Simple Applications</h3>
      <div class="container">
          <p>MSTs are used by utility companies to find the least amount of cable that must be used to wire a subdivision.  Approximate path finding is used, for example, in navigation systems that use GPS to find the current position of the vehicle and an approximate, greedy algorithm<a id="5334"></a> to determine the route to a destination.  Exact path finding is used to optimize the flight profile of commercial aircraft outside FAA-managed air space and can save as much as 10% of the fuel burned on every flight.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Complex Extensions">
      <!-- Complex Extensions -->
      <h3 id="17_7_2">17.7.2	Complex Extensions</h3>
      <div class="container">
          <p>In addition to the obvious examples above, consider these examples:</p>
          <ul>
              <li>designing printed circuit boards is a complex extension of path finding</li>
              <li>stresses in a redundant structure<a id="5594"></a> like an aircraft wing seek a path that is in some sense optimal, and</li>
              <li>the 'traveling salesperson problem" is an unpleasant extension of path finding in which the objective is to find the shorted linear<a id="5453"></a> path that connects all of the nodes of a graph visiting each exactly once. For example, designing routes for garbage collection or school buses.</li>
          </ul>
          <p>Each of these belongs to a large class of problems called N-P Complete problems, a continued topic of research in many industrial engineering<a id="5425"></a> communities.</p>
      </div>
    </div>
  </div>

  <!-- Chapter Summaries -->
  <h2>Chapter Summary</h2>
  <p>This chapter demonstrated effective algorithms for finding good paths<a id="5498"></a> through a graph, and included the following:</p>
  <ul>
      <li>How to construct and use queues and priority<a id="5523"></a> queues as the underlying mechanism for graph traversal<a id="5596"></a></li>
      <li>Prim's algorithm<a id="5335"></a> for finding the minimum<a id="5462"></a> spanning tree of a graph</li>
      <li>Depth-first, Breadth-first and Dijkstras<a id="5389"></a> algorithms for finding exact paths<a id="5499"></a>
      through a graph</li>
      <li>A greedy algorithm<a id="5336"></a> for finding approximate paths<a id="5500"></a> that are "good enough."</li>
  </ul>

  <!-- Programming Project -->
  <h2>Programming Project</h2>
  <p>Suppose that we would like to validate the assertion that the London Underground is designed to have at most two train changes between any pair of stations.</p>
  <ul>
      <li>Download the underground map from http://content.tfl.gov.uk/standard-tube-map.pdf.</li>
      <li>Then, construct a graph representing the major routes in that system. You will not need all the stations identified for this exercise - only one station per track segment between transfer stations.</li>
      <li>Write some code that will determine the number of train changes to travel between any pair of stations using a breadth-first search to minimize the number of changes.</li>
      <li>Iterate across every pair of stations and find the station pair with the maximum number of train changes.</li>
      <li>Then, for comparison, go to http://metromap.fr/en for the equivalent map of the Paris metro.</li>
  </ul>
</div>

</body>
</html>

