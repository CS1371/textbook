<!DOCTYPE HTML>
<html>
<head>
<title>17_Graphs</title>
<!-- include bootstrap -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
<!-- include stylesheets -->
<link rel="stylesheet" href="styles/styles.css" />
<script async src="./javascript/index.js"></script>
</head>
<body>
<div>#top_nav#</div>
<div class="nav-obj">#nav_obj#</div>

<div class="content">
  <h1 align="center">Chapter 17: Graphs</h1>

  <!-- Chapter Objectives -->
  <h1>Chapter Objectives</h1>
  <div class="container">
      <p>This chapter demonstrates two algorithms that solve two problems that frequently occur in engineering<a id="17155"></a>:</p>
      <ul>
          <li>finding the minimum<a id="17440"></a> spanning tree for<a id="17901"></a> a graph and<a id="17273"></a></li>
          <li>finding the best path through a graph.</li>
      </ul>
      <p>However, before we can approach these algorithms, we need to<a id="17446"></a> understand the following:</p>
      <ul>
          <li>How to<a id="17447"></a> construct and<a id="17274"></a> use three special forms of<a id="17668"></a> data<a id="17420"></a> collection: stacks, queues and<a id="17275"></a> priority<a id="17611"></a> queues<li>How to<a id="17448"></a> build a model of<a id="17669"></a> a graph, and<a id="17276"></a></li>
          <li>How to<a id="17449"></a> traverse and<a id="17277"></a> search a graph.</li>
      </ul>
  </div>

  <!-- Introduction -->
  <h1>Introduction</h1>
  <div class="container clearfix">
      <div class="float-sm-right card">
        <img src="..\Images\Fig_17_1.JPG" alt="Figure 17.1" class="fig card-image">
        <p class="figure-name card-title">Figure<a id="17944"></a> 17.1: Street Map of<a id="17670"></a> Atlanta</p>
      </div>
      <p>We first consider the nature<a id="17269"></a> of<a id="17671"></a> a graph by considering Figure<a id="17945"></a> 17.1, a simplified street map of<a id="17672"></a> the city of<a id="17673"></a> Atlanta taken with<a id="17355"></a> permission from<a id="17180"></a> the OpenStreetMap project. The data<a id="17421"></a> storage tools we have considered so far - vectors, arrays, structure<a id="17879"></a> arrays, and<a id="17278"></a> cell<a id="<a id="17107"></a>17069"></a> arrays - have essentially been collections<a id="17109"></a> whose elements<a id="17891"></a> are linearly related to<a id="17450"></a> each other by being organized in rows and<a id="17279"></a> columns. However, practical engineering<a id="17156"></a> frequently meets data<a id="17422"></a> that are not organized so easily. Graphs are one such data<a id="17423"></a> set. The ultimate goal of<a id="17674"></a> this chapter is to<a id="17451"></a> discuss this most general form of<a id="17675"></a> data<a id="17424"></a> structure<a id="17880"></a>. We need first to<a id="17452"></a> resolve the semantic problem of<a id="17676"></a> the name "graph." We typically think of<a id="17677"></a> a graph as a plot. However, in computer science, a graph is a collection of<a id="17678"></a> nodes<a id="17219"></a> connected by edges<a id="17126"></a>. A street map might be a useful mental model of<a id="17679"></a> a graph where the streets are the edges<a id="17127"></a> and<a id="17280"></a> the intersections are the nodes<a id="17220"></a>. To process graphs<a id="17160"></a> effectively, we must first consider three simpler concepts: stacks, queues in general and<a id="17281"></a> priority<a id="17612"></a> queues in particular.</p>
  </div>

  <div class="chp-section" data-sect-num="1" data-sect-name="Stacks">
    <!-- Stacks -->
    <h2 id="17_1">17.1  Stacks</h2>
    <div class="container">
        <p>We briefly discussed the concept of<a id="17680"></a> stacks in Chapter 9 where a specific kind of<a id="17681"></a> stack<a id="17852"></a>, the Activation Stack, is used to<a id="17453"></a> manage the workspace of<a id="17682"></a> each function<a id="17174"></a> currently active in Matlab. We first consider the general nature<a id="17270"></a> and<a id="17282"></a> implementation<a id="17663"></a> of<a id="17683"></a> stacks as special collections<a id="17110"></a> that enable us to<a id="17454"></a> process graphs<a id="17161"></a> efficiently. We experience the concept of<a id="17684"></a> a stack<a id="17853"></a> every day of<a id="17685"></a> our lives. We reproduce here the illustration from<a id="17181"></a> Chapter 9 of<a id="17686"></a> the plates in the cafeteria.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="The Nature of a Stack">
      <!-- The Nature of a Stack -->
      <h3 id="17_1_1">17.1.1	The Nature of<a id="17687"></a> a Stack</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
            <img src="..\Images\Fig_9_1.JPG" alt="Figure 17.2" class="fig card-image">
            <p class="figure-name card-title">Figure<a id="17946"></a> 17.2: A Typical Stack</p>
          </div>
          <p>Formally, we refer to<a id="17455"></a> a stack<a id="17854"></a> as a Last In/First Out (LIFO) collection, as illustrated in Figure<a id="17947"></a> 17.2. The most general form of<a id="17688"></a> a stack<a id="17855"></a> is permitted to<a id="17456"></a> contain any kind of<a id="17689"></a> object, that is, an instance of<a id="17690"></a> any data<a id="17425"></a> type or class. The plates in the illustration are surrogates for<a id="17902"></a> literally anything that could be stored in a Matlab variable<a id="17890"></a>. A cell<a id="17070"></a> array<a id="17055"></a>, therefore, would be a good underlying structure<a id="17881"></a> upon which to<a id="17457"></a> build stack<a id="17856"></a> behavior. Typically, operations<a id="17593"></a> on<a id="17384"></a> a stack<a id="17857"></a> are restricted to<a id="17458"></a> the following:</p>
          <ul>
              <li><b>push</b>: puts an object onto the top of<a id="17691"></a> the stack<a id="17858"></a>,</li>
              <li><b>dequeue</b>: removes an object from<a id="17182"></a> the top of<a id="17692"></a> the stack<a id="17859"></a></li>
              <li><b>peek</b>: copies the first object from<a id="17183"></a> the stacck without removing it, and<a id="17283"></a></li>
              <li><b>isempty</b> determines whether the stack<a id="17860"></a> is empty<a id="17138"></a>.</li>
          </ul>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Implementing Stacks">
      <!-- Implementing Stacks -->
      <h3 id="17_1_2">17.1.2	Implementing Stacks</h3>
      <div class="container">
          <p>Although there are many ways to<a id="17459"></a> implement a stack<a id="17861"></a>, a cell<a id="17071"></a> array<a id="17056"></a> is a good choice because it is a linear<a id="17350"></a> collection of<a id="17693"></a> objects<a id="17586"></a> that may be of<a id="17694"></a> any type and<a id="17284"></a> can be extended or shortened without any apparent effort. If we establish a stack<a id="17862"></a> using a cell<a id="17072"></a> array<a id="17057"></a>, the implementation<a id="17664"></a> of<a id="17695"></a> the above behavior is almost trivial. One rather strange characteristic is the need to<a id="17460"></a> return the modified stack<a id="17863"></a> to<a id="17461"></a> the user<a id="17435"></a>. The Matlab tools are:</p>
          <ul>
              <li><code>stk = push(stk, item)</code> concatenates data<a id="17426"></a> at the end<a id="17142"></a> of<a id="17696"></a> the cell<a id="17073"></a> array<a id="17058"></a> returning<a id="17212"></a> the new stack<a id="17864"></a> to<a id="17462"></a> the user<a id="17436"></a></li>
              <li><code>[stk, item] = pop(stk)</code>: removes the item from<a id="17184"></a> the end<a id="17143"></a> of<a id="17697"></a> the cell<a id="17074"></a> array<a id="17059"></a> and<a id="17285"></a> returns that item and<a id="17286"></a> the modified stack<a id="17865"></a> to<a id="17463"></a> the user<a id="17437"></a></li>
              <li><code>item = peek(<a id="17210"></a>stk)</code>: merely returns the end<a id="17144"></a> item in the cell<a id="17075"></a> array<a id="17060"></a> not returning<a id="17213"></a> the stack<a id="17866"></a> because it doesn't changed</li>
              <li><code>res = isempty(<a id="17208"></a>stk)</code>: is the standard MATLAB<a id="17418"></a> test for<a id="17903"></a> the empty<a id="17139"></a> vector.</li>
          </ul>
          <p>Clearly, because all the cell<a id="17076"></a> array<a id="17061"></a> operations<a id="17594"></a> are also accessible to<a id="17464"></a> the programmer, nothing prevents an unscrupulous programmer from<a id="17185"></a> using other operations<a id="17595"></a> on<a id="17385"></a> the stack<a id="17867"></a> — for<a id="17904"></a> example<a id="17839"></a>, adding an item elsewhere that the top of<a id="17698"></a> the stack<a id="17868"></a>. There are computer tools in Object-Oriented Programming that completely encapsulate the data<a id="17427"></a> and<a id="17287"></a> only permit the specified functions<a id="17884"></a>, but the author recommends that a computer language other than Matlab would be more appropriate if you must have this kind of<a id="17699"></a> security in your data<a id="17428"></a>.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="2" data-sect-name="Queues">
    <!-- Queues -->
    <h2 id="17_2">17.2  Queues</h2>
    <div class="container">
        <p>We first consider the nature<a id="17271"></a> and<a id="17288"></a> implementation<a id="17665"></a> of<a id="17700"></a> queue<a id="17626"></a> that, like a stack<a id="17869"></a>, provides special collections<a id="17111"></a> that enable us to<a id="17465"></a> process graphs<a id="17162"></a> efficiently. We experience the concept of<a id="17701"></a> a queue<a id="17627"></a> every day of<a id="17702"></a> our lives. A line of<a id="17703"></a> cars waiting for<a id="17905"></a> the light to<a id="17466"></a> turn green is a queue<a id="17628"></a>; when we stand in line at a store or send a print job to<a id="17467"></a> a printer, we experience typical queue<a id="17629"></a> behavior. In general, the first object entering a queue<a id="17630"></a> is the first one to<a id="17468"></a> exit the other end<a id="17145"></a>.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="The Nature of a Queue">
      <!-- The Nature of a Queue -->
      <h3 id="17_2_1">17.2.1	The Nature of<a id="17704"></a> a Queue</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
            <img src="..\Images\Fig_17_3.JPG" alt="Figure 17.3" class="fig card-image">
            <p class="figure-name card-title">Figure<a id="17948"></a> 17.3: A Typical Queue - Rabbits at Starbucks</p>
          </div>
          <p>Formally, we refer to<a id="17469"></a> a queue<a id="17631"></a> as a first in/first out (FIFO) collection, as illustrated in Figure<a id="17949"></a> 17.3. As with<a id="17356"></a> stacks, the most general form of<a id="17705"></a> a queue<a id="17632"></a> is permitted to<a id="17470"></a> contain any kind of<a id="17706"></a> object. Typically, operations<a id="17596"></a> on<a id="17386"></a> a queue<a id="17633"></a> are restricted to<a id="17471"></a> the following:</p>
          <ul>
              <li><b>enqueue</b> puts an object onto the queue<a id="17634"></a></li>
              <li><b>dequeue</b> removes an object from<a id="17186"></a> the queue<a id="17635"></a></li>
              <li><b>peek</b> copies the first object out of<a id="17707"></a> the queue<a id="17636"></a> without removing it, and<a id="17289"></a></li>
              <li><b>isempty</b> determine whether the queue<a id="17637"></a> is empty<a id="17140"></a>.</li>
          </ul>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Implementing Queues">
      <!-- Implementing Queues -->
      <h3 id="17_2_2">17.2.2	Implementing Queues</h3>
      <div class="container">
          <p>As with<a id="17357"></a> stacks, a cell<a id="17077"></a> array<a id="17062"></a> is a good choice upon which to<a id="17472"></a> build a queue<a id="17638"></a> because it is a linear<a id="17351"></a> collection of<a id="17708"></a> objects<a id="17587"></a> that may be of<a id="17709"></a> any type and<a id="17290"></a> can be extended or shortened without any apparent effort. If we establish a queue<a id="17639"></a> using a cell<a id="17078"></a> array<a id="17063"></a>, the implementation<a id="17666"></a> of<a id="17710"></a> the above behavior is trivial:</p>
          </ul>
              <li><code>q = enqueue(<a id="17170"></a>q, item)</code> concatenates data<a id="17429"></a> at the end<a id="17146"></a> of<a id="17711"></a> the cell<a id="17079"></a> array<a id="17064"></a></li>
              <li><code>[q item] = dequeue(<a id="17121"></a>q)</code> removes the item from<a id="17187"></a> the front of<a id="17712"></a> the cell<a id="17080"></a> array<a id="17065"></a> and<a id="17291"></a> returns that item to<a id="17473"></a> the user<a id="17438"></a></li>
              <li><code> item = peek(<a id="17211"></a>q)</code> merely accesses the first item in the cell<a id="17081"></a> array<a id="17066"></a></li>
              <li><code> res = isempty(<a id="17209"></a>q)</code> is the standard MATLAB<a id="17419"></a> test for<a id="17906"></a> the empty<a id="17141"></a> vector</li>
          </ul>
          <p>As with<a id="17358"></a> stacks, in a real application, you might want to<a id="17474"></a> implement your queue<a id="17640"></a> with<a id="17359"></a> a tool set that protects the integrity of<a id="17713"></a> the data<a id="17430"></a>, and<a id="17292"></a> as with<a id="17360"></a> stacks, Matlab is physically incapable of<a id="17714"></a> providing this service.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Priority Queues">
      <!-- Priority Queues -->
      <h3 id="17_2_3">17.2.3 Priority Queues</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
            <img src="..\Images\Fig_17_4.JPG" alt="Figure 17.4" class="fig card-image">
            <p class="figure-name card-title">Figure<a id="17950"></a> 17.4: A Priority Queue</p>
          </div>
          <p>There are times when we wish ordinary queues were priority<a id="17613"></a> queues. For example<a id="17840"></a>, at the printer where you wait an hour for<a id="17907"></a> one page while<a id="17896"></a> someone prints large sections of<a id="17715"></a> an encyclopedia and<a id="17293"></a> you wonder why the print queue<a id="17641"></a> can’t put really small jobs ahead of<a id="17716"></a> really large jobs.  The only difference between an ordinary queue<a id="17642"></a> and<a id="17294"></a> a priority<a id="17614"></a> queue<a id="17643"></a> is that the objects<a id="17588"></a> on<a id="17387"></a> the queue<a id="17644"></a> emerge in a specified order. The rabbits in Figure<a id="17951"></a> 14.4 are sorted  by the expected time to<a id="17475"></a> prepare the drink they want. This sorting<a id="17115"></a> may be accomplished either as the items are enqueued as illustrated below, or by searching<a id="17114"></a> for<a id="17908"></a> the "best" item when performing a dequeue operation<a id="17272"></a>.  The efficiency will be the same.</p>
          <p>In our mechanization of<a id="17717"></a> a priority<a id="17615"></a> queue<a id="17645"></a>, the enqueue function<a id="17175"></a> involves adding the new item in order to<a id="17476"></a> the queue<a id="17646"></a>. For this to<a id="17477"></a> happen, there must be a means of<a id="17718"></a> comparing two objects<a id="17589"></a>. Here, we use the function<a id="17176"></a> <code>is_before</code> that generally should be able to<a id="17478"></a> compare any two objects<a id="17590"></a>.  In this implementation<a id="17667"></a>, it is sufficient to<a id="17479"></a> be able to<a id="17480"></a> compare numbers<a id="17445"></a>, strings or structures<a id="17214"></a> that contain either the <code>fields</code> key or NaN<a id="17444"></a>. Clearly, this function<a id="17177"></a> can be extended as necessary to<a id="17481"></a> compare any two objects<a id="17591"></a>.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="3" data-sect-name="Testing Stacks and Queues">
    <!-- Testing Stacks and Queues -->
    <h3 id="17_3">17.3 Testing Stacks and<a id="17295"></a> Queues</h3>
    <div class="container">
        <p>It is always advisable to<a id="17482"></a> test utility functions<a id="17885"></a> thoroughly before using them in complex algorithms. Listing 17.1 shows a script that tests a stack<a id="17870"></a>, a queue<a id="17647"></a> and<a id="17296"></a> a priority<a id="17616"></a> queue<a id="17648"></a>.  Following that script as helper<a id="17268"></a> functions<a id="17886"></a> are the simple functions<a id="17887"></a> that implement all the necessary tools.</p>
        <div class="listing">#listing_17_1#</div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="4" data-sect-name="Graphs">
    <!-- Graphs -->
    <h2 id="17_4">17.4 Graphs</h2>
    <div class="container">
        <p> This chapter focuses on<a id="17388"></a> processing<a id="17260"></a> a graph — the most general form of<a id="17719"></a> dynamic data<a id="17431"></a> structure<a id="17882"></a>, an arbitrary collection of<a id="17720"></a> nodes<a id="17221"></a> connected by edges<a id="17128"></a>. The edges<a id="17129"></a> may be directional<a id="17123"></a> to<a id="17483"></a> indicate that the graph can be traversed along that edge in only one direction (like a one-way street). The edges<a id="17130"></a> may also have a value<a id="17889"></a> associated with<a id="17361"></a> them to<a id="17484"></a> indicate, for<a id="17909"></a> example<a id="17841"></a>, the cost of<a id="17721"></a> traversing<a id="17599"></a> that edge. We refer to<a id="17485"></a> this as a weighted<a id="17894"></a> graph. For a street map, this cost could either be the distance, or in a more sophisticated system, the travel time—a function<a id="17178"></a> of<a id="17722"></a> the distance, the speed limit, and<a id="17297"></a> the traffic congestion. Graphs are not required to<a id="17486"></a> be completely connected, and<a id="17298"></a> they may contain cycles<a id="17117"></a> - closed loops in which the unwary algorithm<a id="16992"></a> could become trapped. Graphs also have no obvious starting and<a id="17299"></a> stopping points. Finally, a path on<a id="17389"></a> a graph is a connected list of<a id="17723"></a> edges<a id="17131"></a> that is the result of<a id="17724"></a> traversing<a id="17600"></a> a graph.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Graph Examples">
      <!-- Graph Examples -->
      <h3 id="17_4_1">17.4.1 Graph Examples</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
              <img src="..\Images\Fig_17_5.JPG" alt="Figure 17.5" class="fig card-image">
              <p class="figure-name card-title">Figure<a id="17952"></a> 17.5: A Simple Graph</p>
          </div>
          <p>A simple graph is shown in Figure<a id="17953"></a> 17.5. In the figure, the connection points 0 ... 10 are the nodes<a id="17222"></a> and<a id="17300"></a> the edges<a id="17132"></a> are the interconnecting lines, which in this example<a id="17842"></a> are not directional<a id="17124"></a> but are weighted<a id="17895"></a>. Graphs occur frequently in everyday life, as illustrated by the street map shown in Figure<a id="17954"></a> 17.1. Street maps can be conveniently represented as graphs<a id="17163"></a> where intersections are the nodes<a id="17223"></a> and<a id="17301"></a> streets are the edges<a id="17133"></a>. Streets can be directional<a id="17125"></a> (one-way), and<a id="17302"></a> they may have weights associated with<a id="17362"></a> them - either the transit time (a function<a id="17179"></a> of<a id="17725"></a> the length of<a id="17726"></a> the street and<a id="17303"></a> its speed limit) or, with<a id="17363"></a> access to<a id="17487"></a> real-time traffic information, a more complex estimate of<a id="17727"></a> the transit time.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Processing Graphs">
      <!-- Processing Graphs -->
      <h3 id="17_4_2">17.4.2	Processing Graphs</h3>
      <div class="container">
        <p>In designing algorithms that operate on<a id="17390"></a> graphs<a id="17164"></a> in general, we need to<a id="17488"></a> consider the following constraints:</p>
        <ul>
            <li>With cycles<a id="17118"></a> permitted in the data<a id="17432"></a>, there is no natural starting point like the beginning of<a id="17728"></a> a cell<a id="17082"></a> array<a id="17067"></a>. Consequently, the user<a id="17439"></a> must always specify a place on<a id="17391"></a> the graph to<a id="17489"></a> start as well as the place to<a id="17490"></a> stop.</li>
            <li>There are no natural “leaf nodes<a id="17224"></a>” where a search might have to<a id="17491"></a> stop and<a id="17304"></a> back up. Consequently, an algorithm<a id="16993"></a> processing<a id="17261"></a> a graph must have a means of<a id="17729"></a> determining that being at a given node is the “end<a id="17147"></a> of<a id="17730"></a> the line.” Typically, this is accomplished by maintaining a collection of<a id="17731"></a> visited nodes<a id="17225"></a> as it progresses around the graph. Each time a node is considered, the algorithm<a id="16994"></a> must check to<a id="17492"></a> see whether that node is already in the visited collection. If so, it refuses to<a id="17493"></a> return to<a id="17494"></a> that node. The algorithm<a id="16995"></a> must backtrack if it reaches a node from<a id="17188"></a> which there is no edge to<a id="17495"></a> a node that has not already been visited.</li>
            <li>Whereas on<a id="17392"></a> a cell<a id="17083"></a> array<a id="17068"></a> there is only one feasible path from<a id="17189"></a> one node to<a id="17496"></a> another, there may be many possible paths<a id="17242"></a> between two nodes<a id="17226"></a> on<a id="17393"></a> a graph. The best algorithms that search for<a id="17910"></a> paths<a id="17243"></a> must take into account a comparison between paths<a id="17244"></a> to<a id="17497"></a> determine the best one.  For a simple, consistent example<a id="17843"></a>, consider the graph shown in Figure<a id="17955"></a> 17.5. We will use this simple example<a id="17844"></a> to<a id="17498"></a> demonstrate minimum<a id="17441"></a> spanning trees (MSTs) and<a id="17305"></a> finding paths<a id="17245"></a> through the graph.</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="5" data-sect-name="Minimum Spanning Trees">
    <!-- Minimum Spanning Trees -->
    <h2 id="17_5">17.5 Minimum Spanning Trees</h2>
    <div class="container clearfix">
        <p>A Spanning Tree (MST) is a set of<a id="17732"></a> edges<a id="17134"></a> identified for<a id="17911"></a> a graph that touches all of<a id="17733"></a> the nodes<a id="17227"></a> of<a id="17734"></a> the graph. For example<a id="17845"></a>, on<a id="17394"></a> a circuit board, power must be distributed to<a id="17499"></a> all of<a id="17735"></a> the chips on<a id="17395"></a> the board. The routing of<a id="17736"></a> a power trace to<a id="17500"></a> all the power pins would be a spanning tree. More often that not, it is important to<a id="17501"></a> have a spanning tree whose length is as short as possible. Finding the shortest spanning tree is referred to<a id="17502"></a> as the Minimum Spanning Tree (MST) problem. There may well be multiple spanning trees with<a id="17364"></a> the same overall cost and<a id="17306"></a> any one of<a id="17737"></a> those would satisfy the requirement. There are two practical algorithms commonly used to<a id="17503"></a> solve the MST problem:</p>
        <ul>
            <li> Kruscals algorithm<a id="16996"></a>
            <li> Prims<a id="17049"></a> algorithm<a id="16997"></a>
        </ul>
        <div class="float-sm-right card">
          <video controls class="card-image"><source src="..\Images\MST.mp4" type="video/mp4">Fig 17.6 Animation of<a id="17738"></a> Prims<a id="17050"></a> MST Algorithm</video>
          <p class="figure-name card-title">Fig 17.6: Animation of<a id="17739"></a> Prims<a id="17051"></a> MST Algorithm</p>
        </div>
        <p>Since they are both very similar in concept and<a id="17307"></a> produce the correct answer, we will only consider one: Prims<a id="17052"></a> algorithm<a id="16998"></a>.</p>
        <p>Prims<a id="17053"></a> algorithm<a id="16999"></a> finds the subset of<a id="17740"></a> the edges<a id="17135"></a> of<a id="17741"></a> the graph that connect every node exactly once whose total cost is not greater than that of<a id="17742"></a> any other spanning tree. The algorithm<a id="17000"></a> continuously increases the size<a id="17892"></a> of<a id="17743"></a> a tree, one edge at a time, starting with<a id="17365"></a> a tree consisting of<a id="17744"></a> a single node, until it spans all the nodes<a id="17228"></a>. Specifically, given a graph as defined<a id="17215"></a> in Figure<a id="17956"></a> 17.5, Prim’s algorithm<a id="17001"></a> proceeds as shown in Listing 17.2.</p>
        <p>Figure<a id="17957"></a> 17.6 is a pair of<a id="17745"></a> animations of<a id="17746"></a> Prims<a id="17054"></a> algorithm<a id="17002"></a> applied to<a id="17504"></a> a small graph and<a id="17308"></a> then a larger, but still manageable graph.</p>
    </div>
    <div class="listing">#listing_17_2#</div>
</div>

  <div class="chp-section" data-sect-num="6" data-sect-name="Finding Paths through a Graph">
    <!-- Finding Paths through a Graph -->
    <h2 id="17_6">17.6 Finding Paths through a Graph</h2>
    <div class="container">
        <p>This section discusses four algorithms for<a id="17912"></a> finding a path from<a id="17190"></a> one node on<a id="17396"></a> the graph to<a id="17505"></a> another. The first three algorithms exhaustively search the graph to<a id="17506"></a> find the absolute best path between node pairs by different criteria. These differences of<a id="17747"></a> behavior are created by selecting a stack<a id="17871"></a>, a queue<a id="17649"></a> or a priority<a id="17617"></a> queue<a id="17650"></a> as the dynamic container for<a id="17913"></a> interim solutions.  The fourth is one of<a id="17748"></a> many approximation algorithms typically used to<a id="17507"></a> compute a good enough route in circumstances where an exact solution is not feasible.</p>
        <p>Listing 17.3 shows a template<a id="17262"></a> for<a id="17914"></a> the three exact algorithms.</p>
        <div class="listing">#listing_17_3#</div>
        <p>In this listing, we will use a generic <code>&lt;collection&gt;</code> to<a id="17508"></a> substitute for<a id="17915"></a> the specific collections<a id="17112"></a> used in the detailed algorithms to<a id="17509"></a> follow. We will also use the generic operations<a id="17597"></a> <code>&lt;add(...)&gt;</code> and<a id="17309"></a> <code>&lt;remove(...)&gt;</code> as surrogates for<a id="17916"></a> the actual operations<a id="17598"></a> on<a id="17397"></a> the chosen <code>&lt;collection&gt;</code>. Our objective will be to<a id="17510"></a> return a <code>&lt;path&gt;</code> consisting of<a id="17749"></a> a sequence of<a id="17750"></a> 1 or more nodes<a id="17229"></a>.  We will also need the concept of<a id="17751"></a> <code>&lt;children&gt;</code> which is a collection of<a id="17752"></a> edges<a id="17136"></a> [u,v] where u is the end<a id="17148"></a> of<a id="17753"></a> the path and<a id="17310"></a> v is not on<a id="17398"></a> the current path to<a id="17511"></a> prevent cycles<a id="17119"></a> in the path. When choosing which child node to<a id="17512"></a> process first, we need a consistent rule. Since our nodes<a id="17230"></a> are all numbered, it makes sense to<a id="17513"></a> process the child nodes<a id="17231"></a> in increasing numerical<a id="17585"></a> order. This will be the rule for<a id="17917"></a> all the specific examples<a id="17216"></a> to<a id="17514"></a> follow.</p>
        <p>For the following three algorithms, we will see two artifacts:</p>
        <ul>
            <li> animations on<a id="17399"></a> two graphs<a id="17165"></a> showing how the algorithm<a id="17003"></a> works.  The algorithms on<a id="17400"></a> first, small graph will always start at node 1 and<a id="17311"></a> stop at node 7. On the larger graph, they start at node 121 and<a id="17312"></a> stop at node 1. Comparing these animations will illustrate the relative computational cost of<a id="17754"></a> each algorithm<a id="17004"></a>. However, as we will see in section 17.6.4, none of<a id="17755"></a> these algorithms are fast enough to<a id="17515"></a> handle a graph of<a id="17756"></a> any serious size<a id="17893"></a>.</li>
            <li> the contents of<a id="17757"></a> the collection at the end<a id="17149"></a> of<a id="17758"></a> each of<a id="17759"></a> the algorithms in the simple case<a id="17102"></a>.</li>
        </ul>
        <p>A serious student will want to<a id="17516"></a> trace through the template<a id="17263"></a> in Listing 17.3 referring to<a id="17517"></a> the animations in order to<a id="17518"></a> construct the contents of<a id="17760"></a> each collection.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Depth-First Search">
      <!-- Depth-First Search -->
      <h3 id="17_6_1">17.6.1	Depth-First<a id="17609"></a> Search (DFS)</h3>
      <div class="container">
          <p>The depth-first path search algorithm<a id="17005"></a> uses a stack<a id="17872"></a> for<a id="17918"></a> the <code>&lt;collection&gt;</code> and<a id="17313"></a> <code>&lt;push(...)&gt;</code> and<a id="17314"></a> <code>&lt;pop(...)&gt;</code> as the functions<a id="17888"></a> to<a id="17519"></a> add and<a id="17315"></a> remove a path from<a id="17191"></a> the stack<a id="17873"></a>. As we observe the behavior of<a id="17761"></a> the DFS algorithm<a id="17006"></a>, it is clearly the fastest of<a id="17762"></a> the three algorithms, but makes no claim at all about the efficiency of<a id="17763"></a> the resulting path. As long as there is any connectivity between the starting and<a id="17316"></a> ending nodes<a id="17232"></a>, this will find a path.</p>
          <p>As you study the small graph, you would be right to<a id="17520"></a> "ask why bother with<a id="17366"></a> the stack<a id="17874"></a> at all?" since at every cycle through the template<a id="17264"></a>, the algorithm<a id="17007"></a> always takes the last element pushed onto the stack<a id="17875"></a>. As you will see on<a id="17401"></a> a careful study of<a id="17764"></a> the DFS algorithm<a id="17008"></a> on<a id="17402"></a> the larger graph, the stack<a id="17876"></a> is there to<a id="17521"></a> resolve the problem of<a id="17765"></a> cul-de-sacs. As in real streets that have no outlet, a cul-de-sac can be a physical<a id="17166"></a> constraint. However, there can also be logical<a id="17087"></a> cul-de-sacs where a street closes a loop and<a id="17317"></a> has no other outlet. The rule to<a id="17522"></a> eliminate cycles<a id="17120"></a> will also see this geometry as a virtual cul-de-sac.  In either case<a id="17103"></a>, the paths<a id="17246"></a> on<a id="17403"></a> the stack<a id="17877"></a> can be popped off until the algorithm<a id="17009"></a> reaches a node with<a id="17367"></a> an alternative path to<a id="17523"></a> proceed. The logic<a id="17383"></a> of<a id="17766"></a> template<a id="17265"></a> in Listing 17.3 will exit from<a id="17192"></a> the while<a id="17897"></a> loop if there are no more feasible paths<a id="17247"></a> on<a id="17404"></a> the stack<a id="17878"></a>.</p>
          <div class="card-deck">
              <div class="col-sm-7 card">
                  <video controls class="card-image"><source src="..\Images\DFS.mp4" type="video/mp4">Fig 17.7 Animation of<a id="17767"></a> DFS Algorithm</video>
                  <p class="figure-name card-title">Fig 17.7: Animation of<a id="17768"></a> the DFS Algorithm</p>
              </div>
              <div class="col-sm-5 card">
                  <div class="fig-long">
                      <img src="..\Images\DFS.jpg" alt="Figure 17.8" class="fig card-image">
                  </div>
                  <p class="figure-name card-title">Figure<a id="17958"></a> 17.8: Stack after the first DFS search</p>
              </div>
          </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Breadth-First Search">
      <!-- Breadth-First Search -->
      <h3 id="17_6_2">17.6.2	Breadth-First<a id="17040"></a> Search (BFS)</h3>
      <div class="container clearfix">
          <p>Frequently, we actually need the path with<a id="17368"></a> the smallest number of<a id="17769"></a> nodes<a id="17233"></a> between the starting and<a id="17318"></a> ending nodes<a id="17234"></a>. For example<a id="17846"></a>, because changing<a id="17443"></a> trains involves walking and<a id="17319"></a> waiting, the best path on<a id="17405"></a> an urban transit system map is that with<a id="17369"></a> the fewest changes, even if the resulting path is longer. To search for<a id="17919"></a> the path with<a id="17370"></a> the least nodes<a id="17235"></a>, we need an algorithm<a id="17010"></a> that performs a Breadth-First<a id="17041"></a> Search (BFS) on<a id="17406"></a> a graph. We will use the template<a id="17266"></a> in Listing 17.3 where the <code>&lt;collection&gt;</code> is a <code>&lt;queue<a id="17651"></a>&gt;</code>, the <code>&lt;add&gt;</code> method is <code>&lt;enqueue(<a id="17171"></a>...)&gt;</code> and<a id="17320"></a> the &lt;remove(...)&gt; method is <code>&lt;dequeue(<a id="17122"></a>...)&gt;</code>.</p>
          <p>As you observe the animations in Figure<a id="17959"></a> 17.9, especially the larger graph, you will see a characteristic rotating<a id="17382"></a> search mimicking the ripples on<a id="17407"></a> a pond when a pebble is dropped in. This behavior is caused by using the <code>&lt;queue(...)&gt;</code> and<a id="17321"></a> will result in the path with<a id="17371"></a> the least number of<a id="17770"></a> nodes<a id="17236"></a> although it may not be the shortest one.  In fact, on<a id="17408"></a> the small graph animation, while<a id="17898"></a> there is a path with<a id="17372"></a> lower cost that uses one more node, the BFS<a id="17090"></a> algorithm<a id="17011"></a> can't find it. Figure<a id="17960"></a> 17.9 shows animations of<a id="17771"></a> the same two problems using the BFS<a id="17091"></a> algorithm<a id="17012"></a> - a better approach in that it computes the path with<a id="17373"></a> the least number of<a id="17772"></a> nodes<a id="17237"></a>, but does not guarantee the best cost.  In fact, neither DFS nor BFS<a id="17092"></a> take cost into account, but merely use it as an observer.  Figure<a id="17961"></a> 17.10 shows to<a id="17524"></a> state of<a id="17773"></a> the queue<a id="17652"></a> at the end<a id="17150"></a> of<a id="17774"></a> the first animation.</p>
          <div class="card-deck">
              <div class="col-sm-7 card">
                  <video controls class="card-image"><source src="..\Images\BFS.mp4" type="video/mp4">Fig 17.9: Animation of<a id="17775"></a> the BFS<a id="17093"></a> Algorithm</video>
                  <p class="figure-name card-title">Fig 17.9: Animation of<a id="17776"></a> the BFS<a id="17094"></a> Algorithm</p>
              </div>
              <div class="col-sm-5 card">
                  <div class="fig-long">
                      <img src="..\Images\BFS.JPG" alt="Figure 17.10" class="fig card-image">
                  </div>
                  <p class="figure-name card-title">Fig 17.10: Queue after the first BFS<a id="17095"></a> search</p>
              </div>
          </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Dijkstras Algorithm">
      <!-- Dijkstras Algorithm -->
      <h3 id="17_6_3">17.6.3	Dijkstras<a id="17042"></a> Algorithm</h3>
      <div class="container">
          <p>Although the minimal number of<a id="17777"></a> nodes<a id="17238"></a> is sometimes the right answer, frequently there is a path that uses more nodes<a id="17239"></a> but has a smaller overall cost. This is evident from<a id="17193"></a> a quick<a id="17851"></a> glance at Figure<a id="17962"></a> 17.5: the path 1-0-5-6-7 has a lower cost than the path 1-0-4-7 found by the BFS<a id="17096"></a> algorithm<a id="17013"></a>, which actually ignores the edge weights. Many algorithms exist for<a id="17920"></a> finding the optimal path through a graph. Here we illustrate the algorithm<a id="17014"></a> attributed to<a id="17525"></a> the Dutch computer scientist Dr. Edsger Dijkstra. Perhaps it is not the most efficient algorithm<a id="17015"></a>; but for<a id="17921"></a> our purposes, this approach has the virtue of<a id="17778"></a> being a minor extension to<a id="17526"></a> the while<a id="17899"></a> loop algorithm<a id="17016"></a> described in Listing 17.3.  The major differences arise from<a id="17194"></a> the use of<a id="17779"></a> a priority<a id="17618"></a> queue<a id="17653"></a> in place of<a id="17780"></a> the normal queue<a id="17654"></a> used in the BFS<a id="17097"></a> algorithm<a id="17017"></a>.</p>
          <ul>
              <li> As previously noted, priority<a id="17619"></a> queues differ from<a id="17195"></a> basic queues only to<a id="17527"></a> the extent that the <code>&lt;enqueue(<a id="17172"></a>...)&gt;</code> method puts the data<a id="17433"></a> in order, rather than at the tail of<a id="17781"></a> the queue<a id="17655"></a>. The ordering criterion required by the algorithm<a id="17018"></a> is to<a id="17528"></a> place the paths<a id="17248"></a> in increasing order of<a id="17782"></a> path cost. While we have not explicitly dealt with<a id="17374"></a> the Big<a id="17100"></a> O of<a id="17783"></a> these algorithms, it is clear<a id="17108"></a> in the micro sense that inserting<a id="17084"></a> at the end<a id="17151"></a> of<a id="17784"></a> a queue<a id="17656"></a> is O(1) while<a id="17900"></a> inserting<a id="17085"></a> in order in a priority<a id="17620"></a> queue<a id="17657"></a> is O(N) where N is the worst case<a id="17104"></a> of<a id="17785"></a> queue<a id="17658"></a> length.</li>
              <li>The objects<a id="17592"></a> contained in the priority<a id="17621"></a> queue<a id="17659"></a> need to<a id="17529"></a> contain not only the path, but also the total path weight.</li>
              <li> we have to<a id="17530"></a> change the exit strategy in the template<a id="17267"></a> shown in Listing 17.2.  For DFS and<a id="17322"></a> BFS<a id="17098"></a>, once a path has been added to<a id="17531"></a> their collections<a id="17113"></a>, there is no possibility of<a id="17786"></a> a "better" path being inserted ahead of<a id="17787"></a> that result. Hence, it is fine to<a id="17532"></a> perform the exit test when inserting<a id="17086"></a> each child node.  However, this is not the case<a id="17105"></a> for<a id="17922"></a> Dijkstras<a id="17043"></a> algorithm<a id="17019"></a>; better paths<a id="17249"></a> can be inserted before any of<a id="17788"></a> the paths<a id="17250"></a> entered. In a formal<a id="17173"></a> sense, it is safe to<a id="17533"></a> perform the exit test when a path is dequeued. However, when preparing the somewhat intimidating view of<a id="17789"></a> the priority<a id="17622"></a> view when the algorithm<a id="17020"></a> completed, we shortened that queue<a id="17660"></a> by realizing that the algorithm<a id="17021"></a> may be stopped when a path of<a id="17790"></a> cost N to<a id="17534"></a> the end<a id="17152"></a> is enqueued if it is logically impossible for<a id="17923"></a> the next step on<a id="17409"></a> any of<a id="17791"></a> the surviving shorter paths<a id="17251"></a> to<a id="17535"></a> reach the ending node with<a id="17375"></a> a cost less<a id="17353"></a> than N.</li>
          </ul>
          <p>Figures 17.11 and<a id="17323"></a> 17.12 show the animations for<a id="17924"></a> the same two problems and<a id="17324"></a> the resulting priority<a id="17623"></a> queue<a id="17661"></a> for<a id="17925"></a> the smaller case<a id="17106"></a>. While this algorithm<a id="17022"></a> does compute the path with<a id="17376"></a> the lowest cost, it does so at considerable extra computation cost, as is evident from<a id="17196"></a> the run time of<a id="17792"></a> the second animation, the increased Big<a id="17101"></a> O if the enqueue method and<a id="17325"></a> the enormous amount of<a id="17793"></a> extra stuff packed into the priority<a id="17624"></a> queue<a id="17662"></a> in Figure<a id="17963"></a> 17.12.</p>
          <div class="card-deck">
              <div class="col-sm-7 card">
                  <video controls class="card-image"><source src="..\Images\Optimal.mp4" type="video/mp4">Fig 17.11: Animation of<a id="17794"></a> Dijkstras<a id="17044"></a> Algorithm</video>
                  <p class="figure-name card-title">Fig 17.11: Animation of<a id="17795"></a> Dijkstras<a id="17045"></a> Algorithm</p>
              </div>
              <div class="col-sm-5 card">
                  <div class="fig-long">
                      <img src="..\Images\Opt_p_q.jpg" alt="Figure 17.12" class="fig card-image">
                  </div>
                  <p class="figure-name card-title">Fig 17.12: Priority Queue after the first search</p>
              </div>
          </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="4" data-sub-name="An Approximation Algorithm">
      <!-- An Approximation Algorithm -->
      <h3 id="17_6_4">17.6.4	An Approximation Algorithm</h3>
      <div class="container clearfix">
          <p>As we progressed from<a id="17197"></a> DFS to<a id="17536"></a> BFS<a id="17099"></a> to<a id="17537"></a> Dijkstras<a id="17046"></a> algorithm<a id="17023"></a>, the answers became more precise, but the computational cost was increasing.  Even for<a id="17926"></a> a really small proportion of<a id="17796"></a> the streets in the Atlanta metropolitan area, the solution became unpleasantly slow. Yet, the Satellite Navigation system on<a id="17410"></a> any car  can compute the route from<a id="17198"></a> somewhere in the Atlanta, Georgia area to<a id="17538"></a> the suburbs of<a id="17797"></a> Los Angeles, California in a second or less<a id="17354"></a>. To understand how this can work, we need to<a id="17539"></a> look at a fundamental change in the path computation algorithm<a id="17024"></a> and<a id="17326"></a> then, in Section 17.6.5 examine some additions to<a id="17540"></a> that algorithm<a id="17025"></a> to<a id="17541"></a> improve the efficiency and<a id="17327"></a> remove some occasional strange behavior.</p>
          <div class="float-sm-right">
              <div class="card">
                  <video controls class="card-image"><source src="..\Images\Greedy.mp4" type="video/mp4">Fig 17.13: Animation of<a id="17798"></a> a Greedy Algorithm</video>
                  <p class="figure-name card-title">Fig 17.13: Animation of<a id="17799"></a> a Greedy Algorithm</p>
              </div>
              <div class="card">
                  <img src="..\Images\greedy.jpg" alt="Figure 17.14" class="fig card-image">
                  <p class="figure-name card-title">Figure<a id="17964"></a> 17.14: Greedy Algorithm at Work</p>
              </div>
          </div>
          <p>First, we change the fundamental algorithm<a id="17026"></a> - we will give up the desire for<a id="17927"></a> an exact solution and<a id="17328"></a> settle for<a id="17928"></a> a strategy that gives us a good enough answer most of<a id="17800"></a> the time.  There are many such algorithms that are collectively referred to<a id="17542"></a> as "Greedy" algorithms. A greedy<a id="17601"></a> algorithm<a id="17027"></a> will produce a solution as long as the graph has sufficient continuity, but is not guaranteed to<a id="17543"></a> produce the best. In addition to<a id="17544"></a> the cost of<a id="17801"></a> each edge, it also requires that each node be aware of<a id="17802"></a> its geographic<a id="17159"></a> location. Figure<a id="17965"></a> 17.13 shows the usual animations using a crude greedy<a id="17602"></a> algorithm<a id="17028"></a>.  Don<a id="17411"></a>'t blink - you might miss it all.</p>
          <p>The algorithm<a id="17029"></a> is quite simple:</p>
          <ol>
              <li>Beginning at the starting node, it evaluates the result of<a id="17803"></a> traveling along each of<a id="17804"></a> the feasible edges<a id="17137"></a> to<a id="17545"></a> a child node eliminating cyclic paths<a id="17252"></a>. The evaluation takes the form of<a id="17805"></a> summing the cost of<a id="17806"></a> that edge and<a id="17329"></a> an estimate of<a id="17807"></a> the cost from<a id="17199"></a> that node to<a id="17546"></a> the destination. On a street map, for<a id="17929"></a> example<a id="17847"></a>, the estimated cost of<a id="17808"></a> each step would be the length of<a id="17809"></a> the edge and<a id="17330"></a> the straight-line distance from<a id="17200"></a> the new node to<a id="17547"></a> the destination.</li>
              <li>It selects the step with<a id="17377"></a> the least cost, adds the node reached to<a id="17548"></a> the path, and<a id="17331"></a> repeats step 1 until the destination is reached, only back-tracking when it hits a physical<a id="17167"></a> or logical<a id="17088"></a> cul-de-sac.</li>
              <li>Back-tracking is sometimes necessary if a node is reached from<a id="17201"></a> which there are no feasible paths<a id="17253"></a>, such as driving into a physical<a id="17168"></a> or logical<a id="17089"></a> cul-de-sac.</li>
              <li>Complete failure is possible, as it is for<a id="17930"></a> the other algorithms, if no physical<a id="17169"></a> path exists between the origin and<a id="17332"></a> destination nodes<a id="17240"></a>.</li>
              <li> it is also possible to<a id="17549"></a> produce a really silly answer. For example<a id="17848"></a>, consider the local street situation shown in Figure<a id="17966"></a> 17.14. This is a caricature of<a id="17810"></a> my first experiment on<a id="17412"></a> the first car I bought that had GPS. Suppose I were to<a id="17550"></a> ask for<a id="17931"></a> a route from<a id="17202"></a> my home to<a id="17551"></a> some destination to<a id="17552"></a> the South. The path would start with<a id="17378"></a> A - D, and<a id="17333"></a> it would try and<a id="17334"></a> reject B and<a id="17335"></a> C when they reached their respective cul-de-sacs. To choose between the remaining children E and<a id="17336"></a> J, it would choose E because with<a id="17379"></a> any destination to<a id="17553"></a> the South, D - E plus E to<a id="17554"></a> the destination is shorter. But what about a destination to<a id="17555"></a> the North? D - J is then better than D - E, so on<a id="17413"></a> my first test of<a id="17811"></a> my new Nav system, the stupid thing wants me to<a id="17556"></a> go around the loop D - J - K - L - F ...!</li>
          </ol>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="5" data-sub-name="Serious Path Finding Algorithms">
      <!-- Serious Path Finding Algorithms -->
      <h3 id="17_6_5">17.6.5	Serious Path Finding Algorithms</h3>
      <div class="container">
          <p>We have seen earlier that theoretical algorithms are OK for<a id="17932"></a> small problems, but for<a id="17933"></a> commercial algorithms that process large quantities of<a id="17812"></a> data<a id="17434"></a>, much care must be taken to<a id="17557"></a> ensure that the algorithm<a id="17030"></a> is fast enough and<a id="17337"></a> covers the nasty cases that make algorithms look foolish.</p>
          <ul>
              <li><b>"Layering" the problem</b>: Returning to<a id="17558"></a> the Sat Nav problem of<a id="17813"></a> finding a path from<a id="17203"></a> a house in Atlanta to<a id="17559"></a> a house in Los Angeles, if you were personally planning that route, you would not need to<a id="17560"></a> consider all the surface<a id="17610"></a> streets across the country. Rather, you would probably use a greedy<a id="17603"></a> algorithm<a id="17031"></a> to<a id="17561"></a> compute the route from<a id="17204"></a> the starting place to<a id="17562"></a> the nearest expressway on<a id="17414"></a> ramp, and<a id="17338"></a> from<a id="17205"></a> the destination to<a id="17563"></a> the nearest off ramp. The remains of<a id="17814"></a> the trip would be taken care of<a id="17815"></a> with<a id="17380"></a> a greedy<a id="17604"></a> algorithm<a id="17032"></a> on<a id="17415"></a> expressways only from<a id="17206"></a> the selected on<a id="17416"></a> ramp to<a id="17564"></a> the selected off ramp, and<a id="17339"></a> then stitch the three paths<a id="17254"></a> together.</li>
              <li><b>Informed Search</b>: A number of<a id="17816"></a> researchers have enhanced the basic greedy<a id="17605"></a> algorithm<a id="17033"></a> to<a id="17565"></a> avoid the silly solutions.  A* is one such algorithm<a id="17034"></a>. It uses heuristics to<a id="17566"></a> maintain a small number of<a id="17817"></a> competing paths<a id="17255"></a> until they either became too costly or merged to<a id="17567"></a> a point where the best can be selected. One aspect of<a id="17818"></a> the algorithm<a id="17035"></a> design is choosing how many paths<a id="17256"></a> to<a id="17568"></a> maintain. This becomes a trade-off between computational speed and<a id="17340"></a> the need to<a id="17569"></a> avoid ridiculous behavior.  A normal greedy<a id="17606"></a> algorithm<a id="17036"></a> is the fast end<a id="17153"></a> of<a id="17819"></a> that spectrum and<a id="17341"></a> algorithms like Dijkstras<a id="17047"></a> is the slow end<a id="17154"></a>.</li>
          </ul>
      </div>
    </div>
  </div>
Summary
  <div class="chp-section" data-sect-num="7" data-sect-name="Engineering Applications">
    <!-- Engineering Applications -->
    <h2 id="17_7">17.7	Engineering Applications</h2>
    <div class="container">
        <p>Many practical engineering<a id="17157"></a> problems can be characterized as graph search problems.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Simple Applications">
       <!-- Simple Applications -->
      <h3 id="17_7_1">17.7.1	Simple Applications</h3>
      <div class="container">
          <p>MSTs are used by utility companies to<a id="17570"></a> find the least amount of<a id="17820"></a> cable that must be used to<a id="17571"></a> wire a subdivision.  Approximate path finding is used, for<a id="17934"></a> example<a id="17849"></a>, in navigation systems that use GPS to<a id="17572"></a> find the current position of<a id="17821"></a> the vehicle and<a id="17342"></a> an approximate, greedy<a id="17607"></a> algorithm<a id="17037"></a> to<a id="17573"></a> determine the route to<a id="17574"></a> a destination.  Exact path finding is used to<a id="17575"></a> optimize the flight profile of<a id="17822"></a> commercial aircraft outside FAA-managed air space and<a id="17343"></a> can save as much as 10% of<a id="17823"></a> the fuel burned on<a id="17417"></a> every flight.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Complex Extensions">
      <!-- Complex Extensions -->
      <h3 id="17_7_2">17.7.2	Complex Extensions</h3>
      <div class="container">
          <p>In addition to<a id="17576"></a> the obvious examples<a id="17217"></a> above, consider these examples<a id="17218"></a>:</p>
          <ul>
              <li>designing printed circuit boards is a complex extension of<a id="17824"></a> path finding</li>
              <li>stresses in a redundant structure<a id="17883"></a> like an aircraft wing seek a path that is in some sense optimal, and<a id="17344"></a></li>
              <li>the 'traveling salesperson problem" is an unpleasant extension of<a id="17825"></a> path finding in which the objective is to<a id="17577"></a> find the shorted linear<a id="17352"></a> path that connects all of<a id="17826"></a> the nodes<a id="17241"></a> of<a id="17827"></a> a graph visiting each exactly once. For example<a id="17850"></a>, designing routes for<a id="17935"></a> garbage collection or school buses.</li>
          </ul>
          <p>Each of<a id="17828"></a> these belongs to<a id="17578"></a> a large class of<a id="17829"></a> problems called N-P Complete problems, a continued topic of<a id="17830"></a> research in many industrial engineering<a id="17158"></a> communities.</p>
      </div>
    </div>
  </div>

  <!-- Chapter Summaries -->
  <h2>Chapter Summary</h2>
  <p>This chapter demonstrated effective algorithms for<a id="17936"></a> finding good paths<a id="17257"></a> through a graph, and<a id="17345"></a> included the following:</p>
  <ul>
      <li>How to<a id="17579"></a> construct and<a id="17346"></a> use queues and<a id="17347"></a> priority<a id="17625"></a> queues as the underlying mechanism for<a id="17937"></a> graph traversal<a id="17116"></a></li>
      <li>Prim's algorithm<a id="17038"></a> for<a id="17938"></a> finding the minimum<a id="17442"></a> spanning tree of<a id="17831"></a> a graph</li>
      <li>Depth-first, Breadth-first and<a id="17348"></a> Dijkstras<a id="17048"></a> algorithms for<a id="17939"></a> finding exact paths<a id="17258"></a>
      through a graph</li>
      <li>A greedy<a id="17608"></a> algorithm<a id="17039"></a> for<a id="17940"></a> finding approximate paths<a id="17259"></a> that are "good enough."</li>
  </ul>

  <!-- Programming Project -->
  <h2>Programming Project</h2>
  <p>Suppose that we would like to<a id="17580"></a> validate the assertion that the London Underground is designed to<a id="17581"></a> have at most two train changes between any pair of<a id="17832"></a> stations.</p>
  <ul>
      <li>Download the underground map from<a id="17207"></a> http://content.tfl.gov.uk/standard-tube-map.pdf.</li>
      <li>Then, construct a graph representing the major routes in that system. You will not need all the stations identified for<a id="17941"></a> this exercise - only one station per track segment between transfer stations.</li>
      <li>Write some code that will determine the number of<a id="17833"></a> train changes to<a id="17582"></a> travel between any pair of<a id="17834"></a> stations using a breadth-first search to<a id="17583"></a> minimize the number of<a id="17835"></a> changes.</li>
      <li>Iterate across every pair of<a id="17836"></a> stations and<a id="17349"></a> find the station pair with<a id="17381"></a> the maximum number of<a id="17837"></a> train changes.</li>
      <li>Then, for<a id="17942"></a> comparison, go to<a id="17584"></a> http://metromap.fr/en for<a id="17943"></a> the equivalent map of<a id="17838"></a> the Paris metro.</li>
  </ul>
</div>

</body>
</html>

