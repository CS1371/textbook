<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"> 
<html> 
<head> 
<title>17_Graphs</title> 
<link rel="stylesheet" href="styles/styles.css" /> 
<script async src="./javascript/index.js"></script> 
</head> 
<body bgcolor="#ffffff"> 
<h1 align="center">Chapter 17: Graphs</h1> 

<table align="center"> 
<tbody> 
<tr> 
<td><a href="16_Sorting.htm">previous</a></td> 
<td><a href="Contents.htm">home</a></td> 
<td><a href="Contents.htm">next</a></td> 
</tr> 
</tbody> 
</table>
<ul>
<li><a href="#17_1">17.1   Stacks</a>
<ul>
    <li><a href="#17_1_1">17.1.1 The Nature of a Stack</a>
    <li><a href="#17_1_2">17.1.2 Implementing Stacks</a>
</ul>
<li><a href="#17_2">17.2   Queues</a>
<ul>
    <li><a href="#17_3_1">17.2.1 The Nature of a Queue</a>
    <li><a href="#17_3_2">17.2.2 Implementing Queues</a>
    <li><a href="#17_3_3">17.2.3  Priority Queues</a>
</ul>
<li><a href="#17_3">17.3 Testing Stacks and Queues</a>
<li><a href="#17_4">17.4  Graphs</a>
<ul>
    <li><a href="#17_4_1">17.4.1 Graph Examples</a>
    <li><a href="#17_4_2">17.4.2 Processing Graphs</a>
</ul>
<li><a href="#17_5">17.5   Minimum Spanning Trees</a>
<li><a href="#17_6">17.6   Finding Paths through a Graph</a>
<ul>
    <li><a href="#17_6_1">17.6.1 Depth-First Search (DFS)</a>
    <li><a href="#17_6_2">17.6.2 Breadth-First Search (BFS)</a>
    <li><a href="#17_6_3">17.6.3  Dijkstra’s Algorithm</a>
    <li><a href="#17_6_4">17.6.4 An Approximation Algorithm</a>
    <li><a href="#17_6_5">17.6.5 Serious Path Finding Algorithms</a>
</ul>
<li><a href="#17_7">17.7    Engineering Applications</a>
<ul>
    <li><a href="#17_7_1">17.7.1  Simple Applications</a>
    <li><a href="#17_7_2">17.7.2 Complex Extensions</a>
</ul>
</ul>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="800" src="Fig_17_1.jpg" width="700" /></p></center>
<figcaption><b><center>Fig 17.1: Street map of Atlanta</center></b></figcaption></figure>
<h1>Chapter Objectives</h1>

This chapter demonstrates two algorithms that solve two problems that frequently occur in engineering:<ul>
<li>finding the minimum spanning tree for a graph and 
<li>finding the best path through a graph. </ul>
However, before we can approach these algorithms, we need to understand the following: <ul>
<li>How to construct and use three special forms of data collection: stacks, queues and priority queues<li>How to build a model of a graph, and 
<li>How to traverse and search a graph.
</ul> 

<h1>Introduction</h1>
We first consider the nature of a graph by considering Figure 17.1, a simplified street map of the city of Atlanta taken with permission from the OpenStreetMap project. The data storage tools we have considered so far — vectors, arrays, structure arrays, and cell arrays — have essentially been collections whose elements are linearly related to each other by being organized in rows and columns. However, practical engineering frequently meets data that are not organized so easily. Graphs are one such data set. The ultimate goal of this chapter is to discuss this most general form of data structure. We need first to resolve the semantic problem of the name "graph." We typically think of a graph as a plot. However, in computer science, a graph is a collection of nodes connected by edges. A street map might be a useful mental model of a graph where the streets are the edges and the intersections are the nodes.  To process graphs effectively, we must first consider three simpler concepts: stacks, queues in general and priority queues in particular.  
<h2><a name="17_1">17.1  Stacks</a></h2>
 We briefly discussed the concept of stacks in Chapter 9 where a specific kind of stack, the Activation Stack, is used to manage the workspace of each function currently active in Matlab. We first consider the general nature and implementation of stacks as special collections that enable us to process graphs efficiently. We experience the concept of a stack every day of our lives. We reproduce here the illustration from Chapter 9 of the plates in the cafeteria.  
<h3><a name="17_1_1">17.1.1	The Nature of a Stack</a></h3>
 Formally, we refer to a stack as a Last In/First Out (LIFO) collection, as illustrated in Figure 17.2. The most general form of a stack is permitted to contain any kind of object, that is, an instance of any data type or class. The plates in the illustration are surrogates for literally anything that coujld be stored in a Matlab variable. A cell array, therefore, would be a good underlying structure upon which to build stack behavior. Typically, operations on a stack are restricted to the following:<ul>
<li> <b>push</b>: puts an object onto the top of the stack, 
<li><b>dequeue</b>: removes an object from the top of the stack
<li><b>peek</b>: copies the first object from the stacck without removing it, and 
<li><b>isempty</b> determines whether the stack is empty.</ul>  
<h3><a name="17_1_2">17.1.2	Implementing Stacks</a></h3>
 Although there are many ways to implement a stack, a cell array is a good choice because it is a linear collection of objects that may be of any type and can be extended or shortened without any apparent effort. If we establish a stack using a cell array, the implementation of the above behavior is almost trivial. One rather strange characteristic is the need to return the modified stack to the user. The Matlab tools are:<ul>
<li><code>stk = push(stk, item)</code> concatenates data at the end of the cell array returning the new stack to the user
<li><code>[stk, item] = pop(stk)</code>: removes the item from the end of the cell array and returns that item and the modified stack to the user
<li><code>item = peek(stk)</code>: merely returns the end item in the cell array not returning the stack because it doesn't changed
<li><code>res = isempty(stk)</code>: is the standard MATLAB test for the empty vector.
</ul>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="200" src="Fig_9_1.jpg" width="300" /></p></center>
<figcaption><b><center>Fig 17.2: a typical stack</center></b></figcaption></figure>
Clearly, because all the cell array operations are also accessible to the programmer, nothing prevents an unscrupulous programmer from using other operations on the stack — for example, adding an item elsewhere that the top of the stack. There are computer tools in Object-Oriented Programming that completely encapsulate the data and only permit the specified functions, but the author recommends that a computer language other than Matlab would be more appropriate if you must have this kind of security in your data.  
<h2><a name="17_2">17.2  Queues</a></h2>
 We first consider the nature and implementation of queue that, like a stack, provides special collections that enable us to process graphs efficiently. We experience the concept of a queue every day of our lives. A line of cars waiting for the light to turn green is a queue; when we stand in line at a store or send a print job to a printer, we experience typical queue behavior. In general, the first object entering a queue is the first one to exit the other end.  
<h3><a name="17_2_1">17.2.1	The Nature of a Queue</a></h3>
 Formally, we refer to a queue as a first in/first out (FIFO) collection, as illustrated in Figure 17.3. As with stacks, the most general form of a queue is permitted to contain any kind of object. Typically, operations on a queue are restricted to the following:<ul>
 <li><b>enqueue</b> puts an object onto the queue
 <li><b>dequeue</b> removes an object from the queue
 <li><b>peek</b> copies the first object out of the queue without removing it, and
 <li><b>isempty</b> determine whether the queue is empty.
</ul> 
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="120" src="Fig_17_3.jpg" width="400" /></p></center>
<figcaption><b><center>Fig 17.3: a typical queue - rabbits at Starbucks</center></b></figcaption></figure>
<h3><a name="17_2_2">17.2.2	Implementing Queues</a></h3>
 As with stacks, a cell array is a good choice upon which to build a queue because it is a linear collection of objects that may be of any type and can be extended or shortened without any apparent effort. If we establish a queue using a cell array, the implementation of the above behavior is trivial:</ul>
<li><code>q = enqueue(q, item)</code> concatenates data at the end of the cell array
<li><code>[q item] = dequeue(q)</code> removes the item from the front of the cell array and returns that item to the user
<li><code> item = peek(q)</code> merely accesses the first item in the cell array
<li><code> res = isempty(q)</code> is the standard MATLAB test for the empty vector
</ul>
As with stacks, in a real application, you might want to implement your queue with a tool set that protects the integrity of the data, and as with stacks, Matlab is physically incapable of providing this service.   
<h3><a name="17_2_3">17.2.3 Priority Queues</a></h3>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="120" src="Fig_17_4.jpg" width="400" /></p></center>
<figcaption><b><center>Fig 17.4: a priority queue</center></b></figcaption></figure>
 There are times when we wish ordinary queues were priority queues. For example, at the printer where you wait an hour for one page while someone prints large sections of an encyclopedia and you wonder why the print queue can’t put really small jobs ahead of really large jobs.  The only difference between an ordinary queue and a priority queue is that the objects on the queue emerge in a specified order. The rabbits in Figure 14.4 are sorted  by the expected time to prepare the drink they want. This sorting may be accomplished either as the items are enqueued as illustrated below, or by searching for the "best" item when performing a dequeue operation.  The efficiency will be the same.<br>
 
In our mechanization of a priority queue, the enqueue function involves adding the new item in order to the queue. For this to happen, there must be a means of comparing two objects. Here, we use the function <code>is_before</code> that generally should be able to compare any two objects.  In this implementation, it is sufficient to be able to compare numbers, strings or structures that contain either the <code>fields</code> key or NaN. Clearly, this function can be extended as necessary to compare any two objects.   
<h3><a name="17_3">17.3 Testing Stacks and Queues</a></h3>
 It is always advisable to test utility functions thoroughly before using them in complex algorithms. Listing 17.1 shows a script that tests a stack, a queue and a priority queue.  Following that script as helper functions are the simple functions that implement all the necessary tools.
<h3>Listing 17.1 - testing stacks, queues and priority queues</h3>
<code><strong>
<font color="#0000ff">function</font> main<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    Test a Stack</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;stack = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;rv = round(rand(<font color="#ff8000">1</font>,<font color="#ff8000">6</font>)*<font color="#ff8000">100</font> - <font color="#ff8000">25</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;stack = pushvec(stack, rv);<br>
&nbsp;&nbsp;&nbsp;&nbsp;sv = popvec(stack); <br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> length(rv) == length(sv) <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&& all(sv == rv(end:-<font color="#ff8000">1</font>:<font color="#ff8000">1</font>))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'Stack good\n'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'Stack bad!!!\n'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    Test a Queue</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;rv = round(rand(<font color="#ff8000">1</font>,<font color="#ff8000">5</font>)*<font color="#ff8000">100</font> - <font color="#ff8000">25</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;q = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;q = enqvec(q, rv);<br>
&nbsp;&nbsp;&nbsp;&nbsp;sv = deqvec(q); <br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> length(rv) == length(sv) <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&& all(sv == rv) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'Queue good\n'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'Queue bad!!!\n'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    Test a Priority Queue</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;rv = round(rand(<font color="#ff8000">1</font>,<font color="#ff8000">5</font>)*<font color="#ff8000">100</font> - <font color="#ff8000">25</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;pq = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;pq = pqenqvec(pq, rv);<br>
&nbsp;&nbsp;&nbsp;&nbsp;sv = deqvec(pq); <br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> length(rv) == length(sv) <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&& all(diff(sv) >= <font color="#ff8000">0</font>) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'Priority Queue good\n'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'Priority Queue bad!!!\n'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> ans = is_before(a, b)<br>
&nbsp;&nbsp;&nbsp;&nbsp;acl = class(a);<br>
&nbsp;&nbsp;&nbsp;&nbsp;ans = false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> isa(b, acl)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">switch</font> acl<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">case</font> {<font color="#c000c0">'double'</font> 'logical' <font color="#c000c0">'uint8'</font>}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans = a < b;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">case</font> <font color="#c000c0">'char'</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans = strcmp(a,b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">case</font> <font color="#c000c0">'struct'</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> isfield(a, <font color="#c000c0">'key'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans = a.key < b.key;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">elseif</font> isfield(a, <font color="#c000c0">'dod'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans = age(a) < age(b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(<font color="#c000c0">'comparing unknown structures'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">otherwise</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error([<font color="#c000c0">'can'</font><font color="#c000c0">'t compare '</font> acl <font color="#c000c0">'s'</font>])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
<font color="#0000ff">function</font> v = popvec(stk)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% pop a vector from a stack</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;v = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">while</font> ~isempty(stk)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[stk val] = pop(stk);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v = [v val];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> stk = pushvec(stk, V)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% push a vector onto a stack</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> v = V<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stk = push(stk, v);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> v = deqvec(q)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% dequeue a vector from a queue</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;v = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">while</font> ~isempty(q)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[q val] = deq(q);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v = [v val];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> q = enqvec(q, V)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% enqueue a vector on a queue</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> v = V<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = enq(q, v);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> q = pqenqvec(q, V)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% enqueue a vector on a priority queue</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> v = V<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = pqenq(q, v);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> s = push(s, data)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% push an item onto a stack</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;s = [s {data}];<br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> [s ans] = pop(s)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% pop an item off a stack</font><br>
ans = s{<font color="#0000ff">end</font>};<br>
s = s(<font color="#ff8000">1</font>:(end-<font color="#ff8000">1</font>));<br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> q = enq(q, data)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% enqueue onto a queue</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;q = [q {data}];<br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> [q ans] = deq(q)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% dequeue an item from a queue</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;ans = q{<font color="#ff8000">1</font>};<br>
&nbsp;&nbsp;&nbsp;&nbsp;q = q(<font color="#ff8000">2</font>:end);<br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> pq = pqenq(pq, item)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% enqueue in order to a priority queue</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;in = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;at = length(pq)+<font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">while</font> in <= length(pq)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> is_before(item, pq{in})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at = in;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">break</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in = in + <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;pq = [pq(<font color="#ff8000">1</font>:at-<font color="#ff8000">1</font>) {item} pq(at:end)];<br>
<font color="#0000ff">end</font><br>
<br>
</strong></code>
  
<h2><a name="17_4">17.4 Graphs</a></h2>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_17_5.jpg" width="400" /></p></center>
<figcaption><b><center>Fig 17.5: a simple graph</center></b></figcaption></figure>
 This chapter focuses on processing a graph — the most general form of dynamic data structure, an arbitrary collection of nodes connected by edges. The edges may be directional to indicate that the graph can be traversed along that edge in only one direction (like a one-way street). The edges may also have a value associated with them to indicate, for example, the cost of traversing that edge. We refer to this as a weighted graph. For a street map, this cost could either be the distance, or in a more sophisticated system, the travel time—a function of the distance, the speed limit, and the traffic congestion. Graphs are not required to be completely connected, and they may contain cycles - closed loops in which the unwary algorithm could become trapped. Graphs also have no obvious starting and stopping points. Finally, a path on a graph is a connected list of edges that is the result of traversing a graph.  
<h3><a name="17_4_1">17.4.1 Graph Examples</a></h3>
 A simple graph is shown in Figure 17.5. In the figure, the connection points 0 ... 10 are the nodes and the edges are the interconnecting lines, which in this example are not directional but are weighted. Graphs occur frequently in everyday life, as illustrated by the street map shown in Figure 17.1. Street maps can be conveniently represented as graphs where intersections are the nodes and streets are the edges. Streets can be directional (one-way), and they may have weights associated with them - either the transit time (a function of the length of the street and its speed limit) or, with access to real-time traffic information, a more complex estimate of the transit time.  
<h3><a name="17_4_2">17.4.2	Processing Graphs</a></h3>
 In designing algorithms that operate on graphs in general, we need to consider the following constraints: <ul>
 <li>With cycles permitted in the data, there is no natural starting point like the beginning of a cell array. Consequently, the user must always specify a place on the graph to start as well as the place to stop.
 <li>There are no natural “leaf nodes” where a search might have to stop and back up. Consequently, an algorithm processing a graph must have a means of determining that being at a given node is the “end of the line.” Typically, this is accomplished by maintaining a collection of visited nodes as it progresses around the graph. Each time a node is considered, the algorithm must check to see whether that node is already in the visited collection. If so, it refuses to return to that node. The algorithm must backtrack if it reaches a node from which there is no edge to a node that has not already been visited.
 <li>Whereas on a cell array there is only one feasible path from one node to another, there may be many possible paths between two nodes on a graph. The best algorithms that search for paths must take into account a comparison between paths to determine the best one.  For a simple, consistent example, consider the graph shown in Figure 17.5. We will use this simple example to demonstrate minimum spanning trees (MSTs) and finding paths through the graph.
</ul> 
<h2><a name="17_5">17.5 Minimum Spanning Trees</a></h2>
A Spanning Tree (MST) is a set of edges identified for a graph that touches all of the nodes of the graph. For example, on a circuit board, power must be distributed to all of the chips on the board. The routing of a power trace to all the power pins would be a spanning tree. More often that not, it is important to have a spanning tree whose length is as short as possible. Finding the shortest spanning tree is referred to as the Minimum Spanning Tree (MST) problem. There may well be multiple spanning trees with the same overall cost and any one of those would satisfy the requirement. There are two practical algorithms commonly used to solve the MST problem: 
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><video width="560" height="350" controls>
<source src="MST.mp4" type="video/mp4">
Your browser does not support the video tag.
</video></p></center>
<figcaption><b><center>Fig 17.6: Animation of Prim's MST Algorithm</center></b></figcaption></figure>

<ul>
<li> Kruscal’s algorithm and
<li> Prim's algorithm
</ul>
Since they are both very similar in concept and produce the correct answer, we will only consider one: Prim's algorithm.
<br>
Prim’s algorithm finds the subset of the edges of the graph that connect every node exactly once whose total cost is not greater than that of any other spanning tree. The algorithm continuously increases the size of a tree, one edge at a time, starting with a tree consisting of a single node, until it spans all the nodes. Specifically, given a graph as defined in Figure 17.5, Prim’s algorithm proceeds
as shown in Listing 17.2.<br>
<h3>Listing 17.2: pseudo-code for Prim's Algorithm</h3>
<code><ol>
<li>Given the set of nodes N
<li>Initialize the result V as a collection containing x where x is an arbitrary node removed from N
<li>Repeat the following steps until N is empty <ul>
<li>Choose an edge [u, v] with minimal weight such that u is in N
and v is not. If there are multiple edges with the same weight, any of them may be chosen
<li>Remove v from N and add [u, v] to V.
</ul>
<li>Report the contents of V as the resulting MST.
</ol>
</code><br>
Figure 17.6 is a pair of animations of Prim's algorithm applied to a small graph and then a larger, but still manageable graph.


<h2><a name="17_6">17.6 Finding Paths through a Graph</a></h2>
 This section discusses four algorithms for finding a path from one node on the graph to another. The first three algorithms exhaustively search the graph to find the absolute best path between node pairs by different criteria. These differences of behavior are created by selecting a stack, a queue or a priority queue as the dynamic container for interim solutions.  The fourth is one of many approximation algorithms typically used to compute a good enough route in circumstances where an exact solution is not feasible. 
Listing 17.3 shows a template for the three exact algorithms. 
<h3>Listing 17.3: generic pseudo-code for path finding</h3>
<code><ol>
<li>Given the set of nodes N and edges E
<li>Given a starting node Ns and an ending node Ne 
<li>Initialize the result as an empty <code>&lt;collection&gt;</code>, V
<li><code>&lt;add&gt;</code> x to V where x is an arbitrary node removed from N
<li>Repeat the following steps while V is not empty <ul>
<li>&lt;remove(...)&gt; a path, P, from V
<li>check if it reaches Ne; if so, exit with P
<li>calculate the children reachable from the end of the path
<li>for each child [u, v] in children, append it to the path P and &lt;add(...)&gt; the new path P1 to V
<li>%%%% NOTE: don't use the following test with the priority queue
<li>check if v is Ne, the ending node; exit if so 
</ul>
<li>Report the contents of P as the resulting path from Ns to Ne.
</ol>
</code>

In this listing, we will use a generic <code>&lt;collection&gt;</code> to substitute for the specific collections used in the detailed algorithms to follow. We will also use the generic operations <code>&lt;add(...)&gt;</code> and <code>&lt;remove(...)&gt;</code> as surrogates for the actual operations on the chosen <code>&lt;collection&gt;</code>. Our objective will be to return a <code>&lt;path&gt;</code> consisting of a sequence of 1 or more nodes.  We will also need the concept of <code>&lt;children&gt;</code> which is a collection of edges [u,v] where u is the end of the path and v is not on the current path to prevent cycles in the path. When choosing which child node to process first, we need a consistent rule. Since our nodes are all numbered, it makes sense to process the child nodes in increasing numerical order. This will be the rule for all the specific examples to follow.<br><br>
For the following three algorithms, we will see two artifacts: <ul>
<li> animations on two graphs showing how the algorithm works.  The algorithms on first, small graph will always start at node 1 and stop at node 7. On the larger graph, they start at node 121 and stop at node 1. Comparing these animations will illustrate the relative computational cost of each algorithm. However, as we will see in section 17.6.4, none of these algorithms are fast enough to handle a graph of any serious size.
<li> the contents of the collection at the end of each of the algorithms in the simple case.  
</ul>
A serious student will want to trace through the template in Listing 17.3 referring to the animations in order to construct the contents of each collection.

<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><video width="560" height="350" controls>
<source src="DFS.mp4" type="video/mp4">
Your browser does not support the video tag.
</video></p></center>
<figcaption><b><center>Fig 17.7: Animation of the DFS Algorithm</center></b></figcaption></figure>
<h3><a name="17_6_1">17.6.1	Depth-First Search (DFS)</a></h3>
The depth-first path search algorithm uses a stack for the <code>&lt;collection&gt;</code> and <code>&lt;push(...)&gt;</code> and <code>&lt;pop(...)&gt;</code> as the functions to add and remove a path from the stack. As we observe the behavior of the DFS algorithm, it is clearly the fastest of the three algorithms, but makes no claim at all about the efficiency of the resulting path. As long as there is any connectivity between the starting and ending nodes, this will find a path. <br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="170" src="DFS.jpg" width="140" /></p></center>
<figcaption><b><center>Fig 17.8: Stack after the first DFS search </center></b></figcaption></figure>
As you study the small graph, you would be right to "ask why bother with the stack at all?" since at every cycle through the template, the algorithm always takes the last element pushed onto the stack. As you will see on a careful study of the DFS algorithm on the larger graph, the stack is there to resolve the problem of cul-de-sacs. As in real streets that have no outlet, a cul-de-sac can be a physical constraint. However, there can also be logical cul-de-sacs where a street closes a loop and has no other outlet. The rule to eliminate cycles will also see this geometry as a virtual cul-de-sac.  In either case, the paths on the stack can be popped off until the algorithm reaches a node with an alternative path to proceed. The logic of template in Listing 17.3 will exit from the while loop if there are no more feasible paths on the stack.
<br><br><br><br><br><br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><video width="560" height="350" controls>
<source src="BFS.mp4" type="video/mp4">
Your browser does not support the video tag.
</video></p></center>
<figcaption><b><center>Fig 17.9: Animation of the BFS Algorithm</center></b></figcaption></figure>

<h3><a name="17_6_2">17.6.2	Breadth-First Search (BFS)</a></h3>
 Frequently, we actually need the path with the smallest number of nodes between the starting and ending nodes. For example, because changing trains involves walking and waiting, the best path on an urban transit system map is that with the fewest changes, even if the resulting path is longer. To search for the path with the least nodes, we need an algorithm that performs a Breadth-First Search (BFS) on a graph. We will use the template in Listing 17.3 where the <code>&lt;collection&gt;</code> is a <code>&lt;queue&gt;</code>, the <code>&lt;add&gt;</code> method is <code>&lt;enqueue(...)&gt;</code> and the &lt;remove(...)&gt; method is <code>&lt;dequeue(...)&gt;</code>. 
 <figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="170" src="BFS.jpg" width="140" /></p></center>
<figcaption><b><center>Fig 17.10: Queue after the first BFS search </center></b></figcaption></figure>
As you observe the animations in Figure 17.9, especially the larger graph, you will see a characteristic rotating search mimicking the ripples on a pond when a pebble is dropped in. This behavior is caused by using the <code>&lt;queue(...)&gt;</code> and will result in the path with the least number of nodes although it may not be the shortest one.  In fact, on the small graph animation, while there is a path with lower cost that uses one more node, the BFS algorithm can't find it. Figure 17.9 shows animations of the same two problems using the BFS algorithm - a better approach in that it computes the path with the least number of nodes, but does not guarantee the best cost.  In fact, neither DFS nor BFS take cost into account, but merely use it as an observer.  Figure 17.10 shows to state of the queue at the end of the first animation.
 <br><br>
<h3><a name="17_6_3">17.6.3	Dijkstra’s Algorithm</a></h3>
 Although the minimal number of nodes is sometimes the right answer, frequently there is a path that uses more nodes but has a smaller overall cost. This is evident from a quick glance at Figure 17.5: the path 1-0-5-6-7 has a lower cost than the path 1-0-4-7 found by the BFS algorithm, which actually ignores the edge weights. Many algorithms exist for finding the optimal path through a graph. Here we illustrate the algorithm attributed to the Dutch computer scientist Dr. Edsger Dijkstra. Perhaps it is not the most efficient algorithm; but for our purposes, this approach has the virtue of being a minor extension to the while loop algorithm described in Listing 17.3.  The major differences arise from the use of a priority queue in place of the normal queue used in the BFS algorithm. <ul>
 <li> As previously noted, priority queues differ from basic queues only to the extent that the <code>&lt;enqueue(...)&gt;</code> method puts the data in order, rather than at the tail of the queue. The ordering criterion required by the algorithm is to place the paths in increasing order of path cost. While we have not explicitly dealt with the Big O of these algorithms, it is clear in the micro sense that inserting at the end of a queue is O(1) while inserting in order in a priority queue is O(N) where N is the worst case of queue length. 
 <li>The objects contained in the priority queue need to contain not only the path, but also the total path weight. 
<li> we have to change the exit strategy in the template shown in Listing 17.2.  For DFS and BFS, once a path has been added to their collections, there is no possibility of a "better" path being inserted ahead of that result. Hence, it is fine to perform the exit test when inserting each child node.  However, this is not the case for the Dijkstra algorithm; better paths can be inserted before any of the paths entered. In a formal sense, it is safe to perform the exit test when a path is dequeued. However, when preparing the somewhat intimidating view of the priority view when the algorithm completed, we shortened that queue by realizing that the algorithm may be stopped when a path of cost N to the end is enqueued if it is logically impossible for the next step on any of the surviving shorter paths to reach the ending node with a cost less than N.
</ul> 
Figures 17.11 and 17.12 show the animations for the same two problems and the resulting priority queue for the smaller case. While this algorithm does compute the path with the lowest cost, it does so at considerable extra computation cost, as is evident from the run time of the second animation, the increased Big O if the enqueue method and the enormous amount of extra stuff packed into the priority queue in Figure 17.12.
<h3><a name="17_6_4">17.6.4	An Approximation Algorithm</a></h3>
 When a graph is very large, the computation complexity of the exact solutions (roughly O(N2)) becomes unmanageable. The A* algorithm is one of many popular approximation techniques that will produce a solution, but is not guaranteed to produce the best, and its computational complexity is roughly O(N). This algorithm is quite simple:  1.	Beginning at the starting node, it evaluates the result of traveling along each of the feasible edges to an adjacent node (eliminating cyclic paths). The evaluation takes the form of summing the cost of that edge and an estimate of the cost from that node to the destination. On a street map, for example, the estimated cost of each step would be the length of the edge and the straight-line distance from the new node to the destination. 2.	It selects the step with the least cost, adds the node reached to the path, and repeats step 1 until the destination is reached. 3.	Back-tracking is sometimes necessary if a node is reached from which there are no feasible paths, such as driving into a dead end street. 4.	Complete failure is also possible, as it is for the other algorithms, if no physical path exists between the origin and destination nodes.  Listing 17.14 shows the code that implements a greedy algorithm. Notice that some additional information is necessary to effectively compute the estimated cost from a node to the destination. In our example, we can use the location of each node, but in general, that location may not be readily available.  In Listing 17.14:  Lines 2 and 3: We will maintain two lists—the current path and the visited list indicating all the nodes that have been visited. This provides for the case when back-tracking is necessary to avoid revisiting the dead end. Lines 4–29: Continue until the target node is reached.  Lines 5 and 6: Find the nodes that can be reached from the current node. Lines 7 and 8: Initialize the storage for the best next step. Lines 9–19: Iterate across all possibilities. Line 10: Only considers nodes not on the visited list. Lines 11–13: The cost of this step is the sum of the actual cost of one step and the estimate of the remaining cost given in this case by the distance between the nodes (invoking the helper function at lines 35–39). Lines 14–17: Check for improvement in the best cost. Lines 20 and 21: Check for a dead end. Lines 22 and 23: Check for total failure—we have backed up beyond the starting node. Lines 26 and 27: Add a successful node to the current path (from which it might later be remove by backing up) and the visited nodes from which it is never removed. Lines 30–33: Prepare the results as a sparse matrix for plotting. Lines 35–39: Helper function calculating the distance between the specified points. The A* path from A to H is shown in Figure 17.9. Note that in this simple case, it found the same path as the BFS, but that is not necessarily the case in a more complex test.  
<h3><a name="17_6_5">17.6.5	Serious Path Finding Algorithms</a></h3>
We have seen earlier that theoretical algorithms are OK for small problems, but for commercial algorithms that process large quantities of data, much care must be taken to ensure that the algorithm covers the nasty cases that make algorithms look foolish.
<h2><a name="17_7">17.7	Engineering Applications</a></h2>
 Many practical engineering problems can be characterized as graph search problems.  
<h3><a name="17_7_1">17.7.1	Simple Applications</a></h3>
MSTs are used by utility companies to find the least amount of cable that must be used to wire a subdivision.  Approximate path finding is used, for example, in navigation systems that use GPS to find the current position of the vehicle and an approximate, greedy algorithm to determine the route to a destination.  Exact path finding is used to optimize the flight profile of commercial aircraft outside FAA-managed air space and can save as much as 10% of the fuel burned on every flight.  
<h3><a name="17_7_2">17.7.2	Complex Extensions</a></h3>
In addition to the obvious examples above, consider these examples:

■	designing printed circuit boards is a complex extension of path finding
■	stresses in a redundant structure like an aircraft wing seek a path that is in some sense optimal, and
■	the “traveling salesperson problem” is an unpleasant extension of path finding in which the objective is to find the shorted linear path that connects all of the nodes of a graph visiting each exactly once. For example, designing routes for garbage collection or school buses.

Each of these belongs to a large class of problems called N-P Complete problems, a continued topic of research in many communities.




Chapter Summary

This chapter demonstrated effective algorithms for finding good paths through a graph, and included the following:
■	How to construct and use queues and priority queues as the underlying mechanism for graph traversal
■	The basic use of an adjacency matrix for defining a graph
■	Prim’s algorithm for finding the minimum spanning tree of a graph
■	Breadth-first and Dijkstra’s algorithms for finding exact paths
through a graph
■	A greedy algorithm for finding approximate paths that are “good
enough”


Programming Project

We would like to validate the assertion that the London Underground is designed to have at most two train changes between any pair of stations. Download the underground map from http://content.tfl.gov.uk/standard-tube-map.pdf. Then, using the methodology of Section 17.2.3, construct a graph representing the major routes in that system. You will not need all the stations identified for this exercise—only one station per track segment between transfer stations.
a.	Write a function that will determine the number of train changes to travel between any pair of stations using a breadth-first search to minimize the number of changes.
b.	Iterate across every pair of stations and find the station pair with the maximum number of train changes.
Then, for comparison, go to http://metromap.fr/en for the equivalent map of thre Paris metro.  


<table align="center"> 
<tbody> 
<tr> 
<td><a href="16_Sorting.htm">previous</a></td> 
<td><a href="Contents.htm">home</a></td> 
<td><a href="Contents.htm">next</a></td> 
</tr> 
</tbody> 
</table> 

<p align="center"><font size="1">This Web Page was Built with PageBreeze </font><a href="http://pagebreeze.com" target="_blank"><font size="1">Free HTML Editor</font></a><font size="1"> </font></p> 
</body> 
</html> 
-1.000000e+00 
