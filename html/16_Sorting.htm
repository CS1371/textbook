<!DOCTYPE HTML>
<html>
<head>
<title>16_Sorting</title>
<!-- include bootstrap -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
<!-- include stylesheets -->
<link rel="stylesheet" href="styles/styles.css" />
<script async src="./javascript/index.js"></script>
</head>
<body>
<div>#top_nav#</div>
<div class="nav-obj">#nav_obj#</div>

<div class="content">
  <h1 id="16" align="center">Chapter 16: Sorting</h1>

  <!-- Chapter Objectives -->
  <h1>Chapter Objectives</h1>
  <p>This chapter discusses:</p>
  <ul>
      <li>A technique for comparing the performance of algorithms</li>
      <li>A range of algorithms for sorting<a id="5252"></a> a collection of data</li>
      <li>Application areas in which these algorithms are most appropriate</li>
  </ul>

  <!--[whole chapter needs massive rewrite]-->

  <h1>Introduction</h1>
  <div class="container">
      <p>First, we will digress from the main thread of problem solving to discuss an "engineering<a id="5142"></a> algebra" for measuring the cost of an algorithm<a id="5021"></a> in terms of the amount of work done. Then we will consider a number of sorting<a id="5253"></a> algorithms, using this technique to assess their relative merits.</p>
  </div>

  <div class="chp-section" data-sect-num="1" data-sect-name="Measuring Algorithm Cost">
     <!-- Measuring Algorithm Cost -->
    <h2 id="16_1">16.1 Measuring Algorithm Cost</h2>
    <div class="container clearfix">
        <p>How many times do you ask yourself, “Just how good is my algorithm<a id="5022"></a>?” Probably not very often, if ever. After all, we have been creating relatively simple programs that work on a small, finite set of data. Our functions execute and return an answer within a second or two (except for the recursive Fibonacci<a id="5152"></a> function<a id="5156"></a> on numbers<a id="5203"></a> over 25). You may have noticed that some of the image processing scripts<a id="5242"></a> take a number of seconds to run. However, as the problems become more complex and the volume of data increases, we need to consider whether we are solving the problem in the most efficient manner. In extreme cases, processes that manipulate huge amounts of data like the inventory of a large warehouse or a national telephone directory might be possible only with highly efficient algorithms.</p>
        <p><b>Big<a id="5089"></a> O</b> is an algebra that permits us to express how the amount of work done in solving a problem relates to the amount of data being processed. It is a gross simplification  for  software  engineering<a id="5143"></a> analysis purposes, based on some sound<a id="5280"></a> but increasingly complex theory.</p>
        <p>Big<a id="5090"></a> O is a means of estimating the worst case<a id="5122"></a> performance of a given algorithm<a id="5023"></a> when presented with a certain number of data items, usually referred to as N. In fact, the actual process attempts to determine the limit of the relationship between the work done by an algorithm<a id="5024"></a> and N as N approaches infinity.<p>
        <div class="float-sm-right technical-insights card">
            <p class="card-title">Technical Insight 16.1</p>
            <p class="card-text">Interested readers should look up little-O, Big<a id="5091"></a>-&<a id="5226"></a>Omega;, little-&omega;, and Big<a id="5092"></a>-&<a id="5227"></a>Theta;.</p>
        </div>
        <p>We report the Big<a id="5093"></a> O of an algorithm<a id="5025"></a> as O (&lt;expression in terms of N&gt;). For example, O(1) describes the situation where the computing cost is independent of the size of the data, O(N) describes the situation where the computing cost is directly proportional to the size of the data, and O(2N) describes the situation where the computing cost doubles each time one more piece of data is added. At this point, we should also observe some simplifying assumptions:</p>
        <ul>
        <li>We are not concerned with constant multipliers on the Big<a id="5094"></a> O of an algorithm<a id="5026"></a>. As rapidly as processor performance and languages are improving, multiplicative improvements can be achieved merely by acquiring the latest hardware or software. Big<a id="5095"></a> O is a concept that reports qualitative algorithm<a id="5027"></a> improvement. Therefore, we choose to ignore constant multipliers on Big<a id="5096"></a> O analyses.</li>
        <li>We are concerned with the performance of algorithms as N approaches infinity. Consequently, when the Big<a id="5097"></a> O is expressed as the sum of multiple terms, we keep only the term with the fastest growth rate.</li>
        </ul>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Specific Big O Examples">
      <!-- Specific Big-O Examples -->
      <h3 id="16_1_1">16.1.1	Specific Big<a id="5098"></a> O Examples</h3>
      <div class="container clearfix">
          <p>On the basis of algorithms we have already discussed, we will look at examples of the most common Big<a id="5099"></a> O cases.</p>
          <p><b>O(1)—Independent of N</b> O(1) describes the ideal case<a id="5123"></a> of an algorithm<a id="5028"></a> or logical<a id="5191"></a> step whose amount of work is independent of the amount of data. The most obvious example is accessing or modifying an entry in a vector. Since all good languages permit direct access to elements of a vector, the work of these simple operations<a id="5222"></a> is independent of the size of the vector.</p>
          <p><b>O(N)—Linear</b> with N O(N) describes an algorithm<a id="5029"></a> whose performance is linearly related to N. Copying a cell array<a id="5071"></a> of size N is an obvious example, as is searching<a id="5243"></a> for a specific piece of data in such a cell array<a id="5072"></a>. One might argue that occasionally one would find the data as the first element. There is an equal<a id="5146"></a> chance that we would be unlucky and find the item as the last element. On average, we would claim that the performance of this search is the mean of these numbers<a id="5204"></a>: (N+1) / 2. However, applying the simplification rules above, we first reject the 1 as being N to a lower power, leaving N/2, and then reject the constant multiplier, leaving O(N) for a linear<a id="5187"></a> search.</p>
          <div class="float-sm-right card">
               <img src="..\Images\Fig_16_1.JPG" alt="Figure 16.1" class="fig card-img">
               <p class="figure-name card-title">Figure 16.1: Binary Search<a id="5113"></a></p>
           </div>
          <p><b>O(logN)—Binary Search<a id="5114"></a></b> Consider searching<a id="5244"></a> for a number - say, 86 - in a sorted vector such as that shown in Figure 16.1. One could use a linear<a id="5188"></a> search without taking advantage of the ordering of the data. However, a better algorithm<a id="5030"></a> might be as follows:</p>
          <ol>
           <li>Go to the middle of the vector (approximately) and compare that element (59) to the number being sought.</li>
           <li>If this is the desired value<a id="5287"></a>, exit with the answer.</li>
           <li>If the number sought is less<a id="5184"></a> than that element, since the data are ordered, we can reject the half of the array<a id="5073"></a> to the right of, and including the 59.</li>
           <li>Similarly, if the number sought is greater than that element, we can reject the half of the array<a id="5074"></a> to the left of and including the 59.</li>
           <li>Repeat these steps with the remaining half vector until either the number is found or the size of the remaining half is zero.</li>
          </ol>
          <p>Now consider how much data can be covered by each test—a measure of the work done as shown in Table 16.1.</p>
          <table class="table table-sm binary-table">
              <caption>Table 16.1: Work Done in a Binary Search<a id="5115"></a></caption>
              <tr>
                  <th>Work</th>
                  <th>N</th>
              </tr>
              <tr>
                  <td>1</td>
                  <td>2</td>
              </tr>
              <tr>
                  <td>2</td>
                  <td>4</td>
              </tr>
              <tr>
                  <td>3</td>
                  <td>8</td>
              </tr>
              <tr>
                  <td>4</td>
                  <td>16</td>
              </tr>
              <tr>
                  <td>5</td>
                  <td>32</td>
              </tr>
              <tr>
                  <td>.</td>
                  <td>.</td>
              </tr>
              <tr>
                  <td>.</td>
                  <td>.</td>
              </tr>
              <tr>
                  <td>W</td>
                  <td>2<sup>W</sup></td>
              </tr>
          </table>
          <p>In general, we can state that the relationship is expressed as follows:</p>
          <p><code>N = 2<sup>W</sup></code></p>
          <p>However, we need the expression for the work, W, as a function<a id="5157"></a> of N. Therefore, we take the log base 2 of each side so that:</p>
          <p><code>W = log<sub>2</sub>N</code></p>
          <p>Now, we realize that we can convert log<sub>2</sub>N to log<sub>x</sub>N merely by multiplying by log<sub>2</sub>x, a constant that we are allowed to ignore. Consequently, we lose interest in representing the specific base of the logarithm, leaving the work for a binary<a id="5109"></a> search as O(log N).</p>
          <p><b>O(N<sup>2</sup>)—Proportional to N<sup>2</sup></b> O(N<sup>2</sup>) describes an algorithm<a id="5031"></a> whose performance is proportional to the square<a id="5281"></a> of N. It is a special case<a id="5124"></a> of O(N x M), which describes any operation<a id="5221"></a> on an N x M array<a id="5075"></a> or image.</p>
          <p><b>O(2<sup>N</sup>)—Exponential Growth or Worse</b> Occasionally we run across very nasty implementations of simple algorithms. For example, consider the recursive implementation of the Fibonacci<a id="5153"></a> algorithm<a id="5032"></a> we discussed in Section 9.6.2. In this implementation, fib(<a id="5149"></a>N) = fib(<a id="5150"></a>N - 1) 1 fib(<a id="5151"></a>N -2). So each time we add another term, the previous two terms have to be calculated again, thereby doubling the amount of work. If we double the work when 1 is added to N, in general the Big<a id="5100"></a> O is O(2<sup>N</sup>). Of course, in the case<a id="5125"></a> of this particular algorithm<a id="5033"></a>, there is a simple iterative solution with a much preferable performance of O(N).</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Analysis Complex Algorithms">
      <!-- Analyzing Complex Algorithms -->
      <h3 id="16_1_2">16.1.2	Analyzing Complex Algorithms</h3>
      <div class="container">
          <p>We can easily calculate the Big<a id="5101"></a> O of simple algorithms. For more complex algorithms, we determine the Big<a id="5102"></a> O by breaking the complex algorithm<a id="5034"></a> into simpler abstractions, as we saw in Chapter 10. We would continue<a id="5135"></a> that process until the abstractions can be characterized as simple operations<a id="5223"></a> on defined collections<a id="5131"></a> for which we can determine their Big<a id="5103"></a> Os. The Big<a id="5104"></a> O of the overall algorithm<a id="5035"></a> is then determined from the individual components by combining them according to the following rules:</p>
          <ul>
           <li>If two components are sequential (do A and then do B), you add their Big<a id="5105"></a> O expressions</li>
           <li>If components are nested (for each A, do B), you multiply their Big<a id="5106"></a> O expressions</li>
          </ul>
          <p>For example, we will see the merge sort<a id="5194"></a> algorithm<a id="5036"></a> in Section 16.2.5. It can be abstracted as follows:</p>
          <p>Perform a binary<a id="5110"></a> division of the data (O(logN)) and <i>then for each</i> binary<a id="5111"></a> step (of which there are O(log(N)), merge all the data items (O(N)).</p>
          <p> This has the general form:</p>
          <p>Do A, then for each B, do C</p>
          <p>which, according to the rules above, should result in O<sub>A</sub> + O<sub>B</sub> * O<sub>C</sub>. The overall algorithm<a id="5037"></a> therefore costs O(log N) + O(N) * O(log N). We remove the first term because its growth is slower, leaving O(N log N) as the overall algorithm<a id="5038"></a> cost.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="2" data-sect-name="Algorithms for Sorting Data">
     <!-- Algorithms for Sorting Data -->
    <h2 id="16_2">16.2 Algorithms for Sorting Data</h2>
    <div class="container">
        <p>Generally, sorting<a id="5254"></a> a collection of data will organize the data items in such a way that it is possible to search for a specific item using a binary<a id="5112"></a> search rather than a linear<a id="5189"></a> search. This concept is nice in principle when dealing with simple collections<a id="5132"></a> like an array<a id="5076"></a> of numbers<a id="5205"></a>. However, it is more difficult in practice with real data. For example, telephone books are always sorted by the person’s last name. This facilitates searching<a id="5245"></a> by last name, but it does not help<a id="5175"></a> if you are looking for the number of a neighbor whose name you do not know. That search would require sorting<a id="5255"></a> the data by street name.</p>
        <p>There are many methods for sorting<a id="5256"></a> data. We present five representative samples selected from many sorting<a id="5257"></a> algorithms because each has a practical, engineering<a id="5144"></a> application. First we describe each algorithm<a id="5039"></a>, and then we compare their performance and suggest engineering<a id="5145"></a> circumstances in which you would apply each algorithm<a id="5040"></a>. Note that in all these algorithms, the comparisons are done using functions (e.g., <code>gt(<a id="5172"></a>...)</code>, <code>lt(...)</code>, or <code>equals(...)</code>) rather than mathematical operators<a id="5225"></a>. This permits collections<a id="5133"></a> containing arbitrarily complex objects<a id="5214"></a> to be sorted merely by customizing the comparison functions.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Insertion Sort">
      <!-- Insertion Sort -->
      <h3 id="16_2_1">16.2.1 Insertion Sort</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
               <img src="..\Images\Fig_16_2.JPG" alt="Figure 16.2" class="fig card-img">
               <p class="figure-name card-title">Figure 16.2: Insertion Sort in Progress</p>
           </div>
          <p>Insertion sort is perhaps the most obvious sorting<a id="5258"></a> technique. Given the original collection of objects<a id="5215"></a> to sort, it begins by initializing an empty<a id="5136"></a> collection. For example, if the collection were a vector, you might allocate a new vector of the same size and initialize an “output index” to the start of that vector. Then the algorithm<a id="5041"></a> traverses the original vector, inserting<a id="5177"></a> each object from that vector in order into the new vector. This usually requires "shuffling" the objects<a id="5216"></a> in the new vector to make room for the new object.</p>
          <p>Figure 16.2 illustrates the situation where the first four numbers<a id="5206"></a> of the original vector have been inserted into the new vector; the algorithm<a id="5042"></a> finds the place to insert the next number (10) and then moves the 12 across to make space for it.</p>
          <p>Listing 16.1 shows the MATLAB<a id="5192"></a> code for insertion sort<a id="5178"></a> on a vector of numbers<a id="5207"></a>. The algorithm<a id="5043"></a> works for any data collection for which the function<a id="5158"></a> <code>lt(A,B)</code> compares two instances.</p>
          <p>Later we will refer to the selection sort algorithm<a id="5044"></a> that is similar in concept to insertion sort<a id="5179"></a>. Rather than sorting<a id="5259"></a> as the new data are put into the new vector, however, the selection sort algorithm<a id="5045"></a> repeatedly finds and deletes the smallest item in the original vector and puts it directly into the new vector.</p>
          <p>Both insertion sort<a id="5180"></a> and selection sort are O(N<sup>2</sup>) if used to sort a whole vector.</p>
      </div>
      <div class="listing">#listing_16_1#</div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Bubble Sort">
      <!-- Bubble Sort -->
      <h3 id="16_2_2">16.2.2 Bubble Sort</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
               <img src="..\Images\Fig_16_3.JPG" alt="Figure 16.3" class="fig card-img">
               <p class="figure-name card-title">Figure 16.3: Bubble Sort</p>
           </div>
          <p>Where insertion sort<a id="5181"></a> is easy to visualize, it is normally implemented by creating a new collection and growing that new collection as the algorithm<a id="5046"></a> proceeds. Bubble sort is conceptually the easiest sorting<a id="5260"></a> technique to visualize and is usually accomplished by rearranging the items in a collection in place. Given the original collection of N objects<a id="5217"></a> to sort, it makes (N - 1) major passes through the data. The first major pass examines all N objects<a id="5218"></a> in a minor pass, and subsequent passes reduce the number of examinations by 1. On each minor pass through the data, beginning with the first data item and moving incrementally through the data, the algorithm<a id="5047"></a> checks to see whether the next item is smaller than the current one. If so, the two items are swapped in place in the array<a id="5077"></a>.</p>
          <p>At the end<a id="5138"></a> of the first major pass, the largest item in the collection has been moved to the end<a id="5139"></a> of the collection. After each subsequent major pass, the largest remaining item is found at the end<a id="5140"></a> of the remaining items. The process repeats until on the last major pass, the first two items are compared and swapped if necessary. Figure 16.3 illustrates a bubble sort<a id="5116"></a> of a short vector. On the first pass, the value<a id="5288"></a> 98 is moved completely across the vector to the rightmost position. On the next pass, the 45 is moved into position. On the third pass, the 23 reaches the right position, and the last pass finishes the sort.</p>
          <p>Listing 16.2 shows the MATLAB<a id="5193"></a> code for bubble sort<a id="5117"></a> on a vector of numbers<a id="5208"></a>. The algorithm<a id="5048"></a> works for any data type for which the function<a id="5159"></a> <code>gt(<a id="5173"></a>A,B)</code> compares two instances. Since bubble sort<a id="5118"></a> performs (N - 1) * (N - 1)/2 comparisons on the data, it is also O(N<sup>2</sup>). Some implementations use a flag to determine whether any swaps occurred on the last major pass and terminate the algorithm<a id="5049"></a> if none occurred. However, the efficiency gained by stopping the algorithm<a id="5050"></a> early has to be weighed against the cost of setting and testing a flag whenever a swap is accomplished.</p>
      </div>
      <div class="listing">#listing_16_2#</div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Quick Sort">
       <!-- Quick Sort -->
      <h3 id="16_2_3">16.2.3	Quick Sort</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
               <img src="..\Images\Fig_16_4.JPG" alt="Figure 16.4" class="fig card-img">
               <p class="figure-name card-title">Figure 16.4: Quick Sort</p>
           </div>
          <p>As its name suggests, the quick sort<a id="5229"></a> algorithm<a id="5051"></a> is one of the fastest sorting<a id="5261"></a> algorithms. Like Bubble Sort, it is designed to sort an array<a id="5078"></a> "in place."" The quick sort<a id="5230"></a> algorithm<a id="5052"></a> is recursive and uses an elegant approach to subdividing the original vector. Figure 16.4 illustrates this process. The algorithm<a id="5053"></a> proceeds as follows:</p>
          <ul>
           <li>The terminating condition occurs when the vector is of length 1, which is obviously sorted.</li>
           <li>A "pivot point" is then chosen. Some sophisticated versions go to a significant amount of effort to calculate the most effective pivot point. We are content to choose the first item in the vector.</li>
           <li>The vector is then subdivided by moving all of the items less<a id="5185"></a> than the pivot to its left and all those greater than the pivot to its right, thereby placing the pivot in its final location in the resulting vector.</li>
           <li>The items to the left and right of the pivot are then recursively sorted by the same algorithm<a id="5054"></a>.</li>
           <li>The algorithm<a id="5055"></a> always converges because these two halves are always shorter than the original vector.</li>
          </ul>
          <p>Listing  16.3  shows  the  code  for  the  quick  sort  algorithm<a id="5056"></a>.  The partitioning algorithm<a id="5057"></a> looks a little messy, but it is just performing the array<a id="5079"></a> adjustments. It starts with <code>i</code> and <code>j</code> outside the vector to the left and right. Then it keeps moving each toward the middle as long as the values at <code>i</code> and <code>j</code> are on the proper side of the pivot. When this process stops, <code>i</code> and <code>j</code> are the indices of data items that are out of order. They are swapped, and the process is repeated until <code>i</code> crosses past <code>j</code>. Quick sort is O(N log N). As with the previous techniques, this algorithm<a id="5058"></a> applies to collections<a id="5134"></a> of any data type for which the functions <code>lt(A,B</code> and <code>gt(<a id="5174"></a>A,B)</code> compare two instances.</p>
          <p>There is one performance caution about quick sort<a id="5231"></a>. Its speed depends on the randomness of the data. If the data are mostly sorted, its performance reduces to O(N<sup>2</sup>).</p>
      </div>
      <div class="listing">#listing_16_3#</div>
    </div>

    <div class="chp-subsection" data-sub-num="4" data-sub-name="Merge Sort">
       <!-- Merge Sort -->
      <h3 id="16_2_4">16.2.4	Merge Sort</h3>
      <div class="container">
          <div class="float-sm-right card">
               <img src="..\Images\Fig_16_5.JPG" alt="Figure 16.5" class="fig card-img">
               <p class="figure-name card-title">Figure 16.5: Merge Sort</p>
           </div>
          <p>Merge sort is another O(N log N) algorithm<a id="5059"></a> that achieves speed by dividing the original vector into two "equal<a id="5147"></a>" halves. It is difficult at best to perform a merge sort<a id="5195"></a> in place in a collection. Equality, of course, is not possible when there is an odd number of objects<a id="5219"></a> to be sorted, in which case<a id="5126"></a> the length of the "halves" will differ by at most 1. The heart of the merge sort<a id="5196"></a> algorithm<a id="5060"></a> is the technique used to reunite two smaller sorted vectors. This function<a id="5160"></a> is called "merge." Its objective is to merge two vectors that have been previously sorted. Since the two vectors are sorted, the smallest object can only be at the front of one of these two vectors. The smallest item is removed from its place and added to the result vector. This merge process continues until one of the two halves is empty<a id="5137"></a>, in which case<a id="5127"></a> the remaining half (whose values all exceed those in the result vector) is copied into the result.</p>
          <p>The merge sort<a id="5197"></a> algorithm<a id="5061"></a> is shown in Figure 16.5 and proceeds as follows:</p>
          <ul>
           <li>The terminating condition is a vector with length less<a id="5186"></a> than 2, which is, obviously, in order</li>
           <li>The recursive part invokes the merge function<a id="5161"></a> on the recursive call to merge the two halves of the vector</li>
           <li>The process converges because the halves are always smaller than the original vector</li>
          </ul>
          <p>The code for merge sort<a id="5198"></a> is shown in Listing 16.4.</p>
      </div>
      <div class="listing">#listing_16_4#</div>
    </div>

    <div class="chp-subsection" data-sub-num="5" data-sub-name="Radix Sort">
       <!-- Radix Sort -->
      <h3 id="16_2_5">16.2.5	Radix Sort</h3>
      <div class="container clearfix">
          <div class="float-sm-right card">
               <img src="..\Images\Fig_16_6.JPG" alt="Figure 16.6" class="fig card-img">
               <p class="figure-name card-title">Figure 16.6: Radix Sort</p>
           </div>
          <p>A discussion of sorting<a id="5262"></a> techniques would not be complete without discussing radix sort<a id="5238"></a>, commonly referred to as bucket sort. This is also an O(N log N) algorithm<a id="5062"></a> whose most obvious application is for sorting<a id="5263"></a> physical piles of papers, such as students' test papers. However, the same principle can be applied to sorting<a id="5264"></a> successively on the units, tens and hundreds digit of numbers<a id="5209"></a> (hence, the term radix sort<a id="5239"></a>). The process begins with a stack<a id="5282"></a> of unsorted papers, each with an identifier consisting of a number or a unique name. One pass is made through the stack<a id="5283"></a> separating the papers into piles based on the first digit or character of the identifier. Subsequent passes sort each of these piles by subsequent characters or digits until all the piles have a small number of papers that can be sorted by insertion or selection sorts. The piles can then be reassembled in order. Figure 16.6 illustrates the situation at the end<a id="5141"></a> of the second sorting<a id="5265"></a> pass when piles for the first digit have also been separated by the second digit.</p>
          <p>There are a number of reasons why this technique is popular for sorting<a id="5266"></a>:</p>
          <ul>
           <li>There is a minimal amount of "paper shuffling" or bookkeeping</li>
           <li>The base of the logarithm in the O(N log N) is either 10 (numerical identifier) or 26 (alphabetic identifier), thereby providing a "constant multiplier" speed advantage</li>
           <li>Once the first sorting<a id="5267"></a> pass is complete, one can use multi-processing (in the form of extra people) to perform the remaining passes in parallel, thereby reducing the effective performance to O(N) (given sufficient parallel resources)</li>
          </ul>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="3" data-sect-name="Performance Analysis">
     <!-- Performance Analysis -->
    <h2 id="16_3">16.3 Performance Analysis</h2>
    <div class="container clearfix">
        <p>In order to perform a comparison of the performance of different algorithms, a script was written to perform each sort on a vector of increasing length containing random numbers<a id="5210"></a>. The script started with a length of 4 and continued doubling the length until it reached 262,144 (2<sup>18</sup>). To obtain precise timing measurements, each sort technique was repeated a sufficient number of times to obtain moderately accurate timing measurements with the internal millisecond clock. In order to eliminate common computation costs, it was necessary to measure the overhead cost of the loops themselves and subtract that time from the times of each sort algorithm<a id="5063"></a>. Note that in order to show the results of the system internal sort on the same chart, its execution<a id="5148"></a> time was multiplied by 1,000.</p>
        <div class="float-sm-right card">
             <img src="..\Images\Fig_16_7.PNG" alt="Figure 16.7" class="fig-wide card-img">
             <p class="figure-name card-title">Figure 16.7: Sort Study Results</p>
         </div>
        <p>Figure 16.7 shows a typical plot of the results of this analysis, illustrating the relative power of O(N log N) algorithms versus O(N<sup>2</sup>) algorithms. The plot on a log-log scale<a id="5241"></a> shows the relative time taken by the selection sort, insertion sort<a id="5182"></a>, bubble sort<a id="5119"></a>, merge sort<a id="5199"></a>, quick sort<a id="5232"></a>, and quick sort<a id="5233"></a> in place algorithms, together with the internal sort function<a id="5162"></a>. Also on the chart are plotted trend lines for O(N<sup>2</sup>) and O(N log N) processes. We can make the following observations from this chart:</p>
        <ul>
         <li>Since the scales are each logarithmic, it is tempting to claim that there is "not much difference" between O(N<sup>2</sup>) and O(N log N) algorithms. Looking closer, however, it is clear<a id="5130"></a> that for around 200,000 items, the O(N<sup>2</sup>) sorts are around 100,000 times slower than the O(N log N) algorithms.</li>
         <li>The performance of most of the algorithms is extremely erratic below 100 items. If you are sorting<a id="5268"></a> small amounts of data, the algorithm<a id="5064"></a> does not matter.</li>
         <li>The selection sort, bubble sort<a id="5120"></a>, and insertion sort<a id="5183"></a> algorithms clearly demonstrate O(N<sup>2</sup>) behavior.</li>
         <li>The merge sort<a id="5200"></a> and quick sort<a id="5234"></a> algorithms seem to demonstrate O(N log N). Notice, however, that the performance of quick sort<a id="5235"></a> is slightly better than O(N log N). This slight improvement is due to the fact that once the pivot has been moved, it is in the right place and is eliminated from further sorting<a id="5269"></a> passes.</li>
         <li>Clearly, the internal sort function<a id="5163"></a>, in addition to being 1,000 times faster than any of the coded algorithms, is closely tracking the O(N log N) performance curve, indicating that it is programmed with one of the many algorithms that use divide-and-conquer to sort the data as efficiently as possible.</li>
        </ul>
    </div>
  </div>

  <div class="chp-section" data-sect-num="4" data-sect-name="Applications of Sorting Algorithms">
     <!-- Applications of Sorting Algorithms -->
    <h2 id="16_4">16.4 Applications of Sorting Algorithms</h2>
    <div class="container">
        <p>This section discusses the circumstances under which you might choose to use one or another of the sorting<a id="5270"></a> algorithms presented above. We assert here without proof that the theoretical lower bound of sorting<a id="5271"></a> is O(N log N). Consequently, we should not be looking for a generalized sorting<a id="5272"></a> algorithm<a id="5065"></a> that improves on this performance. However, within those constraints, there are circumstances under which each of the sorting<a id="5273"></a> techniques performs best. As we saw in the analysis above, the internal sort function<a id="5164"></a> is blindingly fast and should be used whenever possible. The subsequent paragraphs show the applicability and limitations of the other sort algorithms if you cannot use <code>sort(<a id="5246"></a>...)</code>.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Using sort(...)">
       <!-- Using sort -->
      <h3 id="16_4_1">16.4.1	Using sort(<a id="5247"></a>. . .)</h3>
      <div class="container">
          <p>The first and most obvious question is why one would not always use the built-in <code>sort(<a id="5248"></a>...)</code> function<a id="5165"></a>. Clearly, whenever that function<a id="5166"></a> works, you should use it. Its applicability might seem at first glance to be limited to sorting<a id="5274"></a> numbers<a id="5211"></a> in an array<a id="5080"></a>, and you will come across circumstances when you need to sort more complex items. You might, for example, have a structure<a id="5284"></a> array<a id="5081"></a> of addresses and telephone numbers<a id="5212"></a> that you wish to sort by last name, first name, or telephone number. In this case<a id="5128"></a>, it seems that the internal sort program does not help<a id="5176"></a>, and you have to create your own sort.</p>
          <p><b>Extracting and Sorting Vectors and Cell Arrays</b> However, a closer examination of the specification of the sort function<a id="5167"></a> allows us to generalize the application of <code>sort(<a id="5249"></a>...)</code> significantly. When you call <code>sort(<a id="5250"></a>v)</code>, it actually offers you a second result that contains the indices used to sort <code>v</code>. So in the case<a id="5129"></a> where you have a cell array<a id="5082"></a> or a structure<a id="5285"></a> array<a id="5083"></a> and your sort criteria can be extracted into a vector, you can sort that vector and use the second result, the indexing order, to sort the original array<a id="5084"></a>. Furthermore, if you can extract character string data into a cell array<a id="5085"></a> of strings, the internal sort function<a id="5168"></a> will sort that cell array<a id="5086"></a> alphabetically.</p>
          <p>For example, consider again the CD collection from Chapter 10. We might want to find the most expensive CD in our collection and then make a list of artists and titles ordered alphabetically by artist. We leave the details of this as an exercise for the reader.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Insertion Sort">
       <!-- Insertion sort -->
      <h3 id="16_4_2">16.4.2	Insertion Sort</h3>
      <div class="container">
          <p>Insertion sort is the fastest means of performing incremental sorting. If a small number of new items - say, M - are being added to a sorted collection of size N, the process will be O(M*N), which will be fastest as long as M < log N. For example, consider a national telephone directory with over a billion numbers that must frequently be updated with new listings. Adding a small number of entries (< 20) would be faster with insertion sort than with merge sort, and quick sort would be a disaster because the data are almost all sorted (see below).</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Bubble Sort">
       <!-- Bubble sort -->
      <h3 id="16_4_3">16.4.3	Bubble Sort</h3>
      <div class="container">
          <p>Bubble sort is the simplest in-place sort to program and is fine for small amounts of data. The major advantage of bubble sort<a id="5121"></a> is that in a fine-grained multi-processor environment, if you have N/2 processors available with access to the original data, you can reduce the Big<a id="5107"></a> O to O(N).</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="4" data-sub-name="Quick Sort">
       <!-- Quick Sort -->
      <h3 id="16_4_4">16.4.4	Quick Sort</h3>
      <div class="container">
          <p>As its name suggests, this is the quickest of the sorting<a id="5275"></a> algorithms and should normally be used for a full sort. However, it has one significant disadvantage: its performance depends on a fairly high level of randomness in the distribution of the data in the original array<a id="5087"></a>. If there is a significant probability that your original data might be already sorted, or partially sorted, your quick sort<a id="5236"></a> is not going to be quick. You should use merge sort<a id="5201"></a>.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="5" data-sub-name="Merge Sort">
       <!-- Merge Sort -->
      <h3 id="16_4_5">16.4.5	Merge Sort</h3>
      <div class="container">
          <p>Since its algorithm<a id="5066"></a> does not depend on any specific characteristics of the data, merge sort<a id="5202"></a> will always turn in a solid O(N log N) performance. You should use it whenever you suspect that quick sort<a id="5237"></a> might get in trouble.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="6" data-sub-name="Radix Sort">
       <!-- Radix Sort -->
      <h3 id="16_4_6">16.4.6	Radix Sort</h3>
      <div class="container">
          <p>It is theoretically possible to write the radix sort<a id="5240"></a> algorithm<a id="5067"></a> to attempt to take advantage of its apparent performance improvements over the more conventional algorithms shown above. However, some practical problems arise:</p>
          <ul>
           <li>In practice, the manipulation of the arrays of arrays necessary to sort by this technique is quite complex</li>
           <li>The performance gained for manual sorts by "parallel processing" stacks using multiple people cannot be realized</li>
           <li>The logic<a id="5190"></a> for extracting the character or digit for sorting<a id="5276"></a> is going to detract from the overall performance</li>
          </ul>
          <p>Therefore, absent some serious parallel processing machines, we recommend that the use of bucket sort be confined to manually sorting<a id="5277"></a> large numbers<a id="5213"></a> of physical objects<a id="5220"></a>.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="5" data-sect-name="Engineering Example - A Selection of Countries">
     <!-- Engineering Example -->
    <h2 id="16_5">16.5	Engineering Example - A Selection of Countries</h2>
    <div class="container clearfix">
        <p>In the Engineering Application problem in Section 10.5, we attempted to find the best country for a business expansion based on the rate of growth of the GNP for that country versus its population growth. The initial version of the program returned the suggestion that the company should move to Equatorial Guinea. However, when this was presented to the Board of Directors, it was turned down, and you were asked to bring them a list of the best 20 places to give them a good range of selection.</p>
        <div class="card float-sm-right common-pitfalls">
            <p class="card-title">Common Pitfalls 16.1</p>
            <p class="card-text">A deceptively simple question arises: Should you expect the <code>worldData</code> in the <code>findBestn</code> function<a id="5169"></a> to contain the field<a id="5154"></a> growth? Actually, it will not. Although it appears that the function<a id="5170"></a> <code>findBestn</code> adds this field<a id="5155"></a> to worldData , it is working with a copy of the <code>worldData</code> structure<a id="5286"></a> array<a id="5088"></a> that is not returned to the calling script.</p>
        </div>
        <p>We should make two changes to the algorithm<a id="5068"></a>:</p>
        <ul>
        <li>Originally, we used a crude approximation to determine the slope of the population and GNP curves. However, now we know that <code>polyfit</code> can perform this slope computation accurately, and we will substitute that computation.</li>
        <li>We will use the internal sort function<a id="5171"></a> to find the 20 best countries.</li>
        </ul>
        <p>The code to accomplish this, a major revision of the code in Chapter 10, is shown in Listing 16.5.</p>
        <p>The results from running this version are shown in Table 16.2. This seems to be an acceptable list of possibilities to take back to the Board of Directors.</p>
        <div class="listing">#listing_16_5#</div>
        <table class="table">
            <caption>Table 16.2: Updated world data results</caption>
            <tbody>
                <tr>
                    <td>Estonia</td>
                    <td>Lebanon</td>
                    <td>St. Kitts &<a id="5228"></a> Nevis</td>
                    <td>Malta</td>
                </tr>
                <tr>
                    <td>Albania</td>
                    <td>Cyprus</td>
                    <td>Vietnam</td>
                    <td>Tajikistan</td>
                </tr>
                <tr>
                    <td>Croatia</td>
                    <td>Taiwan</td>
                    <td>Kazakhstan</td>
                    <td>Korea, Republic of</td>
                </tr>
                <tr>
                    <td>Azerbaijan</td>
                    <td>Grenada</td>
                    <td>Uzbekistan</td>
                    <td>Ireland</td>
                </tr>
                <tr>
                    <td>Georgia</td>
                    <td>Portugal</td>
                    <td>Dominica</td>
                    <td>Antigua</td>
                </tr>
            </tbody>
        </table>
    </div>
  </div>

  <!-- Chapter Summary -->
  <h2>Chapter Summary</h2>
  <div class="container">
      <p>This chapter discussed:</p>
      <ul>
          <li>A technique for comparing the performance of algorithms</li>
          <li>A range of useful algorithms for sorting<a id="5278"></a> a collection of data</li>
          <li>Application areas in which these algorithms are most appropriate</li>
      </ul>
  </div>
<h2>Self Test</h2>
<div class="container">

Use the following questions to check your understanding of the material in this
chapter:
<h3>True or False</h3>
<ol>
<li>When computing the Big<a id="5108"></a> O of sequential operations<a id="5224"></a>, you retain only
the term that grows fastest with N.</li>
          <li>All search algorithms have O(N).</li>
          <li>No sort algorithm<a id="5069"></a> can perform better than O(NlogN).</li>
          <li>All sorting<a id="5279"></a> algorithms with O(N<sup>2</sup>) traverse the complete data
collection N times.</li>
          <li>Quick sort in reality should be listed as O(N<sup>2</sup>).</li>
</ol>
<h3>Fill in the Blanks</h3>
<ol>
<li>________________ is an algebra that permits us to express how the
amount of ___________ done in solving a problem relates to the
amount ____________ of being processed.</li>
          <li>Any algorithm<a id="5070"></a> that traverses, maps, folds, or filters a collection is
O(__________).</li>
          <li> _________ sort and _____________ sort perform with O(NlogN).</li>
          <li>_________ sort and _____________ sort are designed to sort the
data in place.</li>
          <li>The system internal sort(<a id="5251"></a>...) returns the ___________ and a(n)
___________ that allow you to sort any collection from whose
elements one can derive a(n) ___________ or ______________________.</li>
</ol>

</div>
</div>


</body>
</html>

