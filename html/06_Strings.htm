<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
    <title>06_Strings</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="styles/styles.css" />
    <script async src="./javascript/index.js"></script>
</head>
<body>
<div>#top_nav#</div>
<div class="nav-obj">#nav_obj#</div>
<div class="content">
  <h1 id="6" align="center">Chapter 6: Strings</h1>

  <!-- Chapter Objectives -->
  <h1>Chapter Objectives</h1>
  <div class="container">
    <p>This chapter discusses the nature<a id="1842"></a>, implementation, and behavior of
    character strings<a id="1731"></a> in the MATLAB language:</p>
    <ul>
      <li>The internal workings of character strings<a id="1732"></a> as vectors</li>
      <li>Operations on character strings<a id="1733"></a></li>
      <li>Converting between numeric and character string representations</li>
      <li>Input and output functions</li>
      <li>The construction and uses for arrays of strings</li>
    </ul>
    <p>To this point in the text, we have seen the use of character strings<a id="1734"></a> that we can store in variables and display in the Command window. In reality, we have already seen a significant amount of character manipulation<a id="1848"></a> that we have taken for granted. The m-files we use to store scripts and functions contain lines of legible characters separated by an invisible “new-line” character.</p>
  </div>

  <!-- Introduction -->
  <h1>Introduction</h1>
  <div class="container">
    <p>This chapter presents the underlying concept of character storage and the tools MATLAB provides for operating<a id="1851"></a> on character strings<a id="1735"></a>. We need to distinguish two different relationships between characters and
    numbers:</p>
    <ol>
      <li>Individual characters have an internal numerical<a id="1838"></a> representation: the visible character shapes we see in windows<a id="1853"></a> are created as a collection of white and black dots by special software called a character generator. Character generators allow us to take the underlying concept of a character - say, “w” - and “draw” that character on screen or paper in accordance with the rules defined by the current font. A complete study of fonts is beyond the scope of
      this discussion, but we need to understand how computers in general and the
      MATLAB language in particular represent that “underlying concept” of a character. This is achieved by representing each individual character by its
      numerical<a id="1839"></a> equivalent. Not long ago, there were many different representations.
      Today, the dominant representation is the one defined by the American
      Standard Code for Information Interchange (ASCII). In this representation, the
      most common uppercase and lowercase characters, numbers, and many
      punctuation marks are represented by numbers between 0 and 127. A
      complete listing of the first 255 values is included in Appendix B.</li>
      <li>Strings of characters represent numerical<a id="1840"></a> values to the user: numerical values
      are stored in a special, internal representation for efficient numerical
      computation as described in Appendix C . However, whenever we need to see
      the value of that number in the Command window, that internal
      representation is automatically converted by MATLAB into a character string
      representing its value in a form we can read. For example, if the variable a
      contained the integer value 124, internally that number could be stored in a
      single byte (8 bits) with a binary<a id="1716"></a> value of 011111100—not a very meaningful
      representation, but efficient internally for performing arithmetic<a id="1709"></a> and logical
      operations. For the user to understand that value, internal MATLAB logic must
      convert it to the three printable characters: '124' . Similarly, when we type in
      the Command window or use the input(<a id="1788"></a>...) function, the set of characters
      that we enter is automatically translated from a character string into the
      internal number representation.</li>
    </ol>
  </div>

  <div class="chp-section" data-sect-num="1" data-sect-name="Character String Concepts: Mapping, Casting, Tokens, and Delimiting">
    <!-- Character String Concepts -->
    <h2 id="6_1">6.1 Character String Concepts: Mapping, Casting, Tokens, and Delimiting</h2>
    <div class="container">
      <p>Here we see the MATLAB language tools that deal with the first relationship
      between characters and numbers: the numerical representation of individual
      characters.</p>
      <p>The basic idea of <b>mapping<a id="1744"></a></b> is that it defines a relationship between two
      entities. The most obvious example of mapping<a id="1745"></a> is the idea that the function<br><br>
      <code>f(x) = 2 &#215; x</code><br><br>
      defines the mapping<a id="1746"></a> between the value of <code>x</code> and the value of <code>f(x)</code> .
      We will apply that concept to the process of translating a character (like
      "A") from its graphical form to a numerical internal code. Character
      mapping<a id="1747"></a> allows each individual graphic character to be uniquely
      represented by a numerical value.</p>
      <p><b>Casting</b> is the process of changing the way a language views a piece of
      data without actually changing the data value. Under normal circumstances,
      a language like MATLAB automatically presents a set of data in the "right"
      form. However, there are times when we wish to force the language to
      treat a data item in a specific way. For example, if we create a variable containing a character string, MATLAB will consistently display it as a character string. However, we might want to view the underlying
      numerical representation as a number, in which case we have to cast the
      variable containing the characters to a numerical data type. MATLAB
      implements casting<a id="1717"></a> as a function with the name of the data type expected.
      In essence, these functions implement the mapping<a id="1748"></a> from one character
      representation to another. For example:<br><br>
      <code> &gt;&gt; str = 'ABCD'<br>
      str =
      &nbsp;&nbsp;&nbsp;&nbsp; ABCD<br>
      &gt;&gt; double(<a id="1773"></a>str)<br>
      ans =
      &nbsp;&nbsp;&nbsp;&nbsp; 65 66 67 68<br><br>
      </code>In your workspace window, <code>ans</code> will be of type <code>double</code>.</p>
      <p>A <b>token<a id="1756"></a></b> is a collection of characters to which we may wish to attach
      meaning. Obvious examples<a id="1823"></a> of tokens are the name of a MATLAB variable
      or the characters representing the values of a number to be used in an
      expression.</p>
      <p>A <b>delimiter<a id="1766"></a></b> is a character used to separate tokens. The space character,
      for example, can delimit words in a sentence; punctuation marks provide
      additional delimiters with specific meanings.</p>
    </div>
  </div>

  <div class="chp-section" data-sect-num="2" data-sect-name="MATLAB Implementation">
    <h2 id="6_2">6.2 MATLAB Implementation</h2>
    <div class="container">
      <p>When you enter a string in the Command window or the editor, MATLAB
      requires that you delimit the characters of a string with a single quote mark
      ( ' ). Note that you can include a single quote mark within the string by
      doubling the character. For example, if you entered the following in the
      Command window:<br><br>
      <code>>> refusal = 'I can''t do that!'</code><br><br>
      The result displayed would be<br><br>
      <code>refusal = <br>
        &nbsp;&nbsp;&nbsp;&nbsp;I can't do that</code><br><br></p>
      <p>Exercise 6.1 illustrates the concept of casting<a id="1718"></a> between data types <code>char</code> and
      <code>double</code>.</p>
      <div class="exercise">#exercise_6_1#</div>
      <p>In Exercise 6.1:</p>
      <ul>
        <li>the casting<a id="1719"></a> function <code>uint8(<a id="1849"></a>...)</code> takes a character or
        character string and changes its representation to a vector of the same
        length as the original string.</li>
        <li>Then the casting<a id="1720"></a> function <code>char(<a id="1725"></a>...)</code> takes a
        number or vector and causes it to be presented as a string. </li>
        <li>The casting<a id="1721"></a> function <code>double(<a id="1774"></a>...)</code> appears to act in the same way as <code>uint8(<a id="1850"></a>...)</code>, but it
        actually uses 64 bits to store the values. </li>
        <li>Single quotes delimit a string to be
        assigned to the variable <code>fred</code>. Notice that when a string is presented as a
        result, the delimiters are omitted.</li>
        <li>When you apply arithmetic<a id="1710"></a> operations to
        a string, the operation<a id="1836"></a> is illegal on characters; therefore, an implicit casting<a id="1722"></a>
        to the numerical equivalent occurs.</li>
        <li>You can perform any mathematical operation<a id="1837"></a> on the vector and use the
          cast, <code>char(<a id="1726"></a>...)</code>, to cast it back to a string.</li>
      </ul>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Slicing and Concatenating Strings">
      <!-- Slicing and Concatenating Strings -->
      <h3 id="6_2_1">6.2.1 Slicing and Concatenating Strings</h3>
      <div class="container">
        <p>Strings are internally represented as vectors; therefore, we can perform all
        the usual vector operations on strings. Try it in Exercise 6.2.</p>
        <div class="exercise">#exercise_6_2#</div>
        <ul>
          <li>First, we set the variable <code>first</code>.</li>
          <li>Then, the variable <code>last</code>.</li>
          <li>Then we concatenate the strings with a space separating them.</li>
          <li>Then we display every other character in the name.</li>
          <li>Then we display the letters of name in reverse order.</li>
        </ul>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Arithmetic and Logical Operations">
      <!-- Arithmetic and Logical Operations -->
      <h3 id="6_2_2">6.2.2 Arithmetic and Logical Operations</h3>
      <div class="container">
        <p>Exactly as operating<a id="1852"></a> on vectors, string operations<a id="1755"></a> may be either mathematical or logical operations.</p> 
		<p>Mathematical operations can be performed on the numerical mapping<a id="1749"></a> of a
        character string. If you do not explicitly perform that casting<a id="1723"></a> first, MATLAB
        will do the cast for you and create a result of type double (not usually
        suitable for character values). Note that <code>char(<a id="1727"></a>'a' + 1 )</code> returning<a id="1805"></a> <code>'b'</code> is an
        accident of the character type mapping<a id="1750"></a>.</p>
        <p>Logical operations on character strings<a id="1736"></a> are also exactly equivalent to
        logical operations on vectors, with the same automatic casting<a id="1724"></a>. Exercise 6.3
        gives you an opportunity to try it yourself.</p>
        <div class="exercise">#exercise_6_3#</div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Useful Functions">
      <!-- Userful Functions -->
      <h3 id="6_2_3">6.2.3 Useful Functions</h3>
      <div class="container">
        <p>The following functions are useful in analyzing character strings<a id="1737"></a>:</p>
        <ul>
          <li><code>ischar(<a id="1797"></a>a)</code> returns true if <code>a</code> is a character string</li>
          <li><code>isspace(<a id="1798"></a>ch)</code> returns true if the character <code>ch</code> is the space character</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="3" data-sect-name="Format Conversion Functions">
    <!-- Format Conversion Functions -->
    <h2 id="6_3">6.3 Format Conversion Functions</h2>
    <div class="container">
      <p>Now we turn to the second relationship between characters and numbers:
      using character strings<a id="1738"></a> to represent individual number values. To move seamlessly 
	  between their internal representation and the visual, external representation, we need string conversion<a id="1753"></a>. We actually need
      two separate capabilities: converting numbers from the efficient, internal
      form to legible strings and converting strings provided by users of MATLAB
      into the internal number representation. MATLAB provides a number of
      functions that transform data between string format<a id="1827"></a> and numerical format<a id="1828"></a>.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Conversion from Numbers to Strings">
      <!-- Conversion from Numbers to Strings -->
      <h3 id="6_3_1">6.3.1 Conversion from Numbers to Strings<a id="1739"></a></h3>
      <div class="container">
        <p>Use the following built-in MATLAB functions for a simple conversion of a
        single number, <code>x</code>, to its string representation:</p>
        <ul>
          <li><code>int2str(<a id="1796"></a>x)</code> if you want it displayed as an integer value</li>
          <li><code>num2str(<a id="1799"></a>x, n)</code> to see the decimal parts; the parameter <code>n</code> represents
          the number of decimal places required—if not specified, its default
          value is <code>3</code>.</li>
        </ul>
        <p>Frequently, however,  you need better control over the data conversion, and the
        function <code><b>sprintf(<a id="1808"></a>...)</b></code> provides fine-grained control. The MATLAB version
        of <code>sprintf(<a id="1809"></a>...)</code> is very similar to the C/C++ implementation of this
        capability. The first parameter to <code>sprintf</code> is a <b>format<a id="1829"></a> control<a id="1740"></a> string</b> that
        defines exactly how the resulting string should be formatted. A variable
        number of <b>value parameters</b> follow the format<a id="1830"></a> string, providing data items
        as necessary to satisfy the formatting.</p>
        <p>Basically, the format<a id="1831"></a> string contains characters to be copied to the
        string returned from <code>sprintf(<a id="1810"></a>...)</code>; however, it also contains two types of functionality introduced by
        the following two special characters:</p>
        <ul>
          <li>The <code>'%'</code> character introduces a conversion specification, indicating
          how one of the value parameters should be represented. The most
          common conversions are <code>%d</code> (integer), <code>%f</code> (real), <code>%g</code> (general), <code>%c</code>
          (character), and <code>%s</code> (string). A number may be placed immediately
          after the <code>%</code> character to specify the minimum number of characters
          in the conversion. If more characters than the specified minimum
          are required to represent the data,<a id="1841"></a> they will be added. In addition,
          the <code>%f</code> and <code>%g</code> conversions can include <code>'.n'</code> to indicate the number
          of decimal places required. If you actually want a <code>'%'</code> character, it
          must be doubled, for example, <code>'%%'</code>. MATLAB processes each of the
          value parameters in turn, inserting<a id="1713"></a> them in the result string
          according to the corresponding conversion specification. If there are
          more parameters than conversion specifications in the format<a id="1832"></a>
          control string, the format<a id="1833"></a> control<a id="1741"></a> string is repeated.</li>
          <li id="120">The '\' character introduces format<a id="1834"></a> control<a id="1742"></a> information, the most
          common of which are \n (new line) and \t (tab). If the '\' character
          is actually wanted in the result string, it should be doubled, for
          example, '\\'.</li>
        </ul>
        <p>For example, consider the following statements:<br><br>
        <code>&nbsp;&nbsp;&nbsp;&nbsp;A = [4.7 1321454.47 4.8];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;index = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;v = 'values';<br>
        &nbsp;&nbsp;&nbsp;&nbsp;str = sprintf(<a id="1811"></a>'%8s of A(%d) are \t%8.3f\t%12.4g\t%f\n'...<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v, index, A(index,1), A(index,2), A(index,3)) <br>
        &nbsp;&nbsp;&nbsp;&nbsp;str =<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values of A(1) are 4.700 1.321e+006 4.800000</code></p>
        <p>
        <ul>
          <li>We first prepared the variables <code>A</code>, <code>index</code> and <code>v</code>, and then called for <code>sprintf(<a id="1812"></a>...)</code> to present their values.</li>
          <li>The first conversion, <code>%8s</code>, takes the value of the first parameter, <code>v</code>, allows
          eight spaces for its conversion, and copied its contents to the resulting string. Since this
          was a string conversion<a id="1754"></a>, the characters are merely copied.</li>
          <li>The characters <code>' of A('</code> are then appended to the output string.</li>
          <li>The second conversion, <code>%d</code>, takes the value of the second parameter, index, and converts it as an
          integer with the minimum space allocated.</li>
          <li>The characters <code>') are'</code> are then
          appended to the output string, followed by a tab character that inserts enough spaces to bring the next characters to a column that is an even multiple of eight.</li>
          <li>The following three conversions appended the next three
          value parameters with three decimal places, a general conversion
          with at least 12 spaces and 4 decimal places, and the default numerical
          conversion.</li>
          <li>Finally, a new line character was inserted into the string.</li>
        </ul>
        <p>We will formalize here the function<br><br>
        <code>fprintf(<a id="1784"></a>&lt;control string&gt;, &lt;parameters&gt;)</code><br><br>
        where the <code>&lt;control string&gt;</code> is the format control<a id="1743"></a> string discussed above, and<br>
        <code>&lt;parameters&gt;</code> is a collection of 0 or more parameters whose values will be presented in each <code>'%'</code> entry in the control string.</p>
        <p>The function <code>fprintf(<a id="1785"></a>...)</code> works exactly as <code>sprintf(<a id="1813"></a>...)</code> except that instead of returning<a id="1806"></a> the resulting string, it writes that string directly to the command window. Notice its use at the bottom of Listing 6.1 below.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Conversion from Strings to Numbers and Other Stuff">
      <!-- Conversion from Strings to Numbers and Other Stuff -->
      <h3 id="6_3_2">6.3.2 Conversion from Strings to Numbers and Other Stuff</h3>
      <div class="container">
        <p>Conversion from strings to numbers is much messier. In order to understand the situation, let us emulate some of the Matlab behavior that you have already used, but probably not realized all the underlying complexity.</p>
        <p><b>First Try</b>: Suppose, for example, you have the string: <code>'area = 3.14159265 .* radius .^ 2'</code>. In paragraph 6.1, we mentioned the idea of a token<a id="1757"></a> as a string whose meaning is important and the delimiters that separate tokens. Our first guess might be to assume that <code>'area'</code>, <code>'='</code>, <code>'3.14159265'</code>, <code>'.*',</code> <code>'radius'</code>, <code>'.^'</code> and <code>'2'</code> were the tokens because they carry the meaning of the equation, and the space character is the delimiter<a id="1767"></a>.</p>
        <p>In order to separate this out into its individual tokens, we will repeatedly employ the function <code>strtok(<a id="1820"></a>...)</code>. This function consumes two inputs and produces two outputs:</p>
        <p><code>[token<a id="1758"></a>, rest] = strtok(<a id="1821"></a>str, delims)</code></p>
        <p>where <code>str</code> is the string to process, <br>
        <code>delims</code> is a string of delimiting characters, <br>
        <code>token<a id="1759"></a></code> is the first token<a id="1760"></a> returned, and<br>
        <code>rest</code> is what remains of the string when that token<a id="1761"></a> is removed.</p>
        <p>Look carefully through Listing 6.1 to see how we extract the meaning from the line of code.</p>
        <div class="listing">#listing_06_1#</div>
        <p>When you run this code, you see this in the Command Window<a id="1765"></a>:</p>
        <p><code>
        calculate area by doing .^ with radius and 2, then doing .* with the result and 3.1416<br>
        </code></p>
        <p>Notice that I deliberately changed the numerical resolution<a id="1835"></a> of <code>pi</code> to only 4 decimal places to assert that we really did convert the string <code>num_1</code> to the <code>double</code> value <code>n_1</code>.</p>
        <p><b>Second Thought</b>: now, what could possibly go wrong ... oh, wait a sec</p>
        <ul>
          <li>although we have been inserting<a id="1714"></a> spaces in the code for clarity, this line is quite legal: <code>'area=3.14159265.*radius.^2'</code>.  So we have to treat the '<code>=</code>' and even worse, the '<code>.*</code>' and '<code>.^</code>' as delimiters. </li>
          <li>Messier still, the simple parsing in Listing 6.1 had to assume that the first token<a id="1762"></a> was a variable name, the second was the '=' to make an assignment<a id="1715"></a> etc. We are certainly not intending to delve into the correct way to process this simple line of code.</li>
        </ul>
        <p>I did warn you at the top of this paragraph about messes to come ...</p>
        <p><b>Preferred Approach:</b> When possible, allow MATLAB’s built-in functions
        <code>str2num</code>, <code>str2double</code> or <code>input(<a id="1789"></a>...)</code> to do the work of conversion for you:</p>
        <ul>
          <li>The function <code>str2num(<a id="1816"></a>str)</code> consumes a string representing either a single
          numerical value or an arbitrarily complex array of numbers and returns the numerical equivalent.</li>
          <li>The function <code>str2double(<a id="1775"></a>str)</code> consumes a string representing only a single
          numerical value and returns the numerical equivalent with <code>double</code> precision.</li>
          <li>The function <code>input(<a id="1790"></a>prompt)</code> presents the prompt string to the user in the
          Command window and waits for the user to type some characters and the [Enter] key, all of which are echoed in the Command window. Then it parses the input string in exactly the same manner as if you had typed that string to the command window, according to the following rules:<br>
          <ol>
            <li>If the string begins with a numerical character, MATLAB converts
            the string to a number</li>
            <li>If it begins with a non-numeric character, MATLAB constructs a
            variable name and looks for its current value</li>
            <li>If you actually want a string literal entered, it must be enclosed in the
            string delimiters.</li>
            <li>If it begins with an open bracket, <code>'['</code>, a vector is constructed</li>
            <li>If it begins with the single quote character, MATLAB creates a
            string</li>
            <li>If a format error occurs, MATLAB repeats the prompt and waits for another input</li>
          </ol>
          This behavior can be modified if <code>'s'</code> is provided as the second parameter,
          <code>input(<a id="1791"></a>prompt, 's')</code>, in which case the complete input character sequence is
          returned to the user as a string with no attempt to perform the above conversions. Exercise 6.4 demonstrates a number of capabilities of the <code>input(<a id="1792"></a>...)</code> function.
          </li>
        </ul>
        <div class="exercise">#exercise_6_4#</div>
        <p><b>Severe Warning: </b> Be careful to separate in your mind the use of the <code>input(<a id="1793"></a>...)</code> function and the process of passing parameters into a function. When values are passed to a function, we refer to this as the function <b><i>consuming</i></b> the incoming parameter(s), and this process happens automatically as part of the function call processing<a id="1825"></a>.  The <code>input(<a id="1794"></a>...)</code> function is a manual process whereby the user has to type data to be processed. The <code>input(<a id="1795"></a>...)</code> function should only be used in scripts that test functions and <b><i>never</i></b> in the body of a function.</p>
        <p><b>Hopeful footnote:</b> If you have to do some complex conversions
        yourself, the function <code>sscanf(<a id="1815"></a>...)</code> was designed to extract the values of variables
        from a string, but is really difficult to use. Instead,
        you can either split a string into tokens as we did above, and then convert each
        token<a id="1763"></a> with the str2num(<a id="1817"></a>str) function or, you might be better off putting that string into a text file and using the techniques in Chapter 8 to extract the meaning you need.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="4" data-sect-name="Character String Operations">
    <!-- Character String Operations -->
    <h2 id="6_4">6.4 Character String Operations</h2>
    <div class="container">
      <p>As with the string-to-number conversions, input and output in the
      Command window can be accomplished with simple functions that have
      little flexibility or with complex functions that have better control.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Simple Data Output: The disp(...) Function">
      <!-- Simple Data Output -->
      <h3 id="6_4_1">6.4.1 Simple Data Output: The <code>disp(<a id="1770"></a>. . .)</code> Function</h3>
      <div class="container">
        <p>We have already seen the use of the <code>disp(<a id="1771"></a>...)</code> function to present data in
        readable form in the Command window. It can
        present the values of any variable, regardless of type, or of strings
        constructed by concatenation<a id="1711"></a>. Note, however, that an explicit number
        conversion is required to concatenate variables with strings. Note also that conversion
        from the ASCII<a id="1706"></a> code is not automatic; you need the <code>char(<a id="1728"></a>...)</code> cast function.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Complex Output">
      <!-- Complex Output -->
      <h3 id="6_4_2">6.4.2 Complex Output</h3>
      <div class="container">
        <p>We discussed the functions fprintf(<a id="1786"></a>...) and sprintf(<a id="1814"></a>...) in Paragraph 6.3.1. While slightly messy to use, their flexibility makes them the functions of choice for displaying<a id="1826"></a> nicely formatted results.  Appendix A includes a complete discussion of the behavior of elements in the control strings of these functions.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Comparing Strings">
      <!-- Comparing Strings -->
      <h3 id="6_4_3">6.4.3 Comparing Strings</h3>
      <div class="container">
        <p>Since strings are readily translated into vectors of numbers, they may be
        compared in the obvious way with the logical operators we used on
        numbers. However, there is the restriction that either the strings must be of the same length or one of them must be of length 1 before it is legal to
        compare them with these operators. To avoid this restriction, MATLAB
        provides the function <code>strcmp(<a id="1818"></a>&lt;s1&gt;, &lt;s2&gt;)</code> that returns <code>true</code> if the
        strings are identical and <code>false</code> if they are not.
        Unfortunately for C programmers, this is not quite the same behavior as the C version, which
        does a more rigorous comparison returning<a id="1807"></a> <code>−1</code>, <code>0</code>, or <code>1</code>. You can study character string comparison in Exercise 6.5.</p>
        <div class="exercise">#exercise_6_5#</div>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="5" data-sect-name="Arrays of Strings">
    <!-- Arrays of Strings -->
    <h2 id="6_5">6.5 Arrays of Strings</h2>
    <div class="container">
      <p>Since a single character string is stored as a vector, it seems natural to
      consider storing a collection of strings as an array. The most obvious way to
      do this, as shown in previous examples<a id="1824"></a>, has some limitations, for which
      there are nice, tidy cures built into the MATLAB language. Consider the
      example shown in Exercise 6.6. Character arrays can be constructed by
      either of the following:</p>
      <ul>
        <li>As a vertical vector of strings, all of which must be the same
        length</li>
        <li>By using a special version of
        the char(<a id="1729"></a>) cast function that
        accepts a variable number of
        strings with different lengths,
        pads them with blanks to
        make all rows the same length,
        and stores them in an array of
        characters</li>
      </ul>
      <div class="exercise">#exercise_6_6#</div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="6" data-sect-name="Engineering Example - Encryption">
    <!-- Engineering Example -->
    <h2 id="6_6">6.6 Engineering Example - Encryption</h2>
    <div class="container clearfix">
      <p><b>The Problem</b>  As public access to information becomes more pervasive, there is increasing
      interest in the use of encryption<a id="1777"></a> to protect intellectual property and private
      communications from unauthorized access. The following discussion is
      based on no direct knowledge of the latest encryption<a id="1778"></a> technology.
      However, it illustrates a very simple approach to developing an algorithm<a id="1844"></a>
      that is immune to all but the most obvious, brute-force code-breaking
      techniques.</p>
      <div class="float-sm-right card">
          <img src="..\Images\Fig_6_1.JPG" alt="Figure 6.1" class="fig fig-long card-image">
          <p class="figure-name card-title">Figure 6.1: An Enigma Machine</p>
      </div>
      <p><b>Background</b>  Historically, a simple encryption<a id="1779"></a> was accomplished using a Caesar cypher that used a single offset value,
      say N, to replace all characters with the character N spaces farther down the alphabet. If the entered
      value was 'A' and N was 4, the encrypted text would have 'E'. With strictly manual analysis, without
      knowing N, it was deemed impossible to decipher messages. In World War II, the German armed forces<a id="1782"></a>
      used a slight modification to this algorithm<a id="1845"></a> whereby each key in the alphabet had a different offset value.
      Figure 6.1 shows an actual Enigma machine that automatically applied the key offset values to messages
      typed on its keyboard. However, it was vulnerable for two reasons:</p>
      <ul>
        <li>there was still a constant mapping<a id="1751"></a> between plain text and encrypted charaacters leaving it open to "simple" letter frequency analysis, and</li>
        <li>since it was difficult to distribute fresh key maps, the maps were only changed once a day.</li>
      </ul>
      <p>A massive effort in England led by Alan Turing produced "Colossus" discussed in Paragraph 1.2.2 that was generally recognized as one of the first "general-purpose" computers. It was able to decode a large majority of the intercepted German message traffic, and was credited with contributing to the end of that terrible war.</p>
      <p><b>The Solution</b> We propose a simple algorithm<a id="1846"></a> whereby the key replacement map can be changed rapidly so that
       the same letter in the original message is only replaced by the same substitute for a short period of time.  Hnce, no simple language analysis will crack the code. The <code>rand(<a id="1800"></a>...)</code> function is an excellent source for an appropriate random sequence. If the encryption<a id="1780"></a> and decryption processes use the same value to seed the same random generator, the same sequence of apparently random (pseudo-random) values will be generated. Since the seed can take on <code>2<sup>31</sup> – 2</code> values, it is virtually impossible to determine the decryption without knowing the seed value. The seed (i.e., the decryption key) can be transmitted to anyone authorized to decrypt the message by any number of ways. Furthermore, since there are abundant different techniques for generating pseudo-random sequences, the specific generation technique must be known in addition to the seed value for successful decryption.</p>
       <p><b>Awkward Dilemma:</b> Unfortunately, earlier versions of Matlab had strange implementations of the ability to change the seed and generators of the rand(<a id="1801"></a>...) and randn(<a id="1804"></a>...) functions.  Rather than struggle with this deprecated implementation, we will take a short tour of the modern implementation for setting up rand(<a id="1802"></a>...).</p>
       <p>There are currently three number generators that consume the current state and generate the next state: 'twister', the default generator, and 'v4' and 'v5uniform' and 'v5normal' the legacy generators.  Each generator can be seeded with an integer value. So we have these implementations:</p>
      <ul>
        <li>to generate the next random state, <code>val = rand(<a id="1803"></a>)</code></li>
        <li>to set the seed value sd with the default generator:  <code>rnd(sd) </code></li>
        <li>to select another generator and seed it:  <code>rnd(sd, &lt;gen&gt;) </code> where <code>&lt;gen&gt;</code> is one of the generators above.</li>
      </ul>
      <p>Listing 6.2 shows the code for encrypting, the corresponding decryption by this technique and two attempts at decryption decrypt - one with the wrong key and one with the wrong generator.</p>
    </div>
    <div class="listing">#listing_06_2#</div>
    <div class="container">
      <p>This is the result when the code is run:</p>
      <p><code>
      original text: The quality of mercy is not strain'd<br>
      encrypted text: Xf% FmHH31$ {\ ove10 }M %~4 ]gB-~,yM<br>
      decrypted text with right values: The quality of mercy is not strain'd (matched)<br>
      decrypted text with bad seed: 2&gt;W 7Cr]lgq %@ ,N(nV ep [/x h4ac1n+a (not matched)<br>
      decrypted text with bad generator: 8v&gt; (zx^G'+ /N |Xb!U KC PcN b6I.6$Q~ (not matched)<br>
    </code></p>
    </div>
  </div>

  <!-- Chapter Summary -->
  <h3>Chapter Summary</h3>
  <div class="container">
    <p>This chapter discussed the nature<a id="1843"></a>, implementation, and behavior of character
    strings. We learned the following:</p>
    <ul>
      <li>Character strings are merely vectors of numbers that are presented
      to the user as single characters</li>
      <li>We can perform on strings the same operations that can be
      performed on vectors; if mathematical operations are
      performed, MATLAB first converts the characters to double
      values</li>
      <li>We can convert between string representations of numbers and the
      numbers themselves using built-in functions</li>
      <li>MATLAB provides functions that convert numbers to text strings
      for presentation in the Command window</li>
      <li>Arrays of strings can be assembled using the char(<a id="1730"></a>...) function</li>
    </ul>
  </div>
<h2>Self Test</h2>
<div class="container">

Use the following questions to check your understanding of the material in this
chapter:
<h3>True or False</h3>
<ol>
<li>Casting changes the value of a piece of data.</li>
<li>The ASCII<a id="1707"></a> code maps individual characters to their internal
numerical representation.</li>
<li>Because the single quote mark ( ' ) delimits strings, you cannot use it
within a string.</li>
<li>If you attempt mathematical operations on a character string,
MATLAB will throw an error.</li>
<li>The function disp(<a id="1772"></a>...) can display multiple values to the
Command window.</li>
<li>The function strcmp(<a id="1819"></a>...) throws an error if the two strings are of
unequal length, unless one of them is a single character.</li>
<li>The switch statement will correctly compare strings of unequal
length in the case tests.</li>
</ol>
<h3>Fill in the Blanks</h3>
<ol>
<li>Numerical values are stored in MATLAB in _______________ for
efficient numerical computation.</li>
<li>Most common __________________, _______________, and many
_________________are represented in ASCII<a id="1708"></a> by the numbers
________________.</li>
<li>The function ____________ casts a string to a vector of the same
length as the string containing the numerical mapping<a id="1752"></a> of
_______________________.</li>
<li>The function fprintf(<a id="1787"></a>...) requires a(n) _____________ that defines
exactly how the resulting string should be formatted and a variable
number of ________________.</li>
<li>Since the _____________ statement tests a logical expression, it
_____________ test strings of unequal length.</li>
<li>A special version of the cast function accepts __________________
strings with different lengths, _____________, and stores them in an
array of characters.</li>
</ol>
<h3>Programming Projects</h3>
<ol>
<li>Solve the following introductory problems on strings.
<ul>
<li>Write a function dayName that consumes a parameter, day ,
containing the numerical value of a day in the month of
September 2008. Your function should return the name of that
day as a string. For example:
dayName( 8 ) should return 'Monday'</li>
<li>You are now given a variable named days, a vector that contains
the numeric values of days in the month of
September 2008. Write a script that will
convert each numeric value in the vector
days into a string named daysOfWeek with
the day names separated by a comma and a space. For example, if days = [8, 9, 10], daysOfWeek should
be 'Monday, Tuesday, Wednesday'
Notice that there is no separator before the first day name or after
the last one.'</li>
<li>
</ul>
<li>Consider the problem the MATLAB system has in parsing the string:<br>
'V=[1 2 3 4; 5,6, 7;8; 9 10]'<br>
Your task is to use strtok to parse this line and construct the array it
represents. You will write a function arrayParse that consumes a
string and returns two variables: a string that is the variable name
and an array.
<ul><li>Tokenize the string first using ' = ' as the delimiter<a id="1768"></a> to isolate the
variable name and the expression to be evaluated. Return the
variable name to the user and save the rest of the line as the
variable str1 for further processing. You may assume that there
are no spaces outside the characters ' [. . .].</li>
<li>Tokenize str1 with ' [ ' and ' ] ' to remove the concatenation<a id="1712"></a>
operators and save the first token<a id="1764"></a> as str2.</li>
<li>Tokenize str2 using ' ; ' as the delimiter<a id="1769"></a>. This will produce 0 or
more strings that represent the rows of the array. Save each in the
variable rowString . You may assume for now that the first row is
the longest one.</li>
<li>Using nested while loops, tokenize each rowString with ' , ' and
' ' as delimiters and use str2num (. . .) to extract the numerical
value of each array entry. Save it as rowEntry .</li>
<li>Concatenate the rowEntry elements horizontally to produce each
row of the array. If the row is too short, pad it with zeros<a id="1822"></a>.</li>
<li>Concatenate each row vertically to produce the resulting array
and return that array to the caller.</li>
<li>Test the function with cases like:<br>
empty<a id="1776"></a>=[]<br>
row=[1 2 3 4]<br>
diag=[0 0 0 1; 0 0 1; 0 1; 1]<br>
</li></ul>

<li>Write a function called DNAcomplement that consumes a set of letters
as a character array that forms a DNA sequence such as 'gattaca' . The
function will produce the complement of the sequence so that a's
become t's , g's become c's , and vice versa. The string 'gattaca'
would therefore become 'ctaatgt' . You may assume that all the
letters in the sequence will be lowercase and that they will all be
either a, t, g, or c .<br>
Note: You may be tempted to use iteration for this problem, but you
don’t need it.</li>
<li>The function rot(s, n) is a simple Caesar cipher encryption<a id="1781"></a>
algorithm<a id="1847"></a> that replaces each English letter in places forward<a id="1783"></a> or
backward along the alphabet in the strings. For example, the result
of rot('Baz!',3) is 'Edc!' . An encrypted string can be deciphered
by simply performing the inverse rotation on it, that is,
rot('Edc!',3), which rotates each English letter in the strings three
places to the left. Numbers, symbols, and non-letters are not
transformed. Implement the following function:<br>
function rotatedText=rot(text,n)<br>
To assist you as you solve this problem, you could write several
functions as local functions in the rot.m file:<br>
isUppercaseLetter(letter), getUppercaseLetter(n),
getLowercaseLetter(n) , and getPosition(letter) .<br>You may also
wish to use the built-in functions isletter (. . .), find (. . .), and
mod (. . .).</li>
<li>You have a big problem. In one of your CS courses, your professor
decides that the only way you will pass the class is if you write a
function to get him out of a mess. All the grades in his class have
been accidentally stored into one long string of characters
containing only the letters A, B, C, D, F, and Y.
<ul>
<li>Your job is to write a function called CrazyGrade that will take in
the string and flip the grades according to the following
specifications:<br>
A becomes F<br>
B becomes D<br>
C remains unchanged<br>
D becomes B<br>
F becomes A<br>
Y becomes W<br>
Your function should take in a string and return an inverted string.
You may assume that the string will only consist of valid letter
grades. For example,<br>
CrazyGrade('BADDAD') should return 'DFBBFB'<br>
CrazyGrade('BAYBAY') should return 'DFWDFW'<br></li>
<li>To make matters worse, he wants you to organize this modified
grade set. Write a function called GradeDist to bunch together all
the similar grades (put all the A's next to each other, B's next to
each other, etc.) Then, calculate and return the professor's grade
distribution. Your function should take in a string and return a
string with all similar grades grouped together, along with an
array containing percentage values from A's all the way to F's. For
example, if there are 15% A's, 16% B's, 33% C's, 16% D's, 16% F's,
and 4% W's, GradeDist should return [15 16 33 16 16 4].</li>
</ol>
</div>
</div>


</body>
</html>

