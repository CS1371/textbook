<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>08_File_I_O</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
<link rel="stylesheet" href="styles/styles.css" />
<script async src="./javascript/index.js"></script>
</head>
<body>
<div>#top_nav#</div>
<div class="nav-obj">#nav_obj#</div>
<div class="content">
  <h1 id="8" align="center">Chapter 8: File Input and<a id="8670"></a> Output</h1>

  <!-- Chapter Objectives -->
  <h1>Chapter Objectives</h1>
  <div class="container">
    <p>Reading and<a id="8671"></a> writing<a id="8660"></a> data<a id="8869"></a> in data<a id="8870"></a> files are fundamental to<a id="8977"></a> the utility of<a id="9133"></a> programming<a id="896<a id="9129"></a>9"></a> languages in general, and<a id="8672"></a> MATLAB<a id="8853"></a> in particular. In addition to<a id="8978"></a> the obvious need to<a id="8979"></a> save and<a id="8673"></a> restore scripts<a id="9254"></a> and<a id="8674"></a> functions<a id="9280"></a> (covered in Chapter 2), here we consider four types<a id="8658"></a> of<a id="9134"></a> activities that read and<a id="8675"></a> write data<a id="8871"></a> files in MATLAB<a id="8854"></a>, each including a discussion of<a id="9135"></a> the circumstances under which they are appropriate:
    <ul>
      <li><b>Saving and<a id="8676"></a> restoring the workspace:</b>The MATLAB<a id="8855"></a> language provides for<a id="9356"></a> the basic ability to<a id="8980"></a> save your workspace (or parts of<a id="9136"></a> your workspace) to<a id="8981"></a> a file and<a id="8677"></a> restore it later for<a id="9357"></a> further processing<a id="8619"></a>.</li>
      <li><b>High-level functions<a id="9281"></a> for<a id="9358"></a> accessing files in specific formats:</b>There are high-level functions<a id="9282"></a> that consume the name of<a id="9137"></a> a file whose contents are in any one of<a id="9138"></a> a number of<a id="9139"></a> popular formats and<a id="8678"></a> produce an internal representation of<a id="9140"></a> the data<a id="8872"></a> from<a id="8558"></a> that file in a form ready for<a id="9359"></a> processing<a id="8620"></a>. Almost all these functions<a id="9283"></a> have an equivalent write function<a id="8530"></a> that will write a new file in the same format<a id="8632"></a> after you have manipulated the data<a id="8873"></a>.</li>
      <li><b>Lower-level file access programs for<a id="9360"></a> general-purpose text<a id="9292"></a> file processing<a id="8621"></a>:</b> we also need to<a id="8982"></a> deal with<a id="8789"></a> lower-level<a id="8828"></a> capabilities for<a id="9361"></a> manipulating text<a id="9293"></a> files that do not contain recognizable structures<a id="8605"></a>.
      </li>
      <li><b>Really low-level binary<a id="8446"></a> file access:</b> we recognize also that at the most fundamental level, file access is about reading<a id="8645"></a> and<a id="8679"></a> writing<a id="8661"></a> arbitrary bit patterns in a file. While the principles remain the same, the practice of<a id="9141"></a> operating<a id="9123"></a> on<a id="8817"></a> binary<a id="8447"></a> files is unusual for<a id="9362"></a> engineers to<a id="8983"></a> require and<a id="8680"></a> will not be further explored in this text<a id="9294"></a>.
      </li>
    </ul></p>
  </div>

  <!-- Introduction -->
  <h1>Introduction</h1>
  <div class="container clearfix">
    <div class="float-sm-right card">
      <img src="..\Images\Fig_8_1.JPG" alt="Figure 8.1" class="fig card-image">
      <p class="figure-name card-title">Figure<a id="9393"></a> 8.1: Paper Tape I/O</p>
    </div>
    <p>This chapter discusses files that contain workspace variables, spreadsheet<a id="8491"></a> data<a id="8874"></a>, and<a id="8681"></a> text<a id="9295"></a>. Subsequent chapters will discuss image<a id="9131"></a> files and<a id="8682"></a> sound<a id="9269"></a> files that have their own unique file access. MATLAB<a id="8856"></a> has the ability to<a id="8984"></a> process the many file formats currently in use. For information on<a id="8818"></a> the other file formats, consult the MATLAB<a id="8857"></a> help<a id="8628"></a> documentation<a id="8475"></a> for<a id="9363"></a> details of<a id="9142"></a> their usage.</p>
    <p>We frequently refer to<a id="8985"></a> the process of<a id="9143"></a> reading<a id="8646"></a> and<a id="8683"></a> writing<a id="8662"></a> data<a id="8875"></a> files as Input/Output<a id="8669"></a> (I/O). We have already seen and<a id="8684"></a> used examples<a id="8618"></a> of<a id="9144"></a> file I/O to<a id="8986"></a> store and<a id="8685"></a> retrieve data<a id="8876"></a> and<a id="8686"></a> programs. Your script and<a id="8687"></a> function<a id="8531"></a> files are stored in your current directory and<a id="8688"></a> could be invoked from<a id="8559"></a> there by name from<a id="8560"></a> the Command<a id="9390"></a> window. To understand fully the concept of<a id="9145"></a> serial I/O, consider Figure<a id="9394"></a> 8.1. This figure takes us back to<a id="8987"></a> the early days of<a id="9146"></a> computing when paper tape was the only available storage medium. After the leader containing only the small holes used to<a id="8988"></a> move the tape forward<a id="8528"></a>, each row of<a id="9147"></a> the paper tape represents the value<a id="9334"></a> of<a id="9148"></a> one character<a id="8832"></a> as 8 bits of<a id="9149"></a> data<a id="8877"></a>.  The 8 bits represent the ASCII<a id="8404"></a> value<a id="9335"></a> in binary<a id="8448"></a> form with<a id="8790"></a> a hole punched where a bit is set. These tapes were prepared on<a id="8819"></a> a tape punching machine, and<a id="8689"></a> were fed through a tape reader to<a id="8989"></a> recover all the characters. This illustrates the meaning of<a id="9150"></a> "serial" processing<a id="8622"></a> - in this case<a id="8450"></a>, the data<a id="8878"></a> are actually stored sequentially on<a id="8820"></a> the paper tape. In principle, while<a id="9354"></a> the storage techniques have evolved beyond recognition and<a id="8690"></a> continue<a id="8466"></a> to<a id="8990"></a> evolve, to<a id="8991"></a> a user<a id="8971"></a>'s program, any computer file system saves and<a id="8691"></a> retrieves data<a id="8879"></a> as a sequential stream of<a id="9151"></a> characters.</p>
  </div>

  <div class="chp-section" data-sect-num="1" data-sect-name="Concept: Serial Input and Output (I/O)">
    <!-- Serial Input and Output -->
    <h2 id="8_1">8.1 Concept: Serial Input and<a id="8692"></a> Output (I/O)</h2>
    <div class="container clearfix">
      <div class="float-sm-right card style-points">
        <p class="card-title">Style Points 8.1</p>
        <p class="card-text">
          In a practical sense, saving workspace data<a id="8880"></a> is very rarely an
          appropriate approach to<a id="8992"></a> saving work because it saves the
          results but not the code that generated the results. It is
          almost always better to<a id="8993"></a> save the scripts<a id="9255"></a> and<a id="8693"></a> raw data<a id="8881"></a> that
          created the workspace. For example<a id="9259"></a>, this is a good idea
          when you have a lengthy computation (perhaps one run
          overnight) to<a id="8994"></a> prepare data<a id="8882"></a> for<a id="9364"></a> a display. You could split that
          script into two halves. The first half would do the overnight
          calculation and<a id="8694"></a> save the workspace. The second part can
          then read the workspace quickly, and<a id="8695"></a> you can develop
          sophisticated ways to<a id="8995"></a> display the data<a id="8883"></a> without having to<a id="8996"></a>
          re-run the lengthy calculations.
        </p>
      </div>
      <p>Although the media used to<a id="8997"></a> store data<a id="8884"></a> have changed, the fundamental operations<a id="9124"></a> needed to<a id="8998"></a> read and<a id="8696"></a> write sequential files have not.  In order to<a id="8999"></a> create a paper tape from<a id="8561"></a> data<a id="8885"></a> in the computer, access to<a id="9000"></a> the tape punch was prepared, the leader and<a id="8697"></a> then the characters then a trailer are sent one item at a time to<a id="9001"></a> the punch.  When all the items had been sent, access to<a id="9002"></a> the punch was closed.  To read a paper tape, its leader was loaded into the tape reader and<a id="8698"></a> the reader motion started. As each character<a id="8833"></a> passed the read head, it was received and<a id="8699"></a> stored in the computer until no characters were left. The modern world of<a id="9152"></a> serial processing<a id="8623"></a> follows exactly the same pattern.</p>
      <p>When a program opens a file by name for<a id="9365"></a> reading<a id="8647"></a>, it continually requests data<a id="8886"></a> from<a id="8562"></a> the file data<a id="8887"></a> stream until the end<a id="8480"></a> of<a id="9153"></a> the file is reached. As the data<a id="8888"></a> are received, the program must identify any special characters that define specific data<a id="8889"></a> characteristics and<a id="8700"></a> use them to<a id="9003"></a> format<a id="8633"></a> the data<a id="8890"></a> to<a id="9004"></a> reconstruct the organization of<a id="9154"></a> the data<a id="8891"></a> stored in the file. Similarly, when writing<a id="8663"></a> data<a id="8892"></a> to<a id="9005"></a> a file, the program must serialize the data<a id="8893"></a>, and<a id="8701"></a> include special character<a id="8834"></a> to<a id="9006"></a> preserve the organization of<a id="9155"></a> the data<a id="8894"></a>.  As we consider workspace I/O and<a id="8702"></a> high-level I/O, most of<a id="9156"></a> these operations<a id="9125"></a> will be invisible to<a id="9007"></a> the user<a id="8972"></a> inside the built-in functions<a id="9284"></a>.  However, when discussing text<a id="9296"></a> files, we will need to<a id="9008"></a> implement all of<a id="9157"></a> these concepts in our code.</p>
    </div>
  </div>

  <div class="chp-section" data-sect-num="2" data-sect-name="Workspace I/O">
    <!-- Workspace I/O -->
    <h2 id="8_2">8.2 Workspace<a id="9397"></a> I/O</h2>
    <div class="container">
      <p>The MATLAB<a id="8858"></a> language defines the tools to<a id="9009"></a> save your complete workspace to<a id="9010"></a> a file with<a id="8791"></a> the <code>save</code> command and<a id="8703"></a> reload it with<a id="8792"></a> the <code>load</code> command. If you provide a file name with<a id="8793"></a> the <code>save</code> command, a file of<a id="9158"></a> that name will be written into your current directory in such a form that a subsequent <code>load</code> command with<a id="8794"></a> that file name will restore the saved workspace. By convention, these files will have a <code>".mat"</code> extension. If you do not provide a file name, the workspace is saved as <code>matlab.mat</code>.  If you are using MATLAB<a id="8859"></a>, you can also identify specific variables that you want to<a id="9011"></a> save — either by listing them explicitly or by providing logical<a id="8443"></a> expressions to<a id="9012"></a> indicate the variable<a id="9344"></a> names<a id="9349"></a>. For example<a id="9260"></a>:<br>
      <code>>> save mydata.mat a b c* </code><br>
      would save the variables  <code>a</code> and<a id="8704"></a>  <code>b</code> and<a id="8705"></a> any variable<a id="9345"></a> beginning with<a id="8795"></a> the letter  <code>c</code>.</p>
      <p>To recover the data<a id="8895"></a>:<br>
      <code>>> clear<a id="8461"></a>  % if necessary to<a id="9013"></a> remove all existing variables from<a id="8563"></a> the workspace<br>
      >> load mydata.mat</code></p>
      <p>For more details, consult the MATLAB<a id="8860"></a> help<a id="8629"></a> documentation<a id="8476"></a>.</p>
    </div>
  </div>

  <div class="chp-section" data-sect-num="3" data-sect-name="High-Level I/O Functions">
    <!-- High Level I/O Functions -->
    <h2 id="8_3">8.3 High-Level I/O Functions</h2>
    <div class="container">
      <p>We turn to<a id="9014"></a> a more specific case<a id="8451"></a> of<a id="9159"></a> file I/O in which we expect to<a id="9015"></a> load a complete file from<a id="8564"></a> external sources with<a id="8796"></a> one function<a id="8532"></a> call, thereby hiding from<a id="8565"></a> the user<a id="8973"></a> all the details of<a id="9160"></a> file access. We might wish to<a id="9016"></a> process that data<a id="8896"></a>, and<a id="8706"></a> perhaps save the modified data<a id="8897"></a> back to<a id="9017"></a> the file system with<a id="8797"></a> one function<a id="8533"></a> call.  When  you  try  to<a id="9018"></a> process  data<a id="8898"></a>  from<a id="8566"></a>  some  unknown source, it is difficult to<a id="9019"></a> write code to<a id="9020"></a> process the data<a id="8899"></a> without some initial exploration   of<a id="9161"></a>   the   nature<a id="8642"></a>   and<a id="8707"></a> organization of<a id="9162"></a> that data<a id="8900"></a>. So a good habit is to<a id="9021"></a> explore the data<a id="8901"></a> in a file by whatever means you have available and<a id="8708"></a> then decide how to<a id="9022"></a> process the data<a id="8902"></a> according to<a id="9023"></a> your observations. Most programming<a id="897<a id="9130"></a>0"></a> languages require the programmer to<a id="9024"></a> write detailed programs to<a id="9025"></a> read and<a id="8709"></a> write files, especially those produced by other application programs or data<a id="8903"></a> acquisition packages. Fortunately for<a id="9366"></a> MATLAB<a id="8861"></a> programmers, much of<a id="9163"></a> this messy work has been built into special file readers and<a id="8710"></a> writers. Table 8.1 identifies the type of<a id="9164"></a> data<a id="8904"></a>, the name of<a id="9165"></a> the appropriate reader and<a id="8711"></a> writer, and<a id="8712"></a> the internal form in which MATLAB<a id="8862"></a> returns the data<a id="8905"></a>.</p>
      <table class="table">
        <caption>Table 8.1: File Types</caption>
        <thead>
          <tr>
            <th>File</th><th>Content</th><th>Reader</th><th>Writer</th><th>Data Format</th><th>Extensions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Binary</td><td>Anything</td><td><code>fread(...)</code></td><td><code>fwrite(...)</code></td><td>Any</td><td>various</td>
          </tr>
          <tr>
            <td>Text</td><td>ASCII<a id="8405"></a> Codes</td><td>See 8.4</td><td>See 8.4</td><td>Text Lines</td><td><code>.txt</code> etc</td>
          </tr>
          <tr>
            <td>CSV</td><td>Comma Separated Values</td><td><code>readcell(<a id="8592"></a>...)formerly xlsread(<a id="8612"></a>...)  or csvread(<a id="8468"></a>...)</code></td><td><code>writecell(<a id="8607"></a>...) formerly xlswrite(<a id="8615"></a>...) or csvwrite(<a id="8469"></a>...)</code><td><code>double</code> array<a id="8410"></a></td><td><code>.csv</code></td>
          </tr>
          <tr>
            <td>Delimited</td><td>Numbers separated  by delimiters</td><td><code>readcell(<a id="8593"></a>...) formerly xlsread(<a id="8613"></a>...)</code></td><td><code>writecell(<a id="8608"></a>...) formerly xlswrite(<a id="8616"></a>...)</code></td><td><code>double</code> array<a id="8411"></a></td><td><code>.txt</code> etc</td>
          </tr>
          <tr>
            <td>Excel<a id="8515"></a></td><td>Spread Sheet</td><td><code>readcell(<a id="8594"></a>...)formerly xlsread(<a id="8614"></a>...)</code></td><td><code>writecell(<a id="8609"></a>...) formerly xlswrite(<a id="8617"></a>...)</code><td><code>cell<a id="8427"></a></code> array<a id="8412"></a></td><td><code>.xls, .xlsx</code></td>
          </tr>
          <tr>
            <td>Image</td><td>Color image<a id="9132"></a></td><td><code>imread(<a id="8589"></a>...)</code></td><td><code>imwrite(<a id="8590"></a>...)</code></td><td><code>uint8</code> array<a id="8413"></a></td><td><code>.jpg </code>etc</td>
          </tr>
          <tr>
            <td>Audio</td><td>Multichannel Sound</td><td><code>audioread(<a id="8445"></a>...)</code></td><td><code>audiowrite(...)</code><td><code>double</code> vector</td><td><code>.wav<a id="9353"></a>, .mp3, .avi</code> etc</td>
          </tr>
          <tr>
            <td>Workspace<a id="9398"></a></td><td>variable<a id="9346"></a> values</td><td><code>load ...</code></td><td><code>save ...</code><td>anything</td><td><code>.mat</code></td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Exploration">
      <!-- Exploration -->
      <h3 id="8_3_1">8.3.1	Exploration</h3>
      <div class="container">
        <p>The types<a id="8659"></a> of<a id="9166"></a> data<a id="8906"></a> of<a id="9167"></a> immediate interest are text<a id="9297"></a> files and<a id="8713"></a> spreadsheets<a id="9270"></a>. In Table 8.1 notice that the delimited<a id="9329"></a> text<a id="9298"></a> files are presumed to<a id="9026"></a> contain numerical<a id="9115"></a> values, whereas the spreadsheet<a id="8492"></a> data<a id="8907"></a> may be either numerical<a id="9116"></a> data<a id="8908"></a> stored as doubles or string data<a id="8909"></a> stored in cell<a id="<a id="8453"></a>8428"></a> arrays. Typically, text<a id="9299"></a> files are delimited<a id="9330"></a> by a special character<a id="8835"></a> (comma, tab, or anything else<a id="8477"></a>) to<a id="9027"></a> designate the column divider and<a id="8714"></a> a new-line character<a id="8836"></a> to<a id="9028"></a> designate the rows. Once the data<a id="8910"></a> are imported, all of<a id="9168"></a> our normal array<a id="8414"></a> and<a id="8715"></a> matrix<a id="8975"></a> processing<a id="8624"></a> tools can be applied. The exception to<a id="9029"></a> this rule is the plain text<a id="9300"></a> reader that must be provided with<a id="8798"></a> a format<a id="8634"></a> specifier to<a id="9030"></a> define the data<a id="8911"></a>, and<a id="8716"></a> the names<a id="9350"></a> of<a id="9169"></a> the variables in which the data<a id="8912"></a> are to<a id="9031"></a> be stored.  So when you are approached with<a id="8799"></a> a file, the file extension (the part of<a id="9170"></a> the file name after the dot) gives you a significant clue to<a id="9032"></a> the nature<a id="8643"></a> of<a id="9171"></a> the data<a id="8913"></a>. For example<a id="9261"></a>, if it is the output from<a id="8567"></a> a spreadsheet<a id="8493"></a>, you should open the data<a id="8914"></a> in that spreadsheet<a id="8494"></a> program to<a id="9033"></a> explore its contents and<a id="8717"></a> organization. [Typically, spreadsheet<a id="8495"></a> data<a id="8915"></a> will not open well in a plain text<a id="9301"></a> editor.] If you do not recognize the file extension as coming from<a id="8568"></a> a spreadsheet<a id="8496"></a>, try opening<a id="8830"></a> the file in a plain text<a id="9302"></a> editor such as that used for<a id="9367"></a> your scripts<a id="9256"></a> and<a id="8718"></a> functions<a id="9285"></a> and<a id="8719"></a> see if the data<a id="8916"></a> are legible. You should be able to<a id="9034"></a> discern the field<a id="8524"></a> delimiters and<a id="8720"></a> the content of<a id="9172"></a> each line if the file contains plain text<a id="9303"></a>.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Spreadsheets">
      <!-- Spreadsheets -->
      <h3 id="8_3_2">8.3.2 Spreadsheets</h3>
      <div class="container">
        <p>Excel<a id="8516"></a> is a Microsoft product that implements spreadsheets<a id="9271"></a>. Spreadsheets are rectangular arrays containing labeled rows and<a id="8721"></a> columns of<a id="9173"></a> cells. The data<a id="8917"></a> in the cells may be numbers<a id="8976"></a>, strings, or formulae that combine the data<a id="8918"></a> values in other cells. Because of<a id="9174"></a> this computational capability, spreadsheets<a id="9272"></a> can be used to<a id="9035"></a> solve many problems, and<a id="8722"></a> most offer flexible plotting packages for<a id="9368"></a> presenting the results in colorful charts. There are occasions, however, when we need to<a id="9036"></a> apply the power of<a id="9175"></a> the MATLAB<a id="8863"></a> language to<a id="9037"></a> the data<a id="8919"></a> in a spreadsheet<a id="8497"></a>.  MATLAB<a id="8864"></a> provides a reader for<a id="9369"></a> Excel<a id="8517"></a> spreadsheets<a id="9273"></a> that gives you a significant amount of<a id="9176"></a> flexibility in retrieving the data<a id="8920"></a> from<a id="8569"></a> the spreadsheet<a id="8498"></a>. Consider the typical set of<a id="9177"></a> data<a id="8921"></a> in a spreadsheet<a id="8499"></a> named grades.xls shown in Table 8.2.</p>
        <table class="table table-bordered">
          <caption>Table 8.2: Sample Spreadsheet Data</caption>
          <thead>
            <tr>
              <th>Name</th><th>Age</th><th>Grade</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Joe</td><td>22</td><td>83</td>
            </tr>
            <tr>
              <td>Sally</td><td>98</td><td>99</td>
            </tr>
            <tr>
              <td>Charlie</td><td>21</td><td>56</td>
            </tr>
            <tr>
              <td>Mary</td><td>23</td><td>89</td>
            </tr>
            <tr>
              <td>Ann</td><td>19</td><td>51</td>
            </tr>
          </tbody>
        </table>
        <p>The goal of<a id="9178"></a> your spreadsheet<a id="8500"></a> reader is to<a id="9038"></a> separate the text<a id="9304"></a> and<a id="8723"></a> numerical<a id="9117"></a> portions of<a id="9179"></a> the spreadsheet<a id="8501"></a>. The parameter consumed by your spreadsheet<a id="8502"></a> reader is the name of<a id="9180"></a> the file; you can ask for<a id="9370"></a> up to<a id="9039"></a> three return variables: the first will hold<a id="8586"></a> all the numerical<a id="9118"></a> values in an array<a id="8415"></a> of<a id="9181"></a> doubles; the second will hold<a id="8587"></a> all the text<a id="9305"></a> data<a id="8922"></a> in cell<a id="<a id="8454"></a>8429"></a> arrays; and<a id="8724"></a> the third, if you request it, will hold<a id="8588"></a> both string and<a id="8725"></a> numerical<a id="9119"></a> data<a id="8923"></a> in cell<a id="<a id="8455"></a>8430"></a> arrays (try Exercise 8.1).</p>
        <div class="exercise">#exercise_8_1#</div>
        <p><code>readcell(<a id="8595"></a>...)</code> outputs the contents of<a id="9182"></a> the file as a cell<a id="8431"></a> array<a id="8416"></a>. In the cell<a id="8432"></a> array<a id="8417"></a>, each spot is a cell<a id="8433"></a> containing the information from<a id="8570"></a> the spreadsheet<a id="8503"></a>, with<a id="8800"></a> a double inside if there was a number, char inside if there was text<a id="9306"></a>, and<a id="8726"></a> missing if it was an empty<a id="8478"></a> cell<a id="8434"></a>; <code>missing</code> is its own data<a id="8924"></a> type.</p>
        <p>Frequently, after processing<a id="8625"></a> data<a id="8925"></a>, you need to<a id="9040"></a> write the results back to<a id="9041"></a> a spreadsheet<a id="8504"></a>. Excel<a id="8518"></a> spreadsheets<a id="9274"></a> can be written using:<br>
        <code>writecell(<a id="8610"></a>&lt;data<a id="8926"></a>&gt;, &lt;filename&gt;)</code><br>
        where <code>&lt;data<a id="8927"></a>&gt;</code> is the data<a id="8928"></a> source (a cell<a id="8435"></a> array<a id="8418"></a>) and<a id="8727"></a> <code>&lt;filename&gt;</code> is the name of<a id="9183"></a> the file.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Delimited Text Files">
      <h3 id="8_3_3">8.3.3	Delimited Text Files</h3>
      <div class="container">
        <p>If information is not available specifically in spreadsheet<a id="8505"></a> form, it can frequently be presented in text<a id="9307"></a> file form. If the data<a id="8929"></a> in a text<a id="9308"></a> file are numerical<a id="9120"></a> values only and<a id="8728"></a> are organized in a reasonable format<a id="8635"></a>, you can read the file directly into an array<a id="8419"></a>. It is necessary that the data<a id="8930"></a> values are separated by commas, spaces, or tab characters [See 6.3.2 about delimiters]. Rows in the data<a id="8931"></a> are separated as expected by a new-line character<a id="8837"></a> combination [See 8.4]. These values might be saved in a file named, for<a id="9371"></a> example<a id="9262"></a>, <code>nums.txt</code>.</p>
        <table class="table table-borderless">
          <caption>Table 8.3: Delimited Data</caption>
            <tbody>
              <tr><td>19,78,42</td></tr>
              <tr><td>22,83,100</td></tr>
              <tr><td>98,99,34</td></tr>
              <tr><td>21,56,12</td></tr>
              <tr><td>23,89</td></tr>
              <tr><td>19,51</td></tr>
            </tbody>
        </table>
        <p>If the text<a id="9309"></a> file contains only representation of<a id="9184"></a> data<a id="8932"></a> separated by delimiters, it can be read using this:<br>
        <code>arr = readcell(<a id="8596"></a>&lt;file_name&gt;, &lt;Name&gt;, &lt;Value&gt;)</code>,<br>
        where the <code>filename</code> parameter is the name of<a id="9185"></a> the file. The <code>readcell(<a id="8597"></a>...)</code> function<a id="8534"></a> produces a cell<a id="8436"></a> array<a id="8420"></a> containing the data<a id="8933"></a> values with<a id="8801"></a> default delimiter<a id="8470"></a> <code>','</code>. If you use a delimiter<a id="8471"></a> other than a comma, you can specify <code>'Delimiter'</code> as the second input and<a id="8729"></a> <code>&lt;delimiter<a id="8472"></a>_value<a id="9336"></a>&gt;</code>, for<a id="9372"></a> example<a id="9263"></a> <code>':'</code> as the third input. The second and<a id="8730"></a> third inputs are optional.</p>
        <p>Try reading<a id="8648"></a> delimited<a id="9331"></a> files in Exercise 8.2 where Table 8.3 shows the content of<a id="9186"></a> the file <code>nums.txt</code>.  Notice that the array<a id="84<a id="8444"></a>21"></a> elements<a id="9352"></a> where data<a id="8934"></a> are not supplied are filled with<a id="8802"></a> class <code>missing</code>.</p>
        <div class="exercise">#exercise_8_2#</div>
        <p>Delimited data<a id="8935"></a> files can be written using:<br>
        <code>writecell(<a id="8611"></a>&lt;data<a id="8936"></a>&gt;, &lt;filename&gt;, &lt;Name&gt;, &lt;Value&gt;)</code><br>
        where <code>&lt;data<a id="8937"></a>&gt;</code> is the data<a id="8938"></a> source (a cell<a id="8437"></a> array<a id="8422"></a>) and<a id="8731"></a> <code>&lt;filename&gt;</code> is the name of<a id="9187"></a> the file. The third and<a id="8732"></a> fourth inputs can specify the delimiting correct, using <code>'Delimiter'</code> as the third input and<a id="8733"></a> <code>&lt;delimiter<a id="8473"></a>_value<a id="9337"></a>&gt;</code>, for<a id="9373"></a> example<a id="9264"></a> <code>':'</code> as the fourth input. If  the  delimiting  character<a id="8838"></a>  is  not  specified,  it  is  presumed  to<a id="9042"></a>  be  a comma.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="4" data-sect-name="Lower-Level File I/O">
    <!-- Lower Level File I/O -->
    <h2 id="8_4">8.4 Lower-Level File I/O</h2>
    <div class="container">
      <p>We will assume here that the file in which we are interested contains text<a id="9310"></a> data<a id="8939"></a> in the form of<a id="9188"></a> ASCII<a id="8406"></a> character<a id="8839"></a> codes.  Files for<a id="9374"></a> which this is not the case<a id="8452"></a> have to<a id="9043"></a> be treated as binary<a id="8449"></a> files which we will not discuss further. The MATLAB<a id="8865"></a> language provides a set of<a id="9189"></a> lower-level<a id="8829"></a> I/O functions<a id="9286"></a> that permit general-purpose text<a id="9311"></a> file reading<a id="8649"></a> and<a id="8734"></a> writing<a id="8664"></a>. The following is a partial discussion of<a id="9190"></a> these functions<a id="9287"></a> that is sufficient for<a id="9375"></a> most text<a id="9312"></a> file processing<a id="8626"></a> needs. Recall in the discussion of<a id="9191"></a> the paper tape in 8.1 that once the tape has been loaded into the tape reader and<a id="8735"></a> begins to<a id="9044"></a> move (the file is opened), the individual characters are delivered to<a id="9045"></a> the calling program until it reached the end<a id="8481"></a> when the tape reader is stopped by the calling program (the file is closed). Today, text<a id="9313"></a> files are delivered on<a id="8821"></a> many kinds of<a id="9192"></a> media, but to<a id="9046"></a> the calling program, the same three features are required:
      <ol>
        <li>the file must be successfully opened,</li>
        <li>data<a id="8940"></a> characters must be received by the calling program, and<a id="8736"></a></li>
        <li>the files should be closed.</li>
      </ol></p>
      <p>Although MATLAB<a id="8866"></a> may close<a id="8462"></a> the file automatically when your program exits, it is good practice to<a id="9047"></a> actually close<a id="8463"></a> the file yourself when you have finished reading<a id="8650"></a> it.</p>
      <p><b>The End-Of-File (EOF) Character:</b> The following question also arises: in the paper tape days, how do you know when you have reached the end<a id="8482"></a> of<a id="9193"></a> the data<a id="8941"></a>?  If you let the tape read until you reach the end<a id="8483"></a> of<a id="9194"></a> the physical<a id="8490"></a> tape, no fresh data<a id="8942"></a> will be passing<a id="9128"></a> the read heads and<a id="8737"></a> some kind of<a id="9195"></a> error condition will arise.  By convention, it was decided that a specific non-printable character<a id="8840"></a> called 'EOF' with<a id="8803"></a> ASCII<a id="8407"></a> value<a id="9338"></a> 26 would be written at the end<a id="8484"></a> of<a id="9196"></a> the data<a id="8943"></a> on<a id="8822"></a> the tape. When that character<a id="8841"></a> was read from<a id="8571"></a> the tape, the calling program is informed that the end<a id="8485"></a> of<a id="9197"></a> the tape has been reached and<a id="8738"></a> the tape can be stopped (the file closed). While the modern era has many different ways of<a id="9198"></a> delivering data<a id="8944"></a> from<a id="8572"></a> a file to<a id="9048"></a> your program, the need is still present to<a id="9049"></a> identify when there are no more data<a id="8945"></a> to<a id="9050"></a> process, and<a id="8739"></a> the EOF character<a id="8842"></a> is still used to<a id="9051"></a> terminate file reading<a id="8651"></a>.</p>
      <p><b>New Line Markers:</b> There is another need for<a id="9376"></a> special markers in a text<a id="9314"></a> file inherited again from<a id="8573"></a> the paper tape era.  The tape reader was at that time directly connected to<a id="9052"></a> a primitive typewriter style printer of<a id="9199"></a> which the classic example<a id="9265"></a> was called the ASR-33. Each character<a id="8843"></a> read from<a id="8574"></a> the tape was typed onto the paper and<a id="8740"></a> the carriage holding the print mechanism moved one place to<a id="9053"></a> the right waiting for<a id="9377"></a> the next character<a id="8844"></a>. When the carriage reached the 80th character<a id="8845"></a> position, it could no longer advance to<a id="9054"></a> the right.  If nothing special happened, all the remaining characters on<a id="8823"></a> the tape were printed at the same location - not really what you want. In order to<a id="9055"></a> continue<a id="8467"></a> printing legibly, two different actions were required, triggered by reading<a id="8652"></a> two different non-printable characters:
      <ul>
        <li>return the carriage to<a id="9056"></a> the first column by driving it all the way to<a id="9057"></a> the left, (CR, ASCII<a id="8408"></a> 13), and<a id="8741"></a></li>
        <li>move the paper up so that the next character<a id="8846"></a> will type below the previous line (LF, ASCII<a id="8409"></a> 10).</li>
      </ul></p>
      <p>In the modern era, of<a id="9200"></a> course, there may be no printing carriage to<a id="9058"></a> move to<a id="9059"></a> the left or paper to<a id="9060"></a> move up, but initially, the CR/LF sequence was still required to<a id="9061"></a> begin the next line of<a id="9201"></a> text<a id="9315"></a>.  However, at some point, somebody said to<a id="9062"></a> themselves that it was wasting storage space to<a id="9063"></a> use two characters where only one action is required. Some people decided to<a id="9064"></a> leave off the CR, and<a id="8742"></a> some decided to<a id="9065"></a> leave off the LF, and<a id="8743"></a> so we are now blessed with<a id="8804"></a> three different possible end<a id="8486"></a>-of<a id="9202"></a>-line indicators: CR, LF, or CR/LF.  This dilemma is usually hidden from<a id="8575"></a> the user<a id="8974"></a>, but can occasionally cause issues when moving text<a id="9316"></a> files from<a id="8576"></a> an Apple computer to<a id="9066"></a> a Windows machine or a Unix machine.</p>
      <p>In general, when reading<a id="8653"></a> a file, the file must be opened to<a id="9067"></a> return a value<a id="9339"></a> to<a id="9068"></a> be used by subsequent functions<a id="9288"></a> to<a id="9069"></a> identify its data<a id="8946"></a> stream. We usually refer to<a id="9070"></a> this identifier as the “file handle.” After the file contents have been manipulated, the file must be closed to<a id="9071"></a> complete the activity.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Opening and Closing Files">
      <!-- Opening and Closing Files -->
      <h3 id="8_4_1">8.4.1	Opening and<a id="8744"></a> Closing Files</h3>
      <div class="container">
        <p>To open a file for<a id="9378"></a> reading<a id="8654"></a> or writing<a id="8665"></a>, use <code>fh = fopen(<a id="8525"></a> &lt;file_name&gt;, &lt;purpose&gt;)</code>
        where <code>fh</code> is a file handle used in subsequent function<a id="8535"></a> calls to<a id="9072"></a> identify this particular input stream, <code>&lt;file_name&gt;</code> is the name of<a id="9203"></a> the file, and<a id="8745"></a> <code>&lt;purpose&gt;</code> is a string specifying the purpose for<a id="9379"></a> opening<a id="8831"></a> the file. The most common purposes are <code>'r'</code> to<a id="9073"></a> read the file, <code>'w'</code> to<a id="9074"></a> write it, or <code>'a'</code> to<a id="9075"></a> append to<a id="9076"></a> an existing file. See the help<a id="8630"></a> files for<a id="9380"></a> more complex situations. If the purpose is <code>'r'</code>, the file must already exist; if <code>'w'</code> and<a id="8746"></a> the file already exists, it will be overwritten; if <code>'a'</code> and<a id="8747"></a> the file already exists, the new data<a id="8947"></a> will be appended to<a id="9077"></a> the end<a id="8487"></a>. The consequence of<a id="9204"></a> failure to<a id="9078"></a> open the file is indicated by returning<a id="8600"></a> a file handle of<a id="9205"></a> –1 rather than a positive number. It is good practice to<a id="9079"></a> check the file handle upon return from<a id="8577"></a> a file open command.</p>
        <p>To close<a id="8464"></a> the file, call <code>fclose(<a id="8519"></a> fh )</code>.
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Reading Text Files">
      <!-- Reading Text Files -->
      <h3 id="8_4_2">8.4.2	Reading Text Files</h3>
      <div class="container">
        <p>It is possible, but rarely appropriate, to<a id="9080"></a> read one character<a id="8847"></a> at a time from<a id="8578"></a> a text<a id="9317"></a> file using <code>fread(...)</code> or <code>fwrite(...)</code> and<a id="8748"></a> we will not consider that here.  Rather, we will make use of<a id="9206"></a> the presence of<a id="9207"></a> the New Line Markers (whatever they are) to<a id="9081"></a> read and<a id="8749"></a> write whole lines or more from<a id="8579"></a> the file.</p>
        <p>To read a file, three levels of<a id="9208"></a> support are provided: reading<a id="8655"></a> whole lines with<a id="8805"></a> or without the new-line character<a id="8848"></a>, parsing into tokens with<a id="8806"></a> delimiters, or parsing into cell<a id="<a id="8456"></a>8438"></a> arrays using a format<a id="8636"></a> string:
        <ul>
          <li>To read a whole line including the new-line character<a id="8849"></a>, use <code>str = fgets(<a id="8522"></a> fh )</code> that will return each line as a string until the end<a id="8488"></a> of<a id="9209"></a> the file, when the value<a id="9340"></a> –1 is returned instead of<a id="9210"></a> a string. To leave out each new-line character<a id="8850"></a>, use <code>fgetl(<a id="8520"></a>...)</code> instead (the last character<a id="8851"></a> is a lowercase L).</li>
          <li>To parse each line into tokens (elementary text<a id="9318"></a> strings) separated by white space delimiters, use a combination of<a id="9211"></a> <code>fgetl(<a id="8521"></a>...)</code> and<a id="8750"></a> the tokenizer function<a id="8536"></a> <code>[&lt;tk&gt;, &lt;rest&gt;] = strtok(<a id="8603"></a> &lt;ln&gt; )</code>; where <code>&lt;tk&gt;</code> is a string token<a id="8458"></a>, <code>&lt;rest&gt;</code> is the remainder of<a id="9212"></a> the line, and<a id="8751"></a> <code>&lt;ln&gt;</code> is a string to<a id="9082"></a> be parsed into tokens.</li>
          <li>you could try to<a id="9083"></a> parse a line according to<a id="9084"></a> a specific format<a id="8637"></a> string into a cell<a id="8439"></a> array<a id="8423"></a> by using
          <code>ca = textscan(<a id="8606"></a> fh, &lt;format<a id="8638"></a>&gt; );</code>
          where <code>ca</code> is the resulting cell<a id="8440"></a> array<a id="8424"></a>, <code>fh</code> is the file handle, and<a id="8752"></a> <code>&lt;format<a id="8639"></a>&gt;</code> is a format<a id="8640"></a> control<a id="8457"></a> string such as we used for<a id="9381"></a> <code>sscanf(<a id="8602"></a>...)</code> in para 6.3.2.</li>
        </ul>
        <p>When the read function<a id="8537"></a> finds the EOF character<a id="8852"></a>, instead of<a id="9213"></a> returning<a id="8601"></a> a string, it returns <code>-1</code>. This is actually the reason to<a id="9085"></a> exit a while<a id="9355"></a> loop processing<a id="8627"></a> the text<a id="9319"></a> which can conveniently be accomplished with<a id="8807"></a> the <code>ischar(<a id="8591"></a>...)</code> function<a id="8538"></a>.</p>
        <p>To illustrate the use of<a id="9214"></a> these functions<a id="9289"></a> for<a id="9382"></a> reading<a id="8656"></a> a text<a id="9320"></a> file, the script in Listing 8.1 shows a script that will list any text<a id="9321"></a> file in the Command<a id="9391"></a> window.</p>
        <div class="listing">#listing_08_1#</div>
        <p>As an example<a id="9266"></a> of<a id="9215"></a> the use of<a id="9216"></a> a strtok(<a id="8604"></a>...), consider the code shown in Listing 8.2, which performs the same function<a id="8539"></a> as Listing 8.1 but uses tokens.</p>
        <div class="listing">#listing_08_2#</div>
        <p>Run the scripts<a id="9257"></a> in Listings 8.1 and<a id="8753"></a> 8.2. This will show the difference in output results between the conventional listing script and<a id="8754"></a> the tokenizing lister. With the tokenizer, we see each individual token<a id="8459"></a> (really, each word in a normal text<a id="9322"></a> file) separately listed.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Writing Text Files">
      <!-- Writing Text Files -->
      <h3 id="8_4_3">8.4.3	Writing Text Files</h3>
      <div class="container">
        <p>Once a file has been opened for<a id="9383"></a> writing<a id="8666"></a>, the <code>fprintf(<a id="8529"></a>...)</code>function<a id="8540"></a> can be used to<a id="9086"></a> write to<a id="9087"></a> the file by including its file handle as the first parameter. For example<a id="9267"></a>, Listing 8.3 is a minor alteration to<a id="9088"></a> Listing 8.1, copying a text<a id="9323"></a> file instead of<a id="9217"></a> listing it in the Command<a id="9392"></a> window.</p>
        <div class="listing">#listing_08_3#</div>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="5" data-sect-name="Engineering Example - Spreadsheet Data">
    <!-- Engineering Example -->
    <h2 id="8_5">8.5	Engineering Example &mdash; Spreadsheet Data</h2>
    <div class="container">
      <div class="float-sm-right card">
        <img src="..\Images\Fig_8_2.JPG" alt="Figure 8.2" class="fig card-image">
        <p class="figure-name card-title">Figure<a id="9395"></a> 8.2: Spreadsheet Data</p>
      </div>
      <p>Frequently, engineering<a id="8489"></a> data<a id="8948"></a> are provided in spreadsheets<a id="9275"></a>. Here we will adapt the structure<a id="9277"></a> assembly problem from<a id="8580"></a> Chapter 7. The script for<a id="9384"></a> that solution created the data<a id="8949"></a> using a constructor function<a id="8541"></a>. Consider the situation in which the data<a id="8950"></a> are provided in a spreadsheet<a id="8506"></a> such as that shown in Figure<a id="9396"></a> 8.2. To make it more interesting, we imagine that the spreadsheet<a id="8507"></a> would have numerical<a id="9121"></a> information such as the node's coordinates and<a id="8755"></a> an index value<a id="9341"></a> which other users might need, but we don't. We have to<a id="9089"></a> start by examining the layout of<a id="9218"></a> the data<a id="8951"></a> and<a id="8756"></a> the process necessary to<a id="9090"></a> extract what we need. Based on<a id="8824"></a> the spreadsheet<a id="8508"></a>, there is both string and<a id="8757"></a> numerical<a id="9122"></a> data<a id="8952"></a>.</p>
      <p>The other concern is that there are a different number of<a id="9219"></a> connections on<a id="8825"></a> each row of<a id="9220"></a> the sheet. Our solution to<a id="9091"></a> the beams problem requires the connections to<a id="9092"></a> be placed in a cell<a id="8441"></a> array<a id="8425"></a>. When a connection is present, it is a string. When it is not present, we can see from<a id="8581"></a> the behavior of<a id="9221"></a> the raw data<a id="8953"></a> that the contents of<a id="9222"></a> empty<a id="8479"></a> cells appear as a cell<a id="8442"></a> containing <code>missiong</code>.</p>
      <p>We need a function<a id="8542"></a> that will read this spread sheet and<a id="8758"></a> produce the same model of<a id="9223"></a> the structure<a id="9278"></a> used in Chapter 7. Such a function<a id="8543"></a> is shown in Listing 8.4.</p>
      <div class="listing">#listing_08_4#</div>
      <p>To test this function<a id="8544"></a>, replace the structure<a id="9279"></a> array<a id="8426"></a> construction in lines 1–22 of<a id="9224"></a> Listing 7.6 in Chapter 7 with<a id="8808"></a> the following line:<br>
      <code>data<a id="8954"></a> = readStruct(<a id="8599"></a>'beams.xlsx');</code><br>
      The script should then produce the same results as before.</p>
    </div>
  </div>

  <!-- Chapter Summary -->
  <h2>Chapter Summary</h2>
  <div class="container">
    <p>We have described three levels of<a id="9225"></a> capability for<a id="9385"></a> reading<a id="8657"></a> and<a id="8759"></a> writing<a id="8667"></a> files:
    <ul>
      <li>The save and<a id="8760"></a> load operators<a id="9127"></a> allow you to<a id="9093"></a> save variables from<a id="8582"></a> the workspace and<a id="8761"></a> restore them to<a id="9094"></a> the workspace</li>
      <li>Specialized functions<a id="9290"></a> read and<a id="8762"></a> write spreadsheets<a id="9276"></a> and<a id="8763"></a> delimited<a id="9332"></a> text<a id="9324"></a> files</li>
      <li>Lower-level functions<a id="9291"></a> provide the ability to<a id="9095"></a> open and<a id="8764"></a> close<a id="8465"></a> files, and<a id="8765"></a> to<a id="9096"></a> read and<a id="8766"></a> write text<a id="9325"></a> files in any form that is required</li>
    </ul>
  </div>
<h2>Self Test</h2>
<div class="container">

Use the following questions to<a id="9097"></a> check your understanding of<a id="9226"></a> the material in this
chapter:
<h3>True or False</h3>
<ol>
<li>All data<a id="8955"></a> files should be treated as a sequential series of<a id="9227"></a> characters.</li>
      <li> When you save a workspace,<a id="9399"></a> you are actually saving the scripts<a id="9258"></a> that
generate the data<a id="8956"></a> in the workspace.</li>
      <li>MATLAB<a id="8867"></a> reads strings from<a id="8583"></a> tab- or comma-delimited<a id="9333"></a> files by
recognizing the double quotes that delimit strings.</li>
      <li>If you use fopen(<a id="8526"></a>...) to<a id="9098"></a> open an existing file and<a id="8767"></a> write to<a id="9099"></a> it, the
original data<a id="8957"></a> in the file will be overwritten.</li>
      <li>The function<a id="8545"></a> fgets(<a id="8523"></a>fh) does not always return a string.</li>
</ol>
<h3>Fill in the Blanks</h3>
<ol>
<li>In general, data<a id="8958"></a> files contain text<a id="9326"></a> that represents the ________ of<a id="9228"></a> the
data<a id="8959"></a> and<a id="8768"></a> control characters that specify the _____________ of<a id="9229"></a> the
data<a id="8960"></a>.</li>
      <li>The MATLAB<a id="8868"></a> readcell(<a id="8598"></a>...) function<a id="8546"></a> returns three results: the
____________ in a(n) __________, the __________ in a(n) __________,
and<a id="8769"></a> _____________ in a ____________.</li>
      <li>When using dlmread(<a id="8474"></a>...) to<a id="9100"></a> populate a(n) ___________, any
unassigned values are ___________.</li>
      <li>When using fopen(<a id="8527"></a>...) , the consequence of<a id="9230"></a> failure to<a id="9101"></a> open the file
is _____________.</li>
</ol>

<h3>Programming Projects</h3>
<ol>
<li>Write a script that performs the following operations<a id="9126"></a>:
<ul>
<li>Set the value<a id="9342"></a> of<a id="9231"></a> variables a, b, c1, c2, c3, and<a id="8770"></a> x . The values
don’t matter, except you should set c2 to<a id="9102"></a> 42.</li>
      <li>Save the values of<a id="9232"></a> all the variable<a id="9347"></a> except x to<a id="9103"></a> mydata.mat using
the save operation<a id="8644"></a>.</li>
      <li>Set the value<a id="9343"></a> of<a id="9233"></a> c2 to<a id="9104"></a> -99.</li>
      <li>Load myData.mat and<a id="8771"></a> check that c2 is now 42.</li>
      <li>Clear all variables.</li>
      <li>Load myData.mat again and<a id="8772"></a> note that the variable<a id="9348"></a> x is not present.
</ul></li>
      <li>One requirement for<a id="9386"></a> all freshmen classes<a id="8460"></a> is an issue of<a id="9234"></a> a 'Standing'
during the middle of<a id="9235"></a> the term. The results are either Satisfactory (S)
or Unsatisfactory (U) . Since you are the office employee in charge of<a id="9236"></a>
issuing these grades, you decide to<a id="9105"></a> write a function<a id="8547"></a> called
midtermGrades to<a id="9106"></a> help<a id="8631"></a> yourself. You discover that the grades are on<a id="8826"></a>
a spreadsheet<a id="8509"></a> organized like this:
<ul>
<li>Each student is represented by one row on<a id="8827"></a> the spreadsheet<a id="8510"></a>.</li>
      <li>Unfortunately, since these sheets are created by different
instructors, they are not necessarily consistent in their layout.</li>
      <li>The first row will contain the following six strings in any order:<br>
'name', 'math', 'science', 'english', 'history', and<a id="8773"></a> 'cs'.</li>
      <li>Under the name column will be a string with<a id="8809"></a> the student's name.</li>
      <li>Grades in the other columns can be 'A', 'B', 'C', 'D', 'F', or
'W</li>
      <li>A student's grade is 'S' if there are more A's, B's and<a id="8774"></a> C's than
not.</li>
      </ul>
Your function<a id="8548"></a> should print out grades ready to<a id="9107"></a> be entered consisting
of<a id="9237"></a> a table with<a id="8810"></a> headings 'Name' and<a id="8775"></a> 'S/U'</li>
      <li>Write a function<a id="8549"></a> called genStats that will compute statistics for<a id="9387"></a> a set
of<a id="9238"></a> class grades. The grades will be stored in a spreadsheet<a id="8511"></a>, and<a id="8776"></a> your
function<a id="8550"></a> will compute statistics and<a id="8777"></a> then write the grades along
with<a id="8811"></a> the statistics to<a id="9108"></a> another spreadsheet<a id="8512"></a>. <br>
You may assume that the initial spreadsheet<a id="8513"></a> will have a format<a id="8641"></a>
similar to<a id="9109"></a>:<br>
Student Name Exam1 Exam2 Exam3 ...<br>
student 1 100 76 45 ...<br>
student 2 34 83 89 ...<br>
The first row is the header row, and<a id="8778"></a> the first column is the list of<a id="9239"></a>
student names<a id="9351"></a>. There may be any number of<a id="9240"></a> exam grades, and<a id="8779"></a> there
may be any number of<a id="9241"></a> students. Although, you may assume that
there will be at least one student and<a id="8780"></a> that there will be at least one
exam.<br>
Also, every student will have a grade for<a id="9388"></a> every exam.
Your function<a id="8551"></a> should only have one input (a string containing the
file name of<a id="9242"></a> the grades file) and<a id="8781"></a> no outputs. You must write your
function<a id="8552"></a> to<a id="9110"></a> perform the following steps:
<ul>
<li>Calculate the average grade of<a id="9243"></a> each student (across the rows) and<a id="8782"></a>
store it in a new column called 'Average' (to the right of<a id="9244"></a> the last
exam grade).</li>
      <li>Calculate the deviation of<a id="9245"></a> each student's overall average
(calculated in step a) from<a id="8584"></a> the maximum student average and<a id="8783"></a>
store it in a new column called 'Deviation' (to the right of<a id="9246"></a> the
'Average' column). Note that deviation is just the difference
between the maximum student average and<a id="8784"></a> a student's overall
average.</li>
      <li>Calculate the average of<a id="9247"></a> each column's data<a id="8961"></a> (each exam), the
averages calculated in step a, and<a id="8785"></a> the deviations calculated in
step b, then store these averages below the last row of<a id="9248"></a> the original
data<a id="8962"></a> and<a id="8786"></a> name that row 'Total Average'.</li>
      <li>Write the original data<a id="8963"></a> along with<a id="8812"></a> all of<a id="9249"></a> the new data<a id="8964"></a> to<a id="9111"></a> a file
named 'Stats_&lt;name_of<a id="9250"></a>_original_file&gt;' (so if the inputted file
name was 'Student_Grades.csv' , the new data<a id="8965"></a> would be written
to<a id="9112"></a> the file named 'Stats_Student_Grades.csv' ).</li>
      <li>Construct a spreadsheet<a id="8514"></a> with<a id="8813"></a> suitable test data<a id="8966"></a> and<a id="8787"></a> use it to<a id="9113"></a> test
your function<a id="8553"></a>.</li>
      </ul></li>
      <li>Write a function<a id="8554"></a> called replaceStr . Your function<a id="8555"></a> should take in the
following order:<br>
filename: A string that corresponds to<a id="9114"></a> the name of<a id="9251"></a> a file<br>
wordA: A string that is a word (contains no spaces)<br>
wordB: Another string that is also a word (contains no spaces)<br>
Your function<a id="8556"></a> should do the following:
<ul>
<ul>Read the file a line at a time.</li>
      <li>On each line, replace every occurrence of<a id="9252"></a> wordA with<a id="8814"></a> wordB.</li>
      <li>Write the modified text<a id="9327"></a> file with<a id="8815"></a> the same name as the original
file, but preprended with<a id="8816"></a> 'new_' . For instance, if the input
filename was 'data<a id="8967"></a>.txt' , the output filename would be 'new_
data<a id="8968"></a>.txt'.</li>
      <li>Prepare a test file by downloading a text<a id="9328"></a> file from<a id="8585"></a> the Internet.
For example<a id="9268"></a>, the complete works of<a id="9253"></a> Shakespeare are accessible at
http://www.william-shakespeare.info</li>
      <li>Examine the file for<a id="9389"></a> repeated words, and<a id="8788"></a> test your function<a id="8557"></a> by
writing<a id="8668"></a> a script that replaces frequently repeated words.</li>
</ul></li>
 
</ol>
</div>
</div>


</body>
</html>

