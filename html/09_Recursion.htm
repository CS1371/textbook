<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"> 
<html> 
<head> 
<title>09_Recursion</title> 
<link rel="stylesheet" href="styles/styles.css" /> 
<script async src="./javascript/index.js"></script> 
</head> 
<body bgcolor="#ffffff"> 
<h1 align="center">Chapter 9: Recursion</h1> 

<table align="center"> 
<tbody> 
<tr> 
<td><a href="08_File_I_O.htm">previous</a></td> 
<td><a href="Contents.htm">home</a></td> 
<td><a href="10_Problem_Solving.htm">next</a></td> 
</tr> 
</tbody> 
</table>
<ul>
<li><a href="#9_1">9.1   Concept: The Activation Stack</a>
<ul>
    <li><a href="#9_1_1">9.1.1  A Stack</a>
    <li><a href="#9_1_2">9.1.2   Activation Stack</a>
    <li><a href="#9_1_3">9.1.3  Function Instances</a>
</ul>
<li><a href="#9_2">9.2   Recursion Defined</a>
<li><a href="#9_3">9.3   Implementing a Recursive Function</a>
<li><a href="#9_4">9.4   Exceptions</a>
<ul>
    <li><a href="#9_4_1">9.4.1   Historical Approaches</a>
    <li><a href="#9_4_2">9.4.2  Generic Exception Implementation</a>
    <li><a href="#9_4_3">9.4.3   MATLAB Implementation</a>
</ul>
<li><a href="#9_5">9.5   Wrapper Functions</a>
<li><a href="#9_6">9.6   Examples of Recursion</a>
<ul>
    <li><a href="#9_6_1">9.6.1  Detecting Palindromes</a>
    <li><a href="#9_6_2">9.6.2  Fibonacci Series</a>
    <li><a href="#9_6_3">9.6.3  Zeros of a Function</a>
</ul>
<li><a href="#9_7">9.7 Engineering Example— Robot  Arm  Motion</a>
</ul>
<h1>Chapter Objectives</h1>

This chapter discusses the following basic ideas of recursive programming:
<ul> 
<li>Three basic characteristics must be present for a recursive function to work </li>
<li>Exceptions are a powerful mechanism for detecting and trapping errors</li>
<li>A wrapper function is used to set up the recursion </li>
<li>Other forms of recursion occur in special circumstances</li>
</ul>

<h1>Introduction</h1>
 Recursion is an alternative technique by which a code block can be repeated in a controlled manner. In Chapter 4, we saw repetition achieved by inserting control statements in the code (either <code>for</code> or <code>while</code>) to determine how many times a code block would be repeated. Recursion uses the basic mechanism for invoking functions to manage the repetition of a block of code.  While some problems are naturally solved by iterative solutions, there are many problems for which a recursive solution is elegant and easily understood. Frequently, a recursive function needs a “wrapper function” to set up the recursion and to check for erroneous initial conditions that might cause errors. The recursive function itself then becomes a private helper function.  
<h2><a name="9_1">9.1  Concept: The Activation Stack</a></h2>
 In order to understand recursive programming, we must look deeper into the mechanism by which function calls are mechanized. Calling any function depends on a special kind of data structure built into the architecture of the central processing unit (CPU). This is called the activation stack. It enables the CPU to determine which functions are active or suspended awaiting the completion of other function calls. To understand the activation stack, first we consider the basic concept of a stack.  
<h3><a name="9_1_1">9.1.1: A Stack</a></h3>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="200" src="Fig_9_1.jpg" width="300" /></p></center>
<figcaption><b><center>Fig 9.1: A Stack</center></b></figcaption></figure>

 A stack is one of the fundamental data structures of computer science. It is best modeled by considering the plates at the front of the cafeteria line. You cannot see how many plates there are on the stack, and the only access you have to them is to take the top plate off the top of the stack or put one on. So a stack is a collection of objects of arbitrary size with a restricted number of operations we are allowed to perform on that collection (see Figure 9.1). Unlike a vector, where it is permissible to read, add, or remove items anywhere in the collection, we are only allowed the following operations with a stack:<ul>
<li>Push an object onto the stack</li>
<li>Pop an object off the stack</li>
<li>Peek at the top object without removing it</li>
<li>Check whether the stack is empty</li>
</ul>  
<h3><a name="9_1_2">9.1.2	Activation Stack</a></h3>
 The core concept that enables any function (especially a recursive function) to operate is the concept of an activation stack. The activation stack is the means by which the operating system allocates memory to functions for storing local data. Typically, local storage is required by a function for the following reasons:<ul>
 <li>Storing the location in memory to which control must be returned when the function execution completes</l>
 <li>Storing copies of the function parameter values</l>
 <li>Providing space for the values of any local variables defined within the function</l>
 </ul>
 When MATLAB is initializing, the operating system allocates a block of memory to contain its activation stack and allocates the first item (usually called a “frame”) on the activation stack to store variables defined in the Command window and by scripts. An astute reader might recognize this as the initial workspace for the system. When the user starts a script or makes an entry in the Command window, any variables created are stored in that stack frame. When that application calls a function, a new stack frame is allocated and “pushed” onto the activation stack. The calling program is then suspended, actual parameters are copied to formal parameters in the new workspace and control is passed to the function. Any new variables created are stored in its stack frame. When that function completes, its frame is popped off the stack and destroyed, and control is returned   to the frame beneath, which is now the  top  of  the  stack.  If  an  active function calls another function, this process  is  repeated.  The  calling function is suspended, a stack frame is pushed onto the activation stack for the new function, and the original function is suspended until the new function completes.  
<h3><a name="9_1_3">9.1.3 Function Instances</a></h3>
 In Chapter 2 we discussed the difference between the type of data defined by its class and an object — an instance of that class assigned to a variable. In the same way, we draw the distinction between the .m file that defines the behavior of a function and the instance(s) of that function that result(s) when the function is called. Each new instance of a function has its own workspace that occupies a temporary stack frame allocated from the activation stack.  
<h2><a name="9_2">9.2	Recursion Defined</a></h2>
 Following the previous line of reasoning, in principle there is no reason why a function could not in fact “call itself,” and this is the logical basis for recursive programming. Of course, as with iterative programming, if there is no mechanism to stop the recursion, the process would repeat endlessly. In the case of endless recursion, since space is being consumed on the activation stack, the system will eventually terminate the process when the memory originally allocated for the activation stack is exhausted.<br>
 The canonical illustration of recursion is the computation of n factorial. We could view the calculation of <code>5!</code> in the following ways:<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;5! = 5 × 4 × 3 × 2 × 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;5! = 5 × 4!</code><br>
The second representation is the recursive view, which warrants a closer examination as follows:<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;n! = n × (n-1)!</code><br>
This definition would not be complete, however, without realizing that it must stop somewhere. In the original definition above, we did not continue the chain of multiplication with "<code> * 0 * (-1) * (-2) ... </code>" for obvious reasons — multiplying by 0 makes all factorial values 0! Mathematically, we “artificially” define the terminating condition for the factorial calculation as the state where <code>0! = 1</code>. We can derive from this example the three necessary characteristics of a recursive function:<ol>
<li>There must be a terminating condition to stop the process</li>
<li>The function must call <b>a clone</b> of itself</li>
<li>The parameters to that call must move the function toward the terminating condition</li>
</ol>
<b>Note:</b> The word <b>clone</b> is important here — a recursive function really does not “call itself,” because it requests a new stack frame and passes different parameters to the instance of the function that occupies the new frame.  
<h2><a name="9_3">9.3	Implementing a Recursive Function</a></h2>
Template 9.1 shows the general template for recursive functions. The following general guidelines indicate how the recursive template is implemented:

<div class="container">
  <div class="sidebar_R">
<h4>Template 9.1: General template for a recursive function</h4>
<code>
function &lt;result&gt; = &lt;function_name&gt; (&lt;formal_params&gt;)<br>
&lt;documentation&gt;<br>
&nbsp;&nbsp;if &lt;terminating condition 1&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;result&gt; = &lt;initial value 1&gt;<br>
&nbsp;&nbsp;elseif &lt;terminating condition 2&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;result&gt; = &lt;initial value 2&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;result&gt; = &lt;operation&gt; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;formal_params&gt;, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;function_name&gt; (&lt;new_params&gt;))<br>
end</code></div><br>

<div class="container">
 <ul>
<li>The <code>&lt;function_name&gt;</code>, like the name of any other function, may be any legal variable name</li>
<li>The variable <code>&lt;result&gt;</code> may be any legal variable name or a vector of variable names</li>
<li>As usual with functions, you should supply at least one line of <code>&lt;documentation&gt;</code> to define its purpose and implementation</li>
<li>Each exit from the function must assign values to all the result variables</li>
<li>The first design decision is to determine the condition(s) under which the recursive process should stop, and how to express this as the <code>&lt;terminating condition N&gt;</code> tests</li>
<li>The <code>&lt;initial value N&gt;</code> entries are the value(s) of the result(s) at the terminating condition(s)</li>
<li>The second design decision is to determine the <code>&lt;operation&gt;</code> - the specific mathematical or logical operation that must be performed to combine the current formal parameters with the result of the recursive call to create a new value of the <code>&lt;result&gt;</code></li>
<li>The last design decision is to determine how to compute the <actual_params> of the recursive call to ensure that the process moves toward at least one of the <code>&lt;terminating condition N&gt;</code> states</li>
</ul>
 </div>

<div class="container">
  <div class="sidebar_R">
<h4>Exercise 9.1 Analyzing recursive behavior</h4>
<ol>
<li>Create the <code>fact(...)</code> function from Listing 9.1 , remove the '<code>%</code>' from the print statement to enable the printout, and run it from the Command window:<br>
<code>>> fact(4)<br>
fact( 4 )<br>
fact( 3 )<br>
fact( 2 )<br>
fact( 1 )<br>
fact( 0 )<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;24</li></code>
<li>Put a break point at Line 4 and run <code>fact(2)</code>. The function should pause in the first stack frame. Notice that the only variable in the workspace is <code>N</code> with a value <code>2</code>.</li>
<li>Find the “step into” button and click it. Since <code>N</code> is not <code>0</code>, the arrow should move to Line 8.</li>
<li>Click again, and the workspace should change to a new workspace with the value <code>N = 1</code> — you just called a clone of the original function with its own stack frame. There should be a second, transparent arrow at Line 7 to indicate that some clone of this function is waiting at that point for a result.</li>
<li>Continue stepping into functions until you return from the copy where <code>N = 0</code>. When this return happens, you return to the frame with <code>N = 1</code>, the frame "underneath," at Line 8, and are then able to compute the first result.</li>
<li>Further stepping will return from each stack frame until you finally return to your script’s workspace with the final answer.<br>
</strong></code>
</div>
<div class="container">
The implementation of the factorial function is shown in Listing 9.1. In Listing 9.1 at Line 3, we show a diagnostic print call that, if not commented, enables you to observe the sequence of events.  Exercise 9.1 provides an analysis of recursive behavior. In particular, notice that all the mathematical operations are performed as the activation stack "unwinds."  

<h4>Listing 9.1: Function to compute N factorial</h4>
<code><strong>
<font color="#0000ff">function</font> result = fact(N)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% recursive computation of N!</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% fprintf('fact( %d )\n', N); % testing only</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> N == <font color="#ff8000">0</font><font color="#00A000"> % Terminating condition</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = <font color="#ff8000">1</font>;<font color="#00A000"> % Terminating action</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
<font color="#00A000"> % recursive call</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = N * fact(N - <font color="#ff8000">1</font>);<br>
<font color="#00A000"> % parameter moves closer to 0 as long as it started as a positive integer</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font></strong></code><br>


<h2><a name="9_4">9.4  Exceptions</a></h2>
 We digress here to discuss how programs deal with unexpected circumstances. Exceptions are a powerful tool for gracefully managing run- time errors caused by programming errors or bad data. The general need for an exception mechanism might best be established by way of an example. Suppose you write a program that requests some data from a user and then launches a significant number of nested function calls—perhaps even a recursive function—to perform an analysis on the data received. Somewhere in the depths of these function calls, the program divides something by a value, but in this instance that value is zero. The cause of this problem is probably bad data entered by the user in the top-level script. However, the effect is discovered deep in the activation stack in the middle of some obscure numerical computation. 
</div >
<h3><a name="9_4_1">9.4.1	Historical Approaches</a></h3>
 Early programming languages attempted to deal with this problem in one of two equally unpleasant ways:
 <ul>
 <li>Some languages require any mathematical function that might produce an error to return the status of that calculation to the calling function. They allow errors to be reported and processed, but they have two unpleasant consequences: using up the ability of a function to return a value and calling this function, which means choosing between testing for errors and solving the problem locally and passing the error condition back to its calling function in the hope that somewhere the error will be dealt with.</li>
 <li>Perhaps worse than this are the languages that use a globally accessible variable, such as <code>ierror</code>, to report status. For example, if <code>ierror</code> were normally set to <code>0</code>, an error could be announced by setting its value to something other than <code>0</code> to indicate the nature of the failure. This frees the function from needing to return status, but it does not relieve the calling function of the need to check whether the <code>ierror</code> value is bad, or solving the problem, or elevating it. Furthermore, if an error does occur within a function, since it is now still returning a value, what value should it return if it is unable to complete its assigned calculation? </li>
</ul> 
<h3><a name="9_4_2">9.4.2	Generic Exception Implementation</a></h3>

 By contrast, most modern programming languages provide an exception mechanism whereby if an error occurs, regardless of how deep in the activation stack, program implementation is immediately suspended in the current stack frame. The activation stack below this frame is then searched for the frame of a program that has “volunteered” to process this type of exception. When it is found, all the stack frames above this frame are removed from the stack and the code in the exception handling mechanism is activated. If no such frame is discovered, the overall program aborts with an error code.  The following mechanisms are necessary to implement the exception mechanism effectively:

<div class="container">
  <div class="sidebar_R">
<h4><center>Template 9.2: Template for processing exceptions</center></h4>
<code>
&lt;successful&gt; = false<br>
while &lt;not successful&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;try<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;request data from the user&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;process the data&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;successful&gt; = true<br>
&nbsp;&nbsp;&nbsp;&nbsp;catch<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;announce the error to the user&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
end</code></div><br>

<div class="container">
 <ul>
 <li><b>Throwing an exception:</b> Whenever a problem occurs, the operating system must suspend operations at that point in the activation stack and go looking for a function equipped to handle the specific exception. If no such function is found, the program is terminated and an exception is shown to the user (in MATLAB, it is written in red in the Command window).</li>
 <li><b>Catching an exception</b> A function that is able to deal with a specific exception uses a <code>try ... catch</code> construct to identify the suspect code and resolve the problem. Between <code>try</code> and <code>catch</code>, the programmer puts a code block that contains activities that could throw exceptions. After the <code>catch</code> statement, there is a code block that should fix the problem.  Depending on the specific language implementation, the exception-catching mechanism usually offers facilities both for determining exactly where the exception occurred and for reconstructing the activation stack with all the variable values as they were at the time of the exception.</li>
 </ul>
 In the previous example, the general template for successfully interacting with the user is shown in Template 9.2. The successful Boolean flag will be set only if the data are processed without error. It does not matter how deep in the data processing code the error occurs—the user interface catches the error, reports it to the user, and prompts the user for better data.  For example, you might have noticed earlier that the <code>input(...)</code> function has a built-in <code>try ... catch</code> mechanism to deal with erroneous user input. If something is entered that cannot be parsed, rather than throw red ink in the Command window, the exception is caught and the prompt repeated for the user.  
 </div>
<h3><a name="9_4_3">9.4.3	MATLAB Implementation</a></h3>
 MATLAB implements a simplified version of the most general form of exception processing. The <code>try ... catch ... end</code> construct is fully supported. However, unlike some languages, the MATLAB language does not distinguish between the kinds of exception that can be thrown.
 <ul>
 <li>All built-in functions throw exceptions when they discover error conditions—attempting to open a nonexistent file for reading, for example—and expect the programmer to catch these exceptions if they are recoverable.</li>
 <li>To throw an exception manually, the program calls the error(...) function that takes one parameter, a string defining the error. If the exception is not caught, the string provided is displayed in red to the user. If the exception is caught, that string is ignored.</li>
 <li>To handle an exception, a code block we suspect might throw an exception is placed between <code>try</code> and <code>catch</code> statements. If no error occurs in the code block, the <code>catch</code> statement is ignored. If an exception is thrown from that code block, however, execution is suspended at that point. No further processing is performed, no data are returned from functions, and the code in the closest <code>catch</code> block is executed up to the associated end statement. To determine the cause of the exception, you can use the <code>lasterror</code> function. It returns the textual information provided at the exception and a structure array describing the activation stack.</li>
 <li>In more complex situations where this function may not be able to actually handle the error, a further exception can be thrown from the <code>catch</code> block. This exception will escape from the current <code>try ... catch</code> block and must be caught (if at all) by another function or script deeper in the activation stack.</li>
 </ul>
 Listing 9.2 illustrates a simple example. The objective is to have the user define a triangle by entering a vector of three sides and to calculate the angle between the first two sides. The acosd(...) function computes the inverse cosine of a ratio. If that ratio is greater than one, there is something seriously wrong with the triangle, and acosd returns a complex number. This script detects that the answer is complex and throws an exception.  
 <div class="container">
  <div class="sidebar_R">
<h4>Exercise 9.2 Processing exceptions</h4>
Put the code from Listing 9.2 in a script and execute it, using the following data:<br>
<code>enter a triangle [a b c]: 2<font color="#00A000"> % wrong number of sides</font><br>
bad triangle - try again<br>
enter a triangle [a b c]: [3 4 8]<font color="#00A000"> % bad values</font><br>
bad triangle - try again<br>
enter a triangle: [3 4 6]<br>
the angle is 62.720387<br>
</code>
Then, edit the script to remove the try statement and the catch block and
repeat the test.
</div>
<div class="container">

 <h4>Listing 9.2: A script using exception processing</h4>
 <code><strong>
OK = false;<font color="#00A000"> % force the while loop to run at least once</font><br>
while ~OK<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">try</font><font color="#00A000"></font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;side = input(<font color="#c000c0">'enter a triangle [a b c]: '</font>);<font color="#00A000"> % ask the user for a triangle</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = side(<font color="#ff8000">1</font>); b = side(<font color="#ff8000">2</font>); c = side(<font color="#ff8000">3</font>); <font color="#00A000"> % allocate sides to [a b c]</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% This will fail with an error if the vector doesn't have at least 3 elements</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% I have the odd feeling that deal(...) could do this ... (sigh!)</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cosC = (c^<font color="#ff8000">2</font> - a^<font color="#ff8000">2</font> - b^<font color="#ff8000">2</font>)/(<font color="#ff8000">2</font> * a * b);<font color="#00A000"> % compute the cosine</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angle = acosd(cosC);<font color="#00A000"> % compute the angle. If the triangle is illegal, this will return a complex number</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> imag(angle) ~= <font color="#ff8000">0</font><font color="#00A000"></font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(<font color="#c000c0">'bad triangle'</font>)<font color="#00A000"> % announce the error and go immediately to the catch block which does nothing,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%       except go back to the input(...) call.</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK = true;<font color="#00A000"> % This line is only reached if the allocations and the acosd call work properly.</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">catch</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
fprintf(<font color="#c000c0">'the angle is %f\n'</font>, angle)<font color="#00A000"></font><br>
<br>
</strong></code>
</div>
<div class="container">
  <div class="sidebar_R">
<h4><center>Template 9.3: Template for a wrapper function</center></h4>
<code>
function &lt;result&gt; = &lt;function_name&gt; (&lt;formal_params&gt;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;documentation&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if &lt;bad_condition&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;throw exception&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;result&gt; = &lt;private_name&gt; (&lt;actual_params&gt;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
end<br>
<br>
function &lt;result&gt; = &lt;private_name&gt; (&lt;formal_params&gt;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;documentation&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if &lt;terminating condition 1&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;result&gt; = &lt;initial value 1&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;elseif &lt;terminating condition 2&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;result&gt; = &lt;initial value 2&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;result&gt; = &lt;operation&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;formal_params&gt;, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;private_name&gt; (&lt;new_params&gt;) )<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
end</code></div><br>

<div class="container">
You have an opportunity to work with exception processing in Exercise 9.2.  
<h2><a name="9_5">9.5 Wrapper Functions</a></h2>
 Consider the factorial function again for a moment—specifically, ask how you would deal with a user who accidentally called for the factorial of a negative number or of a number containing a fractional part. Our original recursive <code>fact(...)</code> function is not protected from these programmer errors. There are three possible strategies for dealing with this situation:
<ol>
<li>The legalist approach ignores the bad values, lets the user’s program die, and then responds to user complaints by pointing out that the documentation clearly indicates that you should not call for the factorial of a negative number. Usually this is not the best approach from the customer relations viewpoint or from the technical support effort viewpoint, especially since recursive code that hangs up typically crashes with a stack overflow—not the easiest symptom to diagnose!</li>
<li>In-line coding builds into the code a test for N less than zero (or fractional) and throws an exception with a meaningful error message. Although this is an improvement over the first choice because it exits gracefully, the test is in a bad place. The function is recursive; therefore, the code for that test is repeated as many times as the function is called. While modern computers are fast enough that one would probably not notice the difference, in general this is a poor implementation that punishes those who are using the function correctly with the same test each time the recursive function is called.</li>
<li>A wrapper function is the best solution. A wrapper function is called once to perform any tests or setup that the recursion requires and then to call the recursive function as a helper to the main function call. While there is a small computational cost to using a wrapper, it is only executed once rather than each time the recursive function is called.</li>
</ol>
</div>
Template 9.3 illustrates this idea. The first function named <function_name> is actually the wrapper function with the return result, parameters, and documentation expected by the caller. It makes whatever tests are necessary to validate the input data, cleans it up if necessary, and calls the helper function named <private_name>. Listing 9.3 is the implementation of the factorial function with a wrapper for protection from bad data.<br>
 <div class="container">
  <div class="sidebar_R">
<h4>Exercise 9.3 Running the protected factorial function</h4>
Write the <code>fact(...)</code> function as shown in Listing 9.3, and test it in the
Command window:<br>
<code>>> fact(-1)<br>
??? Error using ==> fact<br>
bad parameter for fact<br>
>> fact(.5)<br>
??? Error using ==> fact<br>
bad parameter for fact<br>
>> fact(4)<br>
ans =<br>
24<br>
</code>
</div>
<div class="container">
<h4>Listing 9.3: Wrapper implementation for the factorial function</h4>
<code><strong>
<font color="#0000ff">function</font> result = fact(N)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% computation of N!</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> (N < <font color="#ff8000">0</font>) || ((N - floor(N)) > <font color="#ff8000">0</font>)&nbsp;&nbsp;&nbsp;&nbsp; <font color="#00A000">% Look for negative or fractional parts of N</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(<font color="#c000c0">'bad parameter for fact'</font>);&nbsp;&nbsp;&nbsp;<font color="#00A000">% if found, exit with an error.</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% otherwise, </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = r_fact(N);<font color="#00A000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% call the helper function where the real recursion happens.</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<font color="#0000ff">function</font> result = r_fact(N)<font color="#00A000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% The recursive helper function</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% recursive computation of N!</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'fact( %d )\n'</font>, N);<font color="#00A000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Diagnostic Printing enabled</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> N == <font color="#ff8000">0</font><font color="#00A000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Check terminating condition</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = <font color="#ff8000">1</font>;<font color="#00A000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Terminating action</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = N * r_fact(N - <font color="#ff8000">1</font>);<font color="#00A000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% recursive call</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
</strong></code>
</div>
Exercise  9.3  gives  you  an  opportunity  to  work  with  the  protected factorial.  
<h2><a name="9_6">9.6 Examples of Recursion</a></h2>
 We conclude this chapter with three examples of recursive programming: detecting palindromes, computing the Fibonacci series of numbers, and finding zeros of a function. The examples are followed by a practical engineering example of the use of zero finding.  
<h3><a name="9_6_1">9.6.1	Detecting Palindromes</a></h3>
 We might want to determine whether a word or phrase received as a string is a palindrome, that is, whether it is spelled the same forward and backward. Of course, you could accomplish this in one line with vector operations (think about it!) but that would not be a good recursive exercise. If you look up what are considered official palindromes, the string can contain spaces and punctuation, and can have upper or lower case characters. One could design a recursive function named <code>isPal(&lt;string&gt;)</code> as follows:
 <ul>
 <li>Pre-process the string changing upper case to lower case and then removing all characters that are not lower case characters.</li>
 <li>The function <code>isPal(&lt;string&gt;)</code> terminates if the <code>&lt;string&gt;</code> has zero or one character, returning true.</li>
 <li>It also terminates if the first and last characters are not equal, returning false.</li>
 <li>Otherwise (first and last are equal), the function returns <code>isPal(&lt;shorter string&gt;)</code>, where the shorter string is obtained by removing the first and last characters of the original string.</li>
 <li>Clearly, since the string is always being shortened, the recursive solution is approaching the terminating condition.</li>
 </ul>
 The MATLAB implementation of the palindrome detector is shown in Listing 9.4. 
 <h4>Listing 9.4: Recursive palindrome detector</h4>
 <code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Start with a wrapper function to clean up the input string:</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% - Change upper case to lower case</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% - remove all characters not lower case</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;clear; clc<br>
<font color="#0000ff">function</font> res = isPal(str)<br>
&nbsp;&nbsp;&nbsp;&nbsp;str = lower(str);     <font color="#00A000">% remove all upper case</font><br>
str = str(str >= <font color="#c000c0">'a'</font> & str <= <font color="#c000c0">'z'</font>); <font color="#00A000">% keep only lower case</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;res = r_isPal(str);<font color="#00A000">% make the recursive call</font><<br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> res = r_isPal(str)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% recursive palindrome detector</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> length(str) < <font color="#ff8000">2</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = true;<font color="#00A000">  % success: a short string</font><<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">elseif</font> str(<font color="#ff8000">1</font>) ~= str(end)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = false;<font color="#00A000"> % failure - first and last characters don't match</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% recursive call is safe because there must be at least 2 characters here</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = r_isPal(str(<font color="#ff8000">2</font>:end-<font color="#ff8000">1</font>));<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
</strong></code>
Check this with these strings:<br>
<code>>> isPal('Can I attain a C?')<br>
>> isPal('Can I attain a&nbsp;&nbsp;C?')<br>
>> isPal('Can I attain a A?')<br>
>> isPal('Can I attain any C?')<br>
</code>
<h3><a name="9_6_2">9.6.2	Fibonacci Series</a></h3>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_9_2.jpg" width="450" /></p></center>
<figcaption><b><center>Fig 9.2: Fibonacci with Rabbits</center></b></figcaption></figure>
 The Fibonacci series was originally named for the Italian mathematician Leonardo Pisano Fibonacci, who was studying the growth of rabbit populations in the eleventh century. He hypothesized that rabbits mature one month after birth, after which time each pair would produce a new pair of rabbits each month. Starting with a pair of newborn rabbits free in a field, he wanted to calculate the rabbit population after a year. Figure 9.2 illustrates the calculation for the first six months, counting rabbit pairs. It soon becomes clear that the number of rabbits in month <code>N</code> comprises the number in month <code>N-1</code> (since in this ideal example, none of them die) plus the new rabbits born to the mature pairs. Since the rabbits mature after a month, the number of mature pairs that produce a new pair is the number of rabbits in the month before, <code>N-2</code>. So the algorithm for computing the population of pairs after <code>N</code> months, <code>fib(N)</code>, is recursive:
 <ul>
 <li>There is a terminating condition: when <code>N == 1</code> or <code>N == 2</code>, the answer is <code>1</code></li>
 <li>The recursive condition is: <code>fib(N) = fib(N-1) + fib(N-2)</code></li>
 <li>The solution is moving toward the terminating condition, since as long as <code>N</code> is a positive integer, computing <code>N-1</code> and <code>N-2</code> will move toward <code>1</code> or <code>2</code>.</li>
 </ul>
 The implementation of the Fibonacci function is shown in Listing 9.5.<br>
 <h4>Listing 9.5: The Fibonacci Function</h4>
 <code><strong>
<font color="#0000ff">function</font> result = fib(N)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% recursive computation the Nth Fibonacci number</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> N == <font color="#ff8000">1</font> || N == <font color="#ff8000">2</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = fib(N-<font color="#ff8000">1</font>) + fib(N-<font color="#ff8000">2</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
</strong></code>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_9_3.jpg" width="450" /></p></center>
<figcaption><b><center>Fig 9.3: Fibonacci in Nature</center></b></figcaption></figure>
This algorithm produces the Fibonacci series: <code>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, . . .</code>, giving a population after a year of <code>144</code> pairs of rabbits. <br>
A closely related phenomenon is the golden ratio or golden number computed as the limit of the ratio of successive Fibonacci series values — approximately <code>1.618034</code> — that has been found to occur in nature. To the surprise of naturalists, this series of numbers occurs in nature in a remarkable number of circumstances. Consider Figure 9.3 for example, where a set of squares placed side by side in a rotating sequence is drawn using the Fibonacci series for the size of each square. The resulting geometric figure is a close approximation to the logarithmic spiral so frequently found in nature, such as sea shells or seeds packed in pods.  <br>
<b>Notes: </b>
<ol>
<li>Although not shown here, the Fibonacci function needs the same kind of wrapper as we used on the factorial function to protect against bad input values (negative or fractional).</li>
<li>Before we leave the Fibonacci function, we should run a few examples:<br>
<code>
>> fib(1)<font color="#00A000"> % one of the terminating conditions</font><br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1<br>
>> fib(6)<font color="#00A000"> % illustrated in Figure 9.2</font><br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;8<br>
>> fib(12)<font color="#00A000"> % illustrated in Figure 9.3</font><br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;144<br>
>> fib(35)<font color="#00A000"> % did you notice anything?</font><br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;9227465<br>
</li>
</ol>
</code>
Unless you are running on a really fast computer, that last computation probably took over a second to run.  This may be our first example of situations where the algorithm is stunningly inefficient, and need a total redesign.  In the case of Fibonacci, the answer is easy, and will be left to the student to implement and test.<br>
<b>Hint: </b> Could you do this iteratively instead of recursively by storing the previous two values of N?

<h3><a name="9_6_3">9.6.3 Zeros of a Function</a></h3>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_9_4.jpg" width="450" /></p></center>
<figcaption><b><center>Fig 9.4: Find the zeros of this function</center></b></figcaption></figure>

 Frequently we need to solve nonlinear equations by seeking the values of the independent variable that produced a zero result. There are a number of well-known numerical techniques for achieving this goal. We will examine a recursive approach to determining the zeros of functions. However, especially when there are multiple zero crossings, it is very helpful to have a good initial estimate of the location(s) of the crossing(s). As an example, consider a function <code>f(x)</code>. We will use the function given by:<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;f(x) = 0.0333x<sup>6</sup> - 0.3x<sup>5</sup> - 1.3333x<sup>4</sup> + 16x<sup>3</sup> - 187.2x + 172.9</code><br>
 as plotted in Figure 9.4. Of course, this algorithm will work for any function of <code>x</code>. We assume that the continuous line describes the exact function, and the plus marks indicate locations for which we have measurements. Clearly, there are a number of zero crossings of this function, including a very messy looking crossing at around <code>x = 6</code>.  We will find the exact value of one of the zeros of this function by first estimating the zero crossings and then by using a recursive technique for refining a better estimate to arbitrary levels of accuracy.<br>
<b>Estimating Critical Points of a Function:</b> First, we need to compute an approximation to the roots of this equation illustrated by the red '+' marks on Fig 9.4. For our recursive algorithm to work nicely, we need a pair of x values whose y values straddle the x axis. These are marked by green circles on Fig 9.4. These approximations will be found by finding the x values at which adjacent values of the function change sign. The technique for determining where adjacent points change sign is simply to multiply adjacent values of f(x) and find where that product is not positive. Clearly, one could iterate here to find all of the roots. Listing 9.6 produces the following results, which can be verified by observing the circled data points shown in Figure 9.4:<br>
<code>zeros occur just after -6.3000	-4.6667	0.2333	5.9500</code><br>
 Having observed these results, we decide to compute the exact value of the first positive root, occurring at the third crossing.<br>
<b>Recursive Refinement of the Estimate:</b> The recursive function to find any root of <code>f(x)</code> works on the principle of binary division. It consumes a vector of adjacent values of <code>x</code> that are guaranteed to have values of <code>f(x)</code> of opposite sign. The fundamental features of the recursive solution are as follows:<ul>
<li>The terminating condition is when the two x values are within acceptable error—in this case, 0.001</li>
<li>Otherwise, we find the middle of this x range, mx, find its f(mx), and then make the recursive call either with [x(1) mx] or [mx x(2)], depending on the sign of f(mx) × f(x(1))</li>
<li>This will always converge because each recursive call halves the distance between the x limits. 
</ul>
In general, this method is a little slower than Newton’s method, which uses the slope of <code>f(x)</code> to compute the next estimate. However, it is very strong and somewhat immune from the instability suffered by Newton’s method on undulating data. The function that solves this problem is shown in Listing 9.6. 
<h4>Listing 9.6: Finding Zeros of a Function</h4>

<code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Recursive Root Finding</font><br>
<font color="#0000ff">function</font> main<br>
&nbsp;&nbsp;&nbsp;&nbsp;px = linspace(-<font color="#ff8000">7</font>, <font color="#ff8000">9</font>, <font color="#ff8000">100</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;plot(px, f(px))<br>
&nbsp;&nbsp;&nbsp;&nbsp;hold on<br>
&nbsp;&nbsp;&nbsp;&nbsp;grid on<br>
&nbsp;&nbsp;&nbsp;&nbsp;px = linspace(-<font color="#ff8000">6.3</font>, <font color="#ff8000">8.4</font>, <font color="#ff8000">19</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;py = f(px);<br>
&nbsp;&nbsp;&nbsp;&nbsp;disp(<font color="#c000c0">'zeros occur just after'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;zeros = find(py(<font color="#ff8000">1</font>:end-<font color="#ff8000">1</font>) .* py(<font color="#ff8000">2</font>:end) <= <font color="#ff8000">0</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> zndx = <font color="#ff8000">1</font>:length(zeros)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root = findZero([px(zeros(zndx)) px(zeros(zndx)+<font color="#ff8000">1</font>)]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot(root, f(root), <font color="#c000c0">'ro'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid on<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<font color="#0000ff">function</font> pt = findZero(x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% x is a lower-upper pair guaranteed to have</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% y values of opposite sign</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% return the x coordinate of the root</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> abs(x(<font color="#ff8000">1</font>)-x(<font color="#ff8000">2</font>)) < <font color="#ff8000">.001</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pt = x(<font color="#ff8000">1</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mx = sum(x)/<font color="#ff8000">2</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my = f(mx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> my*f(x(<font color="#ff8000">1</font>)) <= <font color="#ff8000">0</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pt = findZero([x(<font color="#ff8000">1</font>) mx]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pt = findZero([mx x(<font color="#ff8000">2</font>)]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<font color="#0000ff">function</font> res = f(x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;res = polyval([<font color="#ff8000">0.0333</font>, -<font color="#ff8000">0.3</font>, -<font color="#ff8000">1.3333</font>, <font color="#ff8000">16</font>, <font color="#ff8000">0</font>, -<font color="#ff8000">187.2</font>, <font color="#ff8000">172.9</font>],x);<br>
<font color="#0000ff">end</font><br>
</strong></code>
  

<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_9_5.jpg" width="450" /></p></center>
<figcaption><b><center>Fig 9.5: Robot Arm Problem</center></b></figcaption></figure>

<h2><a name="9_7">9.7 Engineering Example—Robot Arm Motion</a></h2>

Here we consider the problem of programming the arm of a robot to move its tip in a straight line. Consider the arm shown in Figure 9.5. It consists of a base free to rotate by an angle <code>&alpha;</code> from the direction of the X axis and two jointed limbs of length <code>r<sub>1</sub></code> and <code>r<sub>2</sub></code> at angles <code>&beta;</code> and <code>&gamma;</code>, respectively, to the horizontal. We will simplify things a bit by assuming that <code>r<sub>1</sub></code> and <code>r<sub>2</sub></code> are both equal to the same length <code>l<sub>n</sub></code>.<br>

<b>Overall Objective:</b>
The ultimate challenge of this situation is to calculate the sequence of values of <code>&alpha;</code>, <code>&beta;</code> and <code>&gamma;</code> that will guide the end of the arm, <code>P</code>, along the straight line defined by the points <code>P<sub>a</sub></code> and <code>P<sub>b</sub></code> where <code>P, P<sub>a</sub></code> and <code>P<sub>b</sub></code> are vectors showing the <code>x, y</code> and <code>z</code> coordinates of points on the red dashed line.  We will use a parametric definition of the line:<br>
<code>P = P<sub>a</sub> + t&#215;(P<sub>b</sub> - P<sub>a</sub>)</code><br>where t can take any value between 0 and 1.<br><br>
The value of <code>&alpha;</code> is easily determined to be the rotation to put P into the plane of the arm motion:<br>
<code>(1) &alpha; = atan2(P(1), P(2)) * 180/&pi;;<br></code>
We create the solution for <code>&beta;</code> and <code>&gamma;</code> with three more equations:<br>
<b>horizontally:</b> <code>(2) l<sub>n</sub>cos(&beta;) + l<sub>n</sub>cos(&gamma;) = |OR|</code> where O is the origin of coordinates and R is the projection of P onto the x-y plane.<br>
<b>vertically:</b> <code>(3) l<sub>n</sub>sin(&beta;) + l<sub>n</sub>sin(&gamma;) = P(3)</code><br>
<b>from algebra:</b><code>(4) cos<sup>2</sup>(&gamma;) + sin<sup>2</sup>(&gamma;) = 1</code><br>
and after much manipulation, we determine this expression:<br> 
<code>(5) |OR|<sup>2</sup> + P(3)<sup>2</sup> - 2l<sub>n</sub>(|OR|cos(&beta;) + P(3)sin(&beta;)) = 0<br>
</code>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_9_6.jpg" width="450" /></p></center>
<figcaption><b><center>Fig 9.6: The Zero Crossing Problem</center></b></figcaption></figure>

Pretty daunting until we plot the LHS of this equation against values of <code>&beta;</code> between <code>0</code> and <code>2&pi;</code> (Figure 9.6) and realize that we solve for <code>&beta;</code> by finding the value(s) of <code>&beta;</code> that reduce the LHS to 0 - a simple zero crossing problem.<br>
<b>Immediate Objective:</b>
The sub-problem we address here is to determine the value of <code>&beta;</code> that will reduce the LHS of Equation <code>(5)</code> to zero.<br>
<b>The Solution to the Sub-problem:</b> as before, since there is no analytical solution to this function, we will find the approximate location of the zero crossings and then use a recursive function to find the exact roots. The script that accomplishes this is shown in Listing 9.8.<br>

<code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;clear<br>
&nbsp;&nbsp;&nbsp;&nbsp;clc<br>
&nbsp;&nbsp;&nbsp;&nbsp;close all<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> start<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> P<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> ln<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> Pa<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> Pb<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> cxx<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> cyy<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> czz<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> cimg<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> nxx<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> nyy<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> nzz<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> nimg<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> ORxmag<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> fh<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
</strong></code>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><video width="560" height="420" controls>
<source src="robot_arm.mp4" type="video/mp4">
Your browser does not support the video tag.
</video></p></center>
<figcaption><b><center>Fig 9.7: The Solution</center></b></figcaption></figure>
<code><strong>

&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% We have 3 angles to compute:</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%  - alfa at A about the Z axis from the Y axis</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%  - beta at A about the X axis from the horizontal</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%  - gamma at B about the X axis</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;fh = fopen(<font color="#c000c0">'debug.log'</font>,'w');<br>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(fh, <font color="#c000c0">'%10s%10s%10s%10s\n\n'</font>, 'step',<font color="#c000c0">'alpha'</font>,'beta',<font color="#c000c0">'gamma'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;start = <font color="#ff8000">90</font>;  <font color="#00A000">% inital guess at solution</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;ln = <font color="#ff8000">30</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;nw = <font color="#ff8000">3</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;nr = <font color="#ff8000">2</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;facets = <font color="#ff8000">10</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[cxx cyy czz] = cylinder([<font color="#ff8000">1</font> <font color="#ff8000">1</font>], facets);  <font color="#00A000">% arms</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;czz(<font color="#ff8000">2</font>,:) = ln;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[r, c] = size(cxx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;cimg = zeros(r, c, <font color="#ff8000">3</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;cimg = cimg + <font color="#ff8000">0.8</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[xx yy zz] = cylinder([nr nr], facets);  <font color="#00A000">% nodes</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;nxx = zz;<br>
&nbsp;&nbsp;&nbsp;&nbsp;nyy = yy;<br>
&nbsp;&nbsp;&nbsp;&nbsp;nzz = xx;<br>
&nbsp;&nbsp;&nbsp;&nbsp;nxx = nxx*nw - nw/<font color="#ff8000">2</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;nzr = zeros(<font color="#ff8000">1</font>,facets+<font color="#ff8000">1</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;nxx = [nzr-nw/<font color="#ff8000">2</font>; nxx; nzr+nw/<font color="#ff8000">2</font>];<br>
&nbsp;&nbsp;&nbsp;&nbsp;nyy = [nzr; nyy; nzr];<br>
&nbsp;&nbsp;&nbsp;&nbsp;nzz = [nzr; nzz; nzr];<br>
&nbsp;&nbsp;&nbsp;&nbsp;[nr, nc] = size(nxx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;nimg = zeros(nr, nc, <font color="#ff8000">3</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;nimg = nimg + <font color="#ff8000">0.8</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Pa = [<font color="#ff8000">10</font> -<font color="#ff8000">20</font> <font color="#ff8000">32</font>];<br>
&nbsp;&nbsp;&nbsp;&nbsp;Pb = [-<font color="#ff8000">3</font>, <font color="#ff8000">40</font>, <font color="#ff8000">0</font>];<br>
&nbsp;&nbsp;&nbsp;&nbsp;t = <font color="#ff8000">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;results = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;ok = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">while</font> ok && t <= <font color="#ff8000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P = Pa + (Pb - Pa).*t;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% find alfa</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">try</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[alfa, beta, gamma] = get_angles();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">catch</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok = false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.alf = alfa;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.bet = beta;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.gam = gamma;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.P = P;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results = [results res];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(fh, <font color="#c000c0">'%10.4f%10.2f%10.2f%10.2f\n'</font>, t, alfa, beta, gamma);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = t + <font color="#ff8000">0.01</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;fclose(fh);<br>
&nbsp;&nbsp;&nbsp;&nbsp;draw_stuff(results)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
<font color="#0000ff">function</font> draw_stuff(res)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> Pa<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> Pb<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> cxx<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> cyy<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> czz<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> cimg<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> nxx<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> nyy<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> nzz<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> nimg<br>
&nbsp;&nbsp;&nbsp;&nbsp;figure<br>
&nbsp;&nbsp;&nbsp;&nbsp;set(gca,<font color="#c000c0">'nextplot'</font>,'replacechildren'); <br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Create a video writer object for the output video file and open the object for writing.</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v = VideoWriter(<font color="#c000c0">'robot_arm.mp4'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;open(v);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Generate a set of frames, get the frame from the figure, and then write each frame to the file.</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> rndx = <font color="#ff8000">1</font>:length(res)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alfa = res(rndx)<font color="#ff8000">.alf</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beta = res(rndx)<font color="#ff8000">.bet</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gamma = res(rndx)<font color="#ff8000">.gam</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P = res(rndx)<font color="#ff8000">.P</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot3([Pa(<font color="#ff8000">1</font>) Pb(<font color="#ff8000">1</font>)],[Pa(<font color="#ff8000">2</font>) Pb(<font color="#ff8000">2</font>)],[Pa(<font color="#ff8000">3</font>) Pb(<font color="#ff8000">3</font>)], <font color="#c000c0">'rs--'</font>) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hold on<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot3(P(<font color="#ff8000">1</font>), P(<font color="#ff8000">2</font>), P(<font color="#ff8000">3</font>), <font color="#c000c0">'g*'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% fixed infrastructure</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% cylinder base</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N = <font color="#ff8000">100</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[bxx byy bzz] = cylinder([<font color="#ff8000">1</font> <font color="#ff8000">1</font>], N);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bxx = [zeros(<font color="#ff8000">1</font>,N+<font color="#ff8000">1</font>); bxx; zeros(<font color="#ff8000">1</font>,N+<font color="#ff8000">1</font>)];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byy = [zeros(<font color="#ff8000">1</font>,N+<font color="#ff8000">1</font>); byy; zeros(<font color="#ff8000">1</font>,N+<font color="#ff8000">1</font>)];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bzz = [zeros(<font color="#ff8000">1</font>,N+<font color="#ff8000">1</font>); bzz; ones(<font color="#ff8000">1</font>,N+<font color="#ff8000">1</font>)];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[r c] = size(bxx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bimg = zeros(r, c, <font color="#ff8000">3</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bimg(:,:,<font color="#ff8000">1</font>) = <font color="#ff8000">0.7</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bimg(:,:,<font color="#ff8000">2</font>) = <font color="#ff8000">0.7</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bimg(:,:,<font color="#ff8000">3</font>) = <font color="#ff8000">0.2</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;surf(bxx*<font color="#ff8000">3</font>, byy*<font color="#ff8000">3</font>, bzz*<font color="#ff8000">5</font>-<font color="#ff8000">5</font>, bimg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% cube</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bxx = [ <font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<font color="#ff8000">1</font> -<font color="#ff8000">1</font>  <font color="#ff8000">1</font>  <font color="#ff8000">1</font> -<font color="#ff8000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<font color="#ff8000">1</font> -<font color="#ff8000">1</font>  <font color="#ff8000">1</font>  <font color="#ff8000">1</font> -<font color="#ff8000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font>] * <font color="#ff8000">5</font>;      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byy = [ <font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ff8000">1</font> -<font color="#ff8000">1</font> -<font color="#ff8000">1</font>  <font color="#ff8000">1</font>  <font color="#ff8000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ff8000">1</font> -<font color="#ff8000">1</font> -<font color="#ff8000">1</font>  <font color="#ff8000">1</font>  <font color="#ff8000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font>  <font color="#ff8000">0</font>] * <font color="#ff8000">5</font>;      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bzz = [ <font color="#ff8000">1</font>  <font color="#ff8000">1</font>  <font color="#ff8000">1</font>  <font color="#ff8000">1</font>  <font color="#ff8000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ff8000">1</font>  <font color="#ff8000">1</font>  <font color="#ff8000">1</font>  <font color="#ff8000">1</font>  <font color="#ff8000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<font color="#ff8000">1</font> -<font color="#ff8000">1</font> -<font color="#ff8000">1</font> -<font color="#ff8000">1</font> -<font color="#ff8000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<font color="#ff8000">1</font> -<font color="#ff8000">1</font> -<font color="#ff8000">1</font> -<font color="#ff8000">1</font> -<font color="#ff8000">1</font>] * <font color="#ff8000">5</font>;      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[r c] = size(bxx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bimg = zeros(r, c, <font color="#ff8000">3</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bimg(:,:,<font color="#ff8000">1</font>) = <font color="#ff8000">0.5</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bimg(:,:,<font color="#ff8000">2</font>) = <font color="#ff8000">0.5</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bimg(:,:,<font color="#ff8000">3</font>) = <font color="#ff8000">0.2</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;surf(bxx, byy, bzz-<font color="#ff8000">10</font>, bimg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shading interp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;surf_rotated(nxx, nyy, nzz, nimg, <font color="#ff8000">180</font> - alfa, <font color="#ff8000">0</font>, [<font color="#ff8000">0</font> <font color="#ff8000">0</font> <font color="#ff8000">0</font>]);          <font color="#00A000">% plug A</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nd1 = surf_rotated(cxx, cyy, czz, cimg, <font color="#ff8000">180</font> - alfa, <font color="#ff8000">90</font>-beta, [<font color="#ff8000">0</font> <font color="#ff8000">0</font> <font color="#ff8000">0</font>]);     <font color="#00A000">% line E-A</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;surf_rotated(nxx+nd1(<font color="#ff8000">1</font>), nyy+nd1(<font color="#ff8000">2</font>), nzz+nd1(<font color="#ff8000">3</font>), <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nimg, <font color="#ff8000">180</font> - alfa, <font color="#ff8000">0</font>, nd1);                                      <font color="#00A000">% plug E</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nd2 = surf_rotated(cxx+nd1(<font color="#ff8000">1</font>), cyy+nd1(<font color="#ff8000">2</font>), czz+nd1(<font color="#ff8000">3</font>), <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cimg, <font color="#ff8000">180</font> - alfa, <font color="#ff8000">90</font> - gamma, nd1); <font color="#00A000">% line E-F                            % line E-F</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;surf_rotated(nxx+nd2(<font color="#ff8000">1</font>), nyy+nd2(<font color="#ff8000">2</font>), nzz+nd2(<font color="#ff8000">3</font>), nimg, <font color="#ff8000">180</font> - alfa, <font color="#ff8000">0</font>, nd2); <font color="#00A000">% plug F</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axis equal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    axis off</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xlabel(<font color="#c000c0">'X axis'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ylabel(<font color="#c000c0">'Y axis'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zlabel(<font color="#c000c0">'Z axis'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shading interp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;material metal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid on<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lightangle(-<font color="#ff8000">45</font>, <font color="#ff8000">45</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lightangle(<font color="#ff8000">45</font>, <font color="#ff8000">45</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view(-<font color="#ff8000">120</font>,<font color="#ff8000">40</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hold off<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame = getframe(gcf); <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeVideo(v,frame);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pause(<font color="#ff8000">0.03</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;close(v);<br>
<font color="#0000ff">end</font><br>
<br>
<br>
<font color="#0000ff">function</font> [alf bet gam] = get_angles()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> start<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> P<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> ORxmag<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> ln<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> fh<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% alpha is rotation to put P into the plane of the arm motion</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;alf = atan2(P(<font color="#ff8000">1</font>), P(<font color="#ff8000">2</font>)) * <font color="#ff8000">180</font>/pi;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% create the solution for the equation</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%               </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%   1. horizontal: ln cos b + ln cos g = ORxmag </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%     ORxmagf = ln.*(cosd(bet)+cosd(gam))</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%   2. vertical:   ln sin b + ln sin g = P(3)</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%     P3f = ln .* (sind(bet) + sind(gam))</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%   3. algebra:    cos g^2 + sin g^2 = 1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% from 1:   cos g = ORxmag/ln - cos b</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% from 2:   sin g = P(3)/ln - sin b</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% so in3:   (ORxmag/ln - cos b)^2 + (P(3)/ln - sin b)^2 - 1 = 0;</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% mult by ln^2:</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%            (ORxmag - ln cos b)^2 + (P(3) - ln sin b)^2 - ln^2 = 0;</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% simplify:</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%              ORxmag^2 - 2 ln ORxmag cos b + ln^2 cos b^2 </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%   + P(3)^2 - 2 ln P(3) sin b + ln^2 sin b^2 - ln^2 = 0;</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% using 3 again:</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%   ORxmag^2 + P(3)^2 - 2 ln(ORxmag cos b + P(3) sin b) = 0</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;ORxmag = sqrt(P(<font color="#ff8000">1</font>)^<font color="#ff8000">2</font> + P(<font color="#ff8000">2</font>)^<font color="#ff8000">2</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;b = linspace(<font color="#ff8000">0</font>, <font color="#ff8000">360</font>, <font color="#ff8000">100</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;y = equation(b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;plot(b, y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;grid on<br>
&nbsp;&nbsp;&nbsp;&nbsp;title(<font color="#c000c0">'intersection equation'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;xlabel(<font color="#c000c0">'beta'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ylabel(<font color="#c000c0">'y'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;axis([-<font color="#ff8000">100</font> <font color="#ff8000">400</font> -<font color="#ff8000">2000</font> <font color="#ff8000">5000</font>])<br>
&nbsp;&nbsp;&nbsp;&nbsp;pause(<font color="#ff8000">0.01</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;at = find(b > start);<br>
&nbsp;&nbsp;&nbsp;&nbsp;at = at(<font color="#ff8000">1</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;v = y(at);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% starting at at, find the index of b closest to </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% at that has Y value opposite in sign to v = y(at)</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% bto is all the b indices whose values are opposite</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% sign from v</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;bto = find(y.* v < <font color="#ff8000">0</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> isempty(bto)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(<font color="#c000c0">'no solution'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% dist is the index distance from 'at'</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;dist = abs(bto - at);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% ndx is the place on dist where the min occurs</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;[~, ndx] = min(dist);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% bto(ndx) is the index on B closest to the start</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;to = bto(ndx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">try</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bet = get_zero(b(at), b(to));<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">catch</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(<font color="#c000c0">'early shower'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;gam = atan2(P(<font color="#ff8000">3</font>)./ln - sind(bet), ORxmag./ln - cosd(bet))*<font color="#ff8000">180</font>/pi;<br>
&nbsp;&nbsp;&nbsp;&nbsp;start = bet;<br>
<font color="#0000ff">end</font><br>
<br>
<br>
<br>
<font color="#0000ff">function</font> res = get_zero(b1, b2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> abs(b1-b2) < <font color="#ff8000">0.01</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = b1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bm = (b1 + b2) ./ <font color="#ff8000">2</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e1 = equation(b1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e2 = equation(b2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;em = equation(bm);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> e1 .* em >= <font color="#ff8000">0</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = get_zero(bm, b2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = get_zero(b1, bm);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<br>
<font color="#0000ff">function</font> fn = equation(bet)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> P<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> ln<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> ORxmag<br>
&nbsp;&nbsp;&nbsp;&nbsp;cb = cosd(bet);<br>
&nbsp;&nbsp;&nbsp;&nbsp;sb = sind(bet);<br>
&nbsp;&nbsp;&nbsp;&nbsp;fn = ORxmag.^<font color="#ff8000">2</font> + P(<font color="#ff8000">3</font>).^<font color="#ff8000">2</font> - <font color="#ff8000">2</font>.*ln.*(ORxmag.*cb + P(<font color="#ff8000">3</font>).*sb);<br>
<font color="#0000ff">end</font><br>
<br>
<br>
<font color="#0000ff">function</font> nd = surf_rotated(xx, yy, zz, img, alpha, beta, offset)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% beta is about x axis</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;A = [cosd(beta) -sind(beta)<br>
&nbsp;&nbsp;&nbsp;&nbsp;sind(beta)  cosd(beta)];<br>
&nbsp;&nbsp;&nbsp;&nbsp;[r c] = size(xx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;N = r*c;<br>
&nbsp;&nbsp;&nbsp;&nbsp;P1(<font color="#ff8000">1</font>,:) = reshape(yy-offset(<font color="#ff8000">2</font>), <font color="#ff8000">1</font>, N); <br>
&nbsp;&nbsp;&nbsp;&nbsp;P1(<font color="#ff8000">2</font>,:) = reshape(zz-offset(<font color="#ff8000">3</font>), <font color="#ff8000">1</font>, N);<br>
&nbsp;&nbsp;&nbsp;&nbsp;P2 = A * P1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;yy = reshape(P2(<font color="#ff8000">1</font>,:), r, c) + offset(<font color="#ff8000">2</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;zz = reshape(P2(<font color="#ff8000">2</font>,:), r, c) + offset(<font color="#ff8000">3</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% alpha is about z axis</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;A = [cosd(alpha) -sind(alpha)<br>
&nbsp;&nbsp;&nbsp;&nbsp;sind(alpha)  cosd(alpha)];<br>
&nbsp;&nbsp;&nbsp;&nbsp;P1(<font color="#ff8000">1</font>,:) = reshape(xx-offset(<font color="#ff8000">1</font>), <font color="#ff8000">1</font>, N); <br>
&nbsp;&nbsp;&nbsp;&nbsp;P1(<font color="#ff8000">2</font>,:) = reshape(yy-offset(<font color="#ff8000">2</font>), <font color="#ff8000">1</font>, N);<br>
&nbsp;&nbsp;&nbsp;&nbsp;P2 = A * P1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;xx = reshape(P2(<font color="#ff8000">1</font>,:), r, c) + offset(<font color="#ff8000">1</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;yy = reshape(P2(<font color="#ff8000">2</font>,:), r, c) + offset(<font color="#ff8000">2</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;surf(xx, yy, zz, img);<br>
&nbsp;&nbsp;&nbsp;&nbsp;nd = [mean(xx(<font color="#ff8000">2</font>,:)), mean(yy(<font color="#ff8000">2</font>,:)), mean(zz(<font color="#ff8000">2</font>,:))];<br>
<font color="#0000ff">end</font><br>
<br>
<br>
<br>
<br>
</strong></code>


<b>Reflections:</b>
<ol>
<li>A modest amount of code is all that is required to create an elegant solution to a nontrivial problem. The structure of the recursive function <code>get_zero(b1, b2)</code> shown in Listing 9.8 clearly reflects the standard recursive template, and that function can be used to find zeros of any continuous function defined in the function <code>equation(bet)</code>.</li>
<li>At the risk of alarming students, I have left in place the not insignificant amount of code needed to verify that we are indeed solving the right problem correctly.  This code was pulled forward from concepts presented later in this text. 
</li></ol>

<h2>Chapter Summary</h2>

This chapter discussed the three basic principles of recursive programming that must be present for a recursive program to succeed:<ul>
<li>There must be a terminating condition</li>
<li>The function must call a clone of itself</li>
<li>The parameters of that clone must move the function toward the terminating condition.</li>
</ul>

We have also seen some other important capabilities as follows:<ul>
<li>Exceptions are declared either within system functions or by the user using the error(...) function; they are trapped and perhaps remedied using try ... catch code blocks</li>
<li>A wrapper function is used to set up a recursive solution by validating the incoming data.</li>
</ul>


[Special Characters]

[Problems]


<table align="center"> 
<tbody> 
<tr> 
<td><a href="08_File_I_O.htm">previous</a></td> 
<td><a href="Contents.htm">home</a></td> 
<td><a href="10_Problem_Solving.htm">next</a></td> 
</tr> 
</tbody> 
</table> 

<p align="center"><font size="1">This Web Page was Built with PageBreeze </font><a href="http://pagebreeze.com" target="_blank"><font size="1">Free HTML Editor</font></a><font size="1"> </font></p> 
</body> 
</html> 
-1.000000e+00 
