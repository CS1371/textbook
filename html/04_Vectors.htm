<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
    <title>04_Vectors</title>
    <link rel="stylesheet" href="styles/styles.css" />
    <script async src="./javascript/index.js"></script>
</head>
<body bgcolor="#ffffff">
<h1 align="center">Chapter 4: Vectors and Arrays</h1>

<table align="center">
	<tbody>
		<tr>
			<td><a href="03_Functions.htm">previous</a></td>
			<td><a href="Contents.htm">home</a></td>
			<td><a href="05_Execution.htm">next</a></td>
		</tr>
	</tbody>
</table>

<ul>
	<li><a href="#4_1">4.1  Concept: Data Collections</a>
	<ul>
		<li><a href="#4.1_1">4.1.1   Data Abstraction</a></li>
		<li><a href="#4_1_2">4.1.2   Homogeneous Collection</a></li>
	</ul>
	<li><a href="#4_2">4.2   Vectors</a>
	<ul>
		<li><a href="#4.2_1">4.2.1  Creating a Vector</a></li>
		<li><a href="#4_2_2">4.2.2  Size of a Vector</a></li>
		<li><a href="#4_2_3">4.2.3   Indexing a Vector</a></li>
		<li><a href="#4_2_4">4.2.4  Shortening a Vector</a></li>
		<li><a href="#4_2_5">4.2.5  Operating on Vectors</a></li>
	</ul>
	<li><a href="#4_4">4.4  Arrays</a>
	<ul>
		<li><a href="#4.4_1">4.4.1  Properties of an Array</a></li>
		<li><a href="#4_4_2">4.4.2  Creating an Array</a></li>
		<li><a href="#4_4_3">4.4.3   Accessing Elements of an Array</a></li>
		<li><a href="#4_4_4">4.4.4   Removing Elements of an Array</a></li>
		<li><a href="#4_4_5">4.4.5  Operating on Arrays</a></li>
	</ul>
	<li><a href="#4_5">4.5  Engineering Example — Computing Soil Volume</a><li>
</ul>

<h2>Chapter Objectives</h2>

<p>
This chapter discusses the basic calculations involving rectangular collections of numbers in the form of arrays. For each of these collections, you will learn how to:</p>
<ul>
<li>Create them</li>
<li>Manipulate them</li>
<li>Access their elements</li>
<li>Perform mathematical and logical operations on them</li>
</ul>
<p>This study of arrays will introduce the first of many language characteristics that sets MATLAB apart from other languages: its ability to perform arithmetic and logical operations on collections of numbers as a whole. You need to understand how to create these collections, access the data in them, and manipulate the values in the collections with mathematical and logical operators. First, however, we need to understand the idea of functions built into the language.</p>

<h2><a name="4_1">4.1  Concept: Data Collections</a></h2>

Chapter 2 showed how to perform mathematical operations on single data items. This section considers the concept of grouping data items in general, and then specifically considers two very common ways to group data: in arrays and in vectors, which are a powerful subset of arrays.

<h3><a name="4_1_1">4.1.1  Data Abstraction</a></h3>


It is frequently convenient to refer to groups of data collectively, for example, “all the temperature readings for May” or “all the purchases from Amazon.” This allows us not only to move these items around as a group, but also to consider mathematical or logical operations on these groups. For example, we could discuss the average, maximum, or minimum temperatures for a month, or that the cost of the Amazon purchases had gone down 3%.

<h3><a name="4_1_2">4.1.2  Homogeneous Collections</a></h3>

In Chapter 7, we will encounter more general collection implementations that <b>appear to</b> allow items in a collection to be of different data types. The collections discussed in this chapter, however, will be constrained to accept only items of the same data type. Collections with this constraint are called homogeneous collections.

<h2><a name="4_2">4.2   Vectors</a></h2>

<p>A vector is an array with only one row of elements. It is the simplest means of grouping a collection of like data items. Initially we will consider vectors of numbers or logical values. Some languages refer to vectors as linear arrays or linear matrices. As these names suggest, a vector is a one-dimensional grouping of data, as shown in Figure 4.1. Individual items in a vector are usually referred to as its elements. Vector elements have two separate and distinct attributes that make them unique in a specific vector: their numerical value and their position in that vector. For example, the individual number 66 is in the third position in the vector in Figure 4.1. Its value is 66 and its index is 3. There may be other items in the vector with the value of 66, but no other item will be located in this vector at position 3. Experienced programmers should note that due to its FORTRAN roots, indices in the MATLAB language start from 1 and not 0.</p>

<center><figure style="margin_bottom: 5px">
<p><img alt="image" height="70" src="Fig_4_1.jpg" width="400" /></p>
<figcaption>Fig 4.1 A General Vector</figcaption></figure></center>


<h3><a name="4_2_1">4.2.1  Creating a Vector</a></h3>

<p>There are seven ways to create vectors that are directly analogous to the techniques for creating individual data items and fall into two broad categories:</p>
<ul>
<li>Creating vectors from constant values</li>
<li>Producing new vectors with special-purpose functions</li>
</ul>
<p>The following shows how you can create vectors from constant values:</p>
<ui>
<li>Entering the values directly, for example, <code>A = [2, 5, 7, 1, 3]</code> (the commas are optional and are frequently omitted)</li>
<li>Entering the values as a range of numbers using the colon operator, for example, <code>B = 1:3:20</code>, where the first number is the starting value, the second number is the increment, and the third number is the ending value (you may omit the increment if the desired increment is 1)</li>
</ui>
<p>The following introduces the most common MATLAB functions that create vectors from scratch:</p>
<ui>
<li>The <code>linspace(...)</code> function creates a fixed number of values between two limits, for example, <code>C = linspace (0, 20, 11)</code>, where the first parameter is the lower limit, the second parameter is the upper limit, and the third parameter is the number of values in the vector</li>
<li>The functions <code>zeros(1,n)</code> and <code>ones(1,n)</code> create vectors filled with 0 or 1 respectively.</li>
<li>There are several functions that create vectors of random values. <code>rand(1,n)</code> generates a vector of random numbers uniformly distributed between 0 and 1; <code>randn(1,n)</code> generates a vector of normally distributed values with zero mean and unit standard deviation;  <code>randi([min max], 1, n)</code> generates a vector of random integers in the range min to max.</li>
</ui>
<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.1 - Creating vectors</h4>
<code>>> A = [2 5 7 1 3]<br>A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 5 7 1 3<br>
>> B = 1:3:20<br> B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 4 7 10 13 16 19<br>
>> C = linspace(0, 20, 11) <br>C =<br>
&nbsp;&nbsp;&nbsp;&nbsp;0 2 4 6 8 10 12 14 16 18 20<br>
>> D = [4] <br>D =<br>
&nbsp;&nbsp;&nbsp;&nbsp;4<br>
>> E = zeros(1,4) <br>E =<br>
&nbsp;&nbsp;&nbsp;&nbsp;0	0	0	0<br></code>
<p>Now, open the Workspace window  and study the contents.</p>
  </div>
  <div class="content">

<p>Try working with vectors in Exercise 4.1.</p>

<p>The Workspace window enables you to choose the attributes of each variable to be displayed. Select the Workspace window and you will see a row of column headings beginning with 'Name.' Right click on that headings row; a drop-down menu offers the attributes to display.  Common selections are 'Value' and 'Class.' You may also select and drag the column width markers to change the column layout.<br>
Notice that if the size of the vector is small enough, the value field shows its actual contents; otherwise, you see a description of its attributes, like <1 &#215 11 double>. Exercise 4.1 deliberately created the vector D with only one element, and perhaps the result surprised you. D was presented in both the Interactions window and the Workspace window as if it were a scalar quantity. This is generally true in the MATLAB language—all scalar quantities are considered vectors of unit length.</p>

<h3><a name="4_2_2">4.2.2  Size of a Vector</a></h3>

A vector also has a specific attribute: its length (<code>n</code> in Figure 4.1). In most implementations, this length is fixed when the vector is created. However, as you will see shortly, the MATLAB language provides the ability to increase or decrease the size of a vector by adding or removing elements. MATLAB also provides two functions to determine the size of arrays in general, and of vectors in particular. The function <code>size(V)</code> when applied to the vector <code>V</code> returns another vector containing two quantities: the number of rows in the vector (always 1) and the number of columns (the length of the vector). The function <code>length(V)</code> returns the maximum value in the size of the size array — for a vector, this is a number indicating its length.
</div>

<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.2 Manipulating a vector</h4>
<code>% Extending Exercise 4.1<br>
% indexing to change a value:<br>
{1.} >> A(5) = 42 <br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2	5	7	1	42<br>
% Indexing to extend a vector<br>
{2.} >> A(8) = 3 <br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2	5	7	1	42	0	0	3<br>
% Shortening a vector<br>
{3.} >> A(4) = [] <br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2	5	7	42	0	0	3<br>
% logical indexing<br>
{4.} >> evens = A([false true false true])<br>
evens = <br>
&nbsp;&nbsp;&nbsp;&nbsp;5 42 0</code>
  </div>
  <div class="content">

<h3><a name="4_2_3">4.2.3   Indexing a Vector</a></h3>

As mentioned in section 4.2.2, each element in a vector has two attributes: its value and its position in the vector. You can access the elements in a vector in either of two ways: using a numerical vector or a logical vector. We refer to the process of accessing array elements by their position as “indexing.”

<h3><a name="4_2_4">4.2.4  Shortening a Vector</a></h3>

<p>There are times when we need to remove elements from a vector. For example, if we had a vector of measurements from an instrument, and it was known that the setup for the third reading was incorrect, we would want to remove that erroneous reading before processing the data. To accomplish this, we make a rather strange use of the empty vector, []. The empty vector, as its name and symbol suggest, is a vector with no elements in it. When you assign the empty vector to an element in another vector—say, A—that element is removed from A, and A is shortened by one element. Try Exercise 4.2. As you can see in step {3.}, we asked for the fourth element to be removed from a vector initially with eight elements. The resulting vector has only seven elements, and the fourth element, originally with value 1, has been removed.</p>
<p>Shortening a vector, however, is very rarely the right solution to a problem and can lead to logical difficulties. Wherever possible, you should use indexing to copy
the elements you want to keep rather than using <code>[]</code>to erase elements you want to remove.</p>
</div>

<h3><a name="4_2_5">4.2.5  Operating on Vectors</a></h3>

<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.3 Using vector mathematics</h4>
<p><code>>> A = [2	5 7	1 3];<br>	
>> A + 5<br>				
ans =<br>					
&nbsp;&nbsp;&nbsp;&nbsp;7 10 12	6 8<br>
>> A .*	2	<br>				
ans =<br>						
&nbsp;&nbsp;&nbsp;&nbsp;4 10 14	2 6<br>
>> B = -1:1:3	<br>			
B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;-1	0	1	2	3<br>
>> A .* B % element-by-element multiplication<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;-2	0	7	2	9<br>
>> A * B % matrix multiplication!!<br>
??? Error using ==> mtimes<br>
Inner matrix dimensions must agree.<br>
>> C = [1 2 3]; <br>
>> A .* C % A and C must have the same length<br>
??? Error using ==> times Matrix dimensions must agree.</code>
  </div>
  <div class="content">
<p>The essential core of the MATLAB language is a rich collection of tools for manipulating vectors and arrays. This section first shows how these tools operate on vectors, and then generalizes to how they apply to arrays (multi- dimensional vectors) and, later, matrices. Three techniques extend directly from operations on scalar values:</p>
<ul>
<li>Arithmetic operations</li>
<li>Logical operations</li>
<li>Applying library functions</li>
</ul>
<p>Two techniques are unique to arrays in general, and to vectors in particular:</p>
<ul>
<li>Concatenation</li>
<li>Slicing (generalized indexing)</li>
</ui>
</p>
<p><b>Arithmetic Operations:</b> Arithmetic operations can be performed collectively on the individual components of two vectors as long as both vectors are the same length, or one of the vectors is a scalar (i.e., a vector of length 1). Addition and subtraction have exactly the syntax you would expect, as illustrated in Exercise 4.3. Multiplication, division, and exponentiation, however, have a small syntactic idiosyncrasy related to the fact that these are element-by-element operations, not matrix operations. We will discuss matrix operations in Chapter 12. When the MATLAB language was designed, the ordinary symbols (<code>*</code>,<code>/</code>, and <code>^</code>) were  reserved  for  matrix  operations.  However,  element-by-element  multiplicative  operations  are fundamentally different from matrix operations, and a new set of operators is required to specify these operations. <br>
These are the symbols <code>.*</code>, <code>./</code>, and <code>.^</code> {the dots are part of the operators, but the commas are not} that are used respectively for element-by- element  multiplication,  division,  and exponentiation. Note that because matrix and element-by-element addition and subtraction are identical, no special operation symbols are required for <code>+</code> and <code>-</code>.</p>
<p>In Exercise 4.3, we first see the addition and multiplication of a vector by a scalar quantity, and then element-by-element multiplication of <code>A</code> and <code>B</code>. The first error is generated because we omitted the ‘<code>.</code>’ on the multiply symbol, thereby invoking matrix multiplication, which is improper with the vector <code>A</code> and <code>B</code>. The second error occurs because two vectors involved in arithmetic operations must have the same size. Notice, incidentally, the use of the <code>%</code> sign indicating that the rest of the line is a comment.</p>

<p>You can change the signs of all the values of a vector with the unary minus (<code>-</code>) operator.</p>
</div>
<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.4 Working with vector logical expressions</h4>
<code>% logical expressions<br>
>> A = [2 5 7 1 3];<br>
>> B = [0 6 5 3 2];<br>
{1.}>> A >= 5<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;0	1	1	0	0<br>
{2.}>> A >= B<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1	0	1	0<br>
>> C = [1 2 3];<br>
{3.}>> A > C<br>
??? Error using ==> gt<br>
Matrix dimensions must agree.<br>
% Working with logical vectors<br>
>> A = [true true false false];<br>
>> B = [true false true false];<br>
{4.}>> A & B<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1	0	0	0<br>
{5.}>> A | B<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1	1	1	0<br>
>> C = [1 0 0];<br>
{6.}>> A & C<br>
??? Error using ==> and Matrix dimensions must agree.<br>
% Using the find(…) function<br>
>> A = [2 5 7 1 3];<br>
{7.}>> A > 4<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;0 1 1 0 0<br>
{8.}>> find(A > 4)<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 3</code>
  </div>
  <div class="content">

<p><b>Logical Operations:</b> In Exercise 4.2, you might have wondered why you would ever use logical indexing. In this section, we will see that logical operations on vectors produce vectors of logical results. We can then use these logical result vectors to index vectors in a style that makes the logic of complex expressions very clear. As with arithmetic operations, logical operations can be performed element-by-element on two vectors as long as both vectors are the same length, or if one of the vectors is a scalar (i.e., a vector of length 1). The result will be a vector of logical values with the same length as the longer of the original vector(s).</p>
<p>Try Exercise 4.4 to see how vector logical expressions work. First we built the vectors <code>A</code> and <code>B</code>, and then we performed two legal logical operations: finding where each element of <code>A</code> is not less than <code>5</code>, and where each element of <code>A</code> is not less than the corresponding element of <code>B</code>. As with arithmetic operations, an error occurs if you attempt a logical operation with vectors of different sizes (neither size being 1). Note to our eternal sadness that when MATLAB reports a logical result, it displays the values <code>1</code> for true and <code>0</code> for false. If you check in the Workspace window, the values are in fact of class <code>Logical</code>.</p>

<p>Logical operators can be assembled into more complex operations using logical and (<code>&amp;</code>) and or (<code>|</code>) operators. These operators actually come in two flavors: &amp;/| and &amp;&amp; / ||. The single operators operate on logical arrays of matching size to perform element-wise matches of the individual logical values. The doubled operators combine individual logical results and are usually associated with conditional statements (see Chapter 4). 

In Exercise 4.4{2.}, we combine two logical vectors of the same length successfully, but in {3.} we fail, since just like with arithmetic operations, we cannot combine vectors of different lengths. If you need the indices in a vector where the elements of a logical vector are <code>true</code>, the function <code>find(...)</code> accomplishes this by consuming a vector of logical values and producing a vector of the positions of the true elements.
You can invert the values of all elements of a logical vector (changing <code>true</code> to <code>false</code> and <code>false</code> to <code>true</code>) using the unary not operator, <code>~</code>. For example:<br>

<code>>> na = ~[true true false true]<br>na = <br>
&nbsp;&nbsp;&nbsp;&nbsp;0 0 1 0</code><br>
As you can see, each element of <code>na</code> is the logical inverse of the corresponding original element. As is usual with arithmetic and logical operations, the precedence of operators governs the order in which operations are performed. Table 4.1 shows the operator precedence in the MATLAB language. Operations listed on the same row of the table are performed from left to right. The normal precedence of operators can be overruled by enclosing preferred operations in parentheses: (...).</p>
</div>


<div class="container">
  <div class="sidebar_R">
<h4>Table 4.1 Operator Precedence</h4>
<table>
  <tr>
    <th>Operators</th>
    <th>Description</th>
  </tr>
   <tr>
    <td> <code>.', .^ </code></td>
    <td>Scalar transpose and power</td>
  </tr>
   <tr>
    <td> <code>', ^ </code></td>
    <td>Matrix transpose and power</td>
  </tr>
   <tr>
    <td> <code>+, -, ~ </code></td>
    <td>Unary Operators</td>
  </tr>
   <tr>
    <td> <code>.*, ./, .\, *, /, \ </code></td>
    <td>Multiplication, division, left division</td>
  </tr>
   <tr>
    <td> <code>+, - </code></td>
    <td>Addition and Subtraction</td>
  </tr>
   <tr>
    <td> <code>: </code></td>
    <td>Colon operator</td>
  </tr>
   <tr>
    <td> <code><, <=, >=, >, ==, ~=</code></td>
    <td>Comparison</td>
  </tr>
   <tr>
    <td> <code>&amp; </code></td>
    <td>Element-wise AND</td>
  </tr>
   <tr>
    <td> <code>| </code></td>
    <td>Element-wise OR</td>
  </tr>
   <tr>
    <td> <code>&amp;&amp; </code></td>
    <td>Logical AND</td>
  </tr>
   <tr>
    <td> <code>|| </code></td>
    <td>Logical OR</td>
  </tr>
</table>
  </div>
  <div class="content">
<p>One final note on logical indexing.  There is an interesting exception to the problem of indexing beyond the end of a vector. Consider this example:<br>
<code>>> A = [2 -4 5 0 1]<br>
B = A(true false true true false false false false)<br>
B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 5 0</code><br>
It is acceptable to index with a logical vector whose length is greater than the indexed vector as long as all the elements beyond the end of the indexed vector are <code>false</code>. It might help to consider a slightly different mechanization of the same code snippet:<br>
<code>>> A = [2 -4 5 0 1];<br>
ndxl = [true false true true false false false false);<br>
ndxn = find(ndxl) <br>
ndxn =&nbsp;&nbsp;&nbsp;&nbsp;1 3 4<br>
B = A(ndxn)<br>
B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 5 0</code><br>
This does not fail because the length of the numerical indices <code>ndxn</code> is less than the length of A.</p>

<p><b>Applying Library Functions:</b> The MATLAB language defines a rich collection of mathematical functions that cover mathematical, trigonometric, and statistics capabilities. A partial list is provided in Appendix A. For a complete list of those implemented in MATLAB, refer to the Help menu option in the MATLAB tool bar. With few exceptions, all functions defined in the MATLAB language accept vectors of numbers rather than single values and return a vector of the same length. The following functions deserve special mention because they provide specific capabilities that are frequently useful:
<ul>
<li><code>sum(v)</code> and <code>mean(v)</code> consume a vector and return the sum and mean of all the elements of the vector respectively.</li>
<li><code>min(v)</code> and <code>max(v)</code> return two quantities: the minimum or maximum value in a vector, as well as the position in that vector where that value occurred. For example:<br>
<code>>> [value where] = max([2 7 42 9 -4])<br>
value = 42<br>
where = 3<br></code>
indicates that the largest value is <code>42</code>, and it occurs in the third element of the vector. You saw in Chapter 3 how to implement returning multiple results from a function.</li>
<li><code>round(v)</code> , <code>ceil(v)</code> , <code>floor(v)</code> , and <code>fix(v)</code> remove the fractional part of the numbers in a vector by conventional rounding, rounding up, rounding down, and rounding toward zero, respectively.</ul></p>
</div>
<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.5 Concatenating vectors</h4>
<code>>> A = [2 5 7];<br>
>> B = [1 3];<br>
>> [A B]<br>
ans =<br>
2 5 7 1 3</code><br>
<p>Notice that the resulting vector is not nested like <code>[[2 5 7], [1 3]]</code> but is completely "flat."<p>
  </div>
  <div class="content">

<p><b>Concatenation</b> In Section 4.2.1, we saw the technique for creating a vector by assembling numbers between square brackets:<br>
<code>A = [2 5 7 1 3]</code><br>
This is in fact a special case of concatenation. The MATLAB language lets you construct a new vector by concatenating other vectors:<br>
<code>A = [B C D ...]</code><br>

where the individual items in the brackets may be any vector defined as a constant or variable, and the length of A will be the sum of the lengths of the individual vectors. The simple vector constructor in Section 4.2.1 is a special case of this rule because each number is implicitly a <code>1 × 1</code> vector. The result is therefore a <code>1 × N</code> vector, where N is the sum of the lengths of <code>A</code> and <code>B</code>. Try concatenating the vectors in Exercise 4.5.</p>
</div>
<p><b>Slicing</b> is the name given to complex operations where elements are copied from specified locations in one vector to different locations in another vector. As we saw earlier, the basic operation of extracting and replacing the elements of a vector is called indexing. Furthermore, we saw that indexing is not confined to single elements in a vector; you can also use vectors of indices. These index vectors either can be the values of previously named variables, or they can be created anonymously as they are needed. When you index a single element in a vector, for example, <code>A(4)</code>, you are actually creating an anonymous <code>1 &#215; 1</code> index vector, <code>4</code>, and then using it to access the specified element(s) from the array <code>A</code>.</p>

<p>Creating anonymous index vectors as needed makes some additional features of the colon operator available. The general form for generating a vector of numbers is: <br>
<code>&lt;start&gt; : &lt;increment&gt; : &lt;end&gt;</code>.<br>
 We already know that by omitting the <code>&lt;increment&gt;</code> portion, the default increment is <code>1</code>. When used anonymously while indexing a vector, the following features are also available:<br>
<ul>
<li>The key word <code>end</code> is defined as the length of the index vector in which it is used</li>
<li>The operator <code>:</code> by itself is short for <code>1:end</code></li>
</ul>
</p>
<p>Finally, as you saw earlier, it is legal to index with a vector of logical values. For example, if <code>A</code> is defined as:<br>
<code>A = [2 5 7 1 3];</code><br>
then <code>A([false true false true])</code> returns:<br>
<code>ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;5 1</code><br>

yielding a new vector containing only those values of the original vector where the corresponding logical index is <code>true</code>. This is extremely useful, as you will see later in this chapter, for indexing items in a vector that match a specific test.</p>
<p>The general form of statements for slicing vectors is:<br>
<code>B(&lt;rangeB&gt;) = A(&lt;rangeA&gt;)</code><br>
where <code>&lt;rangeA&gt;</code> and <code>&lt;rangeB&gt;</code> are both index vectors, <code>A</code> is an existing array, and <code>B</code> can be an existing array or a new array. The values in <code>B</code> at the indices in <code>rangeB</code> are assigned the values of <code>A</code> from <code>rangeA</code>. The rules for use of this template are as follows:<br>
<ul>
<li>Either the size of <code>rangeB</code> must be equal to the size of <code>rangeA</code> or
<code>rangeA</code> must be of size <code>1</code></li>
<li>If <code>B</code> did not exist before this statement was implemented, it is zero filled where assignments were not explicitly made</li>
<li>If <code>B</code> did exist before this statement, the values not directly assigned in <code>rangeB</code> remain unchanged. </p>
Study the comments in Listing 4.1 and do Exercise 4.10.</p>

<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.10: Running the vector indexing script</h4>
<p>Execute the script in Listing 4.1.You should see the following output:<br>
<code>odd values of A using predefined indices<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2	7	3<br>
odd values of A using anonymous indices<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2	7	3<br>
put even values into odd values in a new array<br>
B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;5	0	1	0	4<br>
set the even values in B to 99<br>
B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;5	99	1	99	4<br>
find the small values in A<br>
small =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1	0	0	1	1	0<br>
add 10 to the small values<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;12	5	7	11	13	4<br>
this can be done in one ugly operation<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;12	5	7	11	13	4<br>
</code>
  </div>
  <div class="content">

<h4>Listing 4.1: Vector Indexing Script</h4>
<code>
clear; clc<br>
    % Create a vector A with five elements.<br>
    A = [2 5 7 1 3 4];<br>
    % When predefining an index vector, if you want to refer to the size of a<br>
    % vector, you must use either the length(...) function or the size(...)<br>
    % function.<br>
    odds = 1:2:length(A);<br>
    % The disp(...) function shows the contents of its parameter in the<br>
    % Command window, in this case: 'odd values of A using predefined<br>
    % indices'. We use disp(...) rather than comments because comments are<br>
    % visible only in the script itself, not in the program output, which we<br>
    % need here.<br>
    disp('odd values of A using predefined indices')<br>
    % Using a predefined index vector to access elements in vector A.<br>
    % Since no assignment is made, the variable ans takes on the value<br>
    % of a three-element vector containing the odd-numbered elements of<br>
    % A. Notice that these are the odd-numbered elements, not the<br>
    % elements with odd values.<br>
    A(odds)    % {1}<br>
    disp('odd values of A using anonymous indices')<br>
    % Next is the anonymous version of the command given at {1}. Notice that the<br>
    % anonymous version allows you to use the word end within the vector meaning<br>
    % the index of its last element.<br>
    A(1:2:end)<br>
    disp('put evens into odd values in a new array')<br>
    % Since B did not previously exist (a good reason to run the clear command<br>
    % at the beginning of a script is to be sure this is true), a new vector is<br>
    % created with five elements (the largest index assigned in B). Elements in<br>
    % B at positions less than five that were not assigned are zero filled.<br>
    B(odds) = A(2:2:end)<br>
    disp('set the even values in B to 99')<br>
    % If you assign a scalar quantity to a range of indices in a vector, all<br>
    % values at those indices are assigned the scalar value.<br>
    B(2:2:end) = 99<br>
    disp('find the small values in A')<br>
    % Logical operations on a vector produce a vector of Boolean results. This<br>
    % is not the same as typing small = [1 0 0 1 1 0] . If you want to create a<br>
    % logical vector, you must use true and false, for example:<br>
    %       small = [true false false true true false]<br>
    small = A < 4<br>
    disp('add 10 to the small values')<br>
    % This is actually performing the scalar arithmetic operation + 10<br>
    % on an anonymous vector of three elements, and then assigning those<br>
    % values to the range of elements in A.<br>
    A(small) = A(small) + 10<br>
    disp('this can be done in one ugly operation')<br>
    % Not only is this unnecessarily complex, but it is also less efficient<br>
    % because it is applying the logical operator to A twice. It is better to<br>
    % use the form above.<br>
    A(A < 10) = A(A < 10) + 10<br>
	</code>
</div>

<h2><a name="4_3">4.3 Engineering Example — Forces  and  Moments</a></h2>

Vectors are ideal representations of the concept of a vector used in physics. Consider two forces acting on an object at a point P, as shown in Figure 4.2. Calculate the resultant force at P, the unit vector in the direction of that resultant, and the moment of that force about the point M. We can represent each of the vectors in this problem as a MATLAB vector with three components: the x, y, and z values of the vector. The solution to this problem for specific vectors is shown in Listing 4.2.
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="250" src="Fig_4_2.jpg" width="250" /></p>
<figcaption>Fig 4.2 Vector Analysis </figcaption></figure>
<p>
<h3>Listing 4.2 - solving a vector problem</h3>
<code>% Script to solve vector problems<br>
clear; clc<br>
    % Typical initial values for the problem.<br>
    PA = [0 1 1];<br>
    PB = [1 1 0];<br>
    P = [2 1 1]<br>
    A = P + PA<br>
    B = P + PB<br>
    M = [4 0 1]<br>
    % find the resultant of PA and PB<br>
    PC = PA + PB;<br>
    C = P + PC<br>
    % find the unit vector in the direction of PC<br>
    % The unit vector along PC is PC divided by its magnitude. The magnitude is<br>
    % the square root of the sum of the squares of the individual components.<br>
    mag = sqrt(sum(PC.^2));<br>
    unit_vector = PC/mag;<br>
    % find the moment of the force PC about M<br>
    % this is the cross product of MP and PC<br>
    % The vector MP is the vector difference between P and M.<br>
    MP = P - M;<br>
    % There is a built-in function, cross(..), to compute the cross product<br>
    %  of two vectors.<br>
    mom = cross( MP, PC )<br>
</code>
<p><b>Strong Suggestion:</b> After any nontrivial computation, a good engineer will always
perform a sanity check on the answers. When you run the
code for this problem, for example, the answers returned are:<br>
<code>PC = [ 1 2 1]</code><br>
<code>unit_vector = [0.4082 0.8165 0.4082]</code><br>
<code>mom = [ 1 2 -5]</code><br>
To check the moment result, visualize the rotation of PC
about M and apply the right-hand rule to find the axis of
rotation of the moment. Roughly speaking, the right-hand
rule states that the direction of the moment is the direction
in which a normal, right-handed screw at point M would turn
under the influence of this force. Without being too accurate,
we can conclude that the axis of the moment is approximately
along the negative z -axis, an estimate confirmed by the
result shown.</p>

<h2><a name="4_4">4.4  Arrays</a></h2>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="170" src="Fig_4_3.jpg" width="250" /></p>
<figcaption>Fig 4.3 an Array </figcaption></figure>

In Section 4.2, we saw that a vector is the simplest way to group a collection of similar data items. We will now extend these ideas to include arrays of multiple dimensions, initially confined to two dimensions. Each row will have the same number of columns, and each column will have the same number of rows.

At this point, we will refer to these collections as arrays to distinguish them from the matrices discussed in Chapter 12. While arrays and matrices are stored in the same way, they differ in their multiplication, division, and exponentiation operations. Figure 4.3 illustrates a typical two-dimensional array <code>A</code> with <code>m</code> rows and <code>n</code> columns, commonly referred to as an <code>m &#215; n</code> array.

<h3><a name="4_4_1">4.4.1  Properties of an Array</a></h3>

<p>As with vectors, individual items in an array are referred to as its elements. These elements also have the unique attributes combining their value and their position. In a two-dimensional array, the position will be the row and column (in that order) of the element. In general, in an n-dimensional array, the element position will be a vector of <code>n</code> index values.
When applied to an array <code>A</code> with <code>n</code> dimensions, the function <code>size(A)</code>
will return the information in one of two forms:
<ul>
<li>If called with a single return value like <code>sz = size(A)</code>, it will return a vector of length <code>n</code> containing the size of each dimension of the array.</li>
<li>If called with multiple return values like <code>[rows, cols] = size(A)</code>, it returns the individual array dimension up to the number of values requested. To avoid erroneous results with this approach, you should always provide as many variables as there are dimensions of the array.</li>
</ul>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="170" src="Fig_4_4.jpg" width="250" /></p>
<figcaption>Fig 4.4 an Array Transposed</figcaption></figure>

The <code>length(...)</code> function returns the <b>maximum dimension</b> of the array. So if we created an array <code>A</code> dimensioned 2 &#215; 8 &#215; 3, <code>size(A)</code> would return <code>[2 8 3]</code> and <code>length(A)</code> would return <code>8</code>.

The <b>transpose</b> of an <code>m &#215; n</code> array, indicated by the apostrophe character (') placed after the array identifier, returns an <code>n &#215; m</code> array with the values in the rows and columns interchanged. Figure 4.4 shows a transposed array.</p>
<p>A number of special cases arise that are worthy of note:</p>
<ul>
<li>When a 2-D matrix has the same number of rows and columns, it is called square.</li>
<li>When the only nonzero values in an array occur when the row and column indices are the same, the array is called diagonal.</li>
<li>When there is only one row, the array is a row vector, or just a
vector as you saw earlier.</li>
<li>When there is only one column, the array is a column vector, the transpose of a row vector.</li>
</ul>
<h3><a name="4_4_2">4.4.2  Creating an Array</a></h3>

<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.11 Creating arrays</h4>

<code>>> A = [2, 5, 7; 1, 3, 42]<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2	5	7<br>
&nbsp;&nbsp;&nbsp;&nbsp;1	3	42<br>
>> z = zeros(3,2) <br>
z =<br>
&nbsp;&nbsp;&nbsp;&nbsp;0	0<br>
&nbsp;&nbsp;&nbsp;&nbsp;0	0<br>
&nbsp;&nbsp;&nbsp;&nbsp;0	0<br>
>> [z ones(3, 4)] % concatenating arrays<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;0    0    1    1    1    1<br>
&nbsp;&nbsp;&nbsp;&nbsp;0    0    1    1    1    1<br>
&nbsp;&nbsp;&nbsp;&nbsp;0    0    1    1    1    1<br>
>> rand(3,4) <br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;0.9501 0.4860 0.4565 0.4447<br>
&nbsp;&nbsp;&nbsp;&nbsp;0.2311 0.8913 0.0185 0.6154<br>
&nbsp;&nbsp;&nbsp;&nbsp;0.6068 0.7621 0.8214 0.7919<br>
>> rand(size(A))<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;0.9218 0.1763 0.9355<br>
&nbsp;&nbsp;&nbsp;&nbsp;0.7382 0.4057 0.9169<br>
>> diag(A)<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;3<br>
>> diag(diag(A))<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;0 3<br>
>> magic(4)<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;16	2	3	13<br>
&nbsp;&nbsp;&nbsp;&nbsp;5	11	10	8<br>
&nbsp;&nbsp;&nbsp;&nbsp;9	7	6	12<br>
&nbsp;&nbsp;&nbsp;&nbsp;4	14	15	1<br>
</code>		
</div>	
<div class="content">
<p>Arrays can be created either by entering values directly or by using one of a number of built-in functions that create arrays with specific characteristics.
<ul>
<li>As with vectors, you can directly enter the values in an array using either a semicolon (;) or a new line to indicate the end of a row, for example: <code>A = [2, 5, 7; 1, 3, 42]</code>.</li>
<li>The functions <code>zeros(m, n)</code> and <code>ones(m, n)</code> create arrays with <code>m</code> rows and <code>n</code> columns filled with zeros and ones, respectively.</li>
<li>The function <code>rand(m, n)</code> fills an array with random numbers in the range <code>0 .. 1</code>.</li>
<li>The function <code>randn(m, n)</code> fills an array with random numbers normally distributed about <code>0</code> with a standard deviation of <code>1</code>.</li>
<li>The function <code>diag(...)</code> takes several forms, the most useful of which are <code>diag(A)</code>, where <code>A</code> is an array, that returns its diagonal as a vector, and <code>diag(V)</code>, where <code>V</code> is a vector, that returns a square matrix with that diagonal. Type <code>help diag</code> in the Command window for a full description of the capabilities of <code>diag(...)</code></li>
<li>The MATLAB language also defines the function <code>magic(m)</code>, which fills a square matrix with the numbers <code>1</code> to <code>m<sup>2</sup></code> organized in such a way that its rows, columns, and diagonals all add up to the same value.</li>
</ul>
Try Exercise 4.11 to practice working with arrays.
</div>
<h3><a name="4_4_3">4.4.3   Accessing Elements of an Array</a></h3>
<p>The elements of an array may be addressed by enclosing the indices of the required element in parentheses, with the first index being the row index and the second index the column index. Considering the values produced by Exercise 4.11, <code>A(2, 3)</code> would return the element in the second row, third column: <code>42</code>. If you were to attempt to read outside the length of the rows or columns, an error would result.</p>

<p>We can also store values that are elements of an array. For example, continuing Example 4.11, <br>
<code>A(2, 3) = 0</code><br>
would result in this answer:</p>
<code>A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2	5	7<br>
&nbsp;&nbsp;&nbsp;&nbsp;1	3	0<br></code>
<p>As with vectors, MATLAB will automatically extend the array if you write beyond its boundaries. If there are missing elements between the current array elements and the index at which you attempt to store a new value, the missing elements will be zero filled. For example, again continuing Example 4.11,<br>
<code>A(4, 1) = 3</code><br>
would result in this answer:<br>
<code>A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2	5	7<br>
&nbsp;&nbsp;&nbsp;&nbsp;1	3	0<br>
&nbsp;&nbsp;&nbsp;&nbsp;0	0	0<br>
&nbsp;&nbsp;&nbsp;&nbsp;3	0	0<br>
</code>


<h3><a name="4_4_4">4.4.4   Removing Elements of an Array</a></h3>

<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.12: Working with array arithmetic</h4>
<code>
>> A = [2 5 7<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 3 2]<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 5 7<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 3 2<br>
>> A + 5<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;7 10 12<br>
&nbsp;&nbsp;&nbsp;&nbsp;6 8 7<br>
B = ones(2, 3)<br>
B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 1 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 1 1<br>
>> B = B * 2<br>
B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 2 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 2 2<br>
>> A.*B % scalar multiplication<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;4 10 14<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 6 4<br>
>> A*B % matrix multiplication does not work here<br>
??? Error using ==> mtimes<br>
Inner matrix dimensions must agree.<br>
</code>
</div>	
<div class="content">
You can remove elements from arrays in the same way that you remove elements from a vector. However, since the arrays must remain rectangular, elements have to be removed as complete rows or columns. For example, for the array <code>A</code> in the previous section, entering:<br>
<code>A(3, :) = []</code><br>
would remove all elements from the third row, and the result would be:<br>
<code>A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2	5	7<br>
&nbsp;&nbsp;&nbsp;&nbsp;1	3	0<br>
&nbsp;&nbsp;&nbsp;&nbsp;3	0	0<br>
</code>
Similarly, if <br>
<code>A(:, 3) = []<br></code> 
was then entered, the result would be:<br>

<code>A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2	5<br>
&nbsp;&nbsp;&nbsp;&nbsp;1	3<br>
&nbsp;&nbsp;&nbsp;&nbsp;3	0<br>
</code>


<h3><a name="4_4_5">4.4.5  Operating on Arrays</a></h3>
<p>This section discusses how array operations extend directly from vector operations: arithmetic and logical operations, the application of functions, concatenation, and slicing. This section will also discuss two topics peculiar to arrays: reshaping and linearizing arrays.</p>
<p><b>Array Arithmetic Operations</b>: Arithmetic operations can be performed collectively on the individual components of two arrays as long as both arrays have the same dimensions or one of them is a scalar (i.e., has a vector of length 1). Addition and subtraction have exactly the syntax you would expect, as shown in Exercise 4.12. Multiplication, division, and exponentiation, however, must use the “dot operator” symbols: .*, ./, and .^ (the dot is part of the symbol, but the commas are not) for scalar multiplication, division, and exponentiation.</p>
<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.13: Working with array logical operations</h4>
<code>
>> A = [2 5; 1 3]<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 5<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 3<br>
>> B = [0 6; 3 2];<br>
>> A >= 4<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;0 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;0 0<br>
>> A >= B<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;0 1<br>
>> C = [1 2 3 4]<br>
>> A > C<br>
??? Error using ==> gt<br>
Matrix dimensions must agree.<br></code>
</div>
<div class="content">

<p><b>Array Logical Operations:</b> As with vectors, logical array operations can be performed collectively on the individual components of two arrays as long as both arrays have the same dimensions or one of the arrays is a scalar (i.e., has a vector of length 1). The result will be an array of logical values with the same size as the original array(s). Do Exercise 4.13 to see how array logical operations work. Here, we successfully compare the array <code>A</code> to a scalar value, and to the array <code>B</code> that has the same dimensions as <code>A</code>. However, comparing to the array <code>C</code> that has the same number of elements but the wrong shape produces an error. </p>
<p><b>Applying Library Functions:</b> In addition to being able to consume vectors, most mathematical functions in the MATLAB language can consume an array of numbers and return an array of the same shape. The following functions deserve special mention because they are exceptions to this rule and provide specific capabilities that are frequently useful:</p>
<ul>
<li><code>sum(v)</code> and <code>mean(v)</code> when applied to a 2-D array return a row vector containing the sum and mean of each column of the array, respectively. If you want the sum of the whole array, use <code>sum(sum(v))</code>.</li>
<li><code>min(v)</code> and <code>max(v)</code> return two row vectors: the minimum or maximum value in each column and also the row in that column where that value occurred. For example:<br>
<code>>> [values rows] = max([2	7 42;<br>
&nbsp;&nbsp;&nbsp;&nbsp;9 14	8;<br>
&nbsp;&nbsp;&nbsp;&nbsp;10 12 -6])<br>
values =<br>
&nbsp;&nbsp;&nbsp;&nbsp;[10 14 42]<br>
rows =<br>
&nbsp;&nbsp;&nbsp;&nbsp;[3 2 1]<br></code></li>
This indicates that the maximum values in each column are <code>10</code>, <code>14</code>, and <code>42</code>, respectively, and they occur in rows <code>3</code>, <code>2</code>, and <code>1</code>. </li>

<li>If you really need the row and column containing, say, the maximum value of the whole array, continue the preceding example with the following lines:<br>
<code>>> [value col] = max(values)<br>
value = <br>
&nbsp;&nbsp;&nbsp;&nbsp;42<br>
col = <br>
&nbsp;&nbsp;&nbsp;&nbsp;3<br>
</code>
This finds the maximum value in the whole array and determines that it occurs in column <code>3</code>. So to determine the row in which that maximum occurred, we index the vector of row maximum locations, <code>rows</code>, with the column in which the maximum occurred.<br>

<code>>> row = rows(col)<br>
row = <br>
1<br></code>
Therefore, we correctly conclude that the maximum number in this array is <code>42</code>, and it occurs at row <code>1</code>, column <code>3</code>.</li>
</ul>
</div>
<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.14 Concatenating arrays</h4>
<code>
>> A = [2 5; 1 7];<br>
>> B = [1 3]'; % makes a column vector<br>
>> [A B]<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 5 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 7 3<br>
</code>
</div>
<div class="content">

<p><b>Array Concatenation:</b> The MATLAB language permits programmers to construct a new array by concatenating other arrays in the following ways:
<ul>
<li>Horizontally, as long as each component has the same number of rows:<br>
<code>A = [B C D ... X Y Z]</code></li>
<li>Vertically, as long as each has the same number of columns:<br>
<code>A = [B; C; D; ... X; Y; Z]</code></li>
</ul>
The result of horizontal concatenation will be an array with the number of rows common to all and for the number of columns, the sum of the columns of each element concatenated. Similarly, the result of vertical concatenation will be an array with the number of columns common to all and for the number of rows, the sum of the rows of each element concatenated. Exercise 4.14 gives you the opportunity to concatenate an array.
</p>
</div>
<p><b>Slicing Arrays:</b> The general form of statements for moving sections of one array into sections of another is as follows:<br>
<code>B(&lt;rangeBR&gt;, &lt;rangeBC&gt;) = A(&lt;rangeAR&gt;,&lt;rangeAC&gt;)</code><br>
where each <code>&lt;range..&gt;</code> is an index vector, <code>A</code> is an existing array, and <code>B</code> can be either an existing array or a new array. The values in <code>B</code> at the specified indices are all assigned the corresponding values copied from A. The rules for using this template are as follows:
<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.15 Reshaping an array</h4>
<code>
>> A = 1:10<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 2 3 4 5 6 7 8 9 10<br>
>> reshape(A, 4, 3)<br>
??? Error using ==> reshape<br>
To RESHAPE the number of elements must not change.<br>
>> reshape([A 0 0], 4, 3)<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 5 9<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 6 10<br>
&nbsp;&nbsp;&nbsp;&nbsp;3 7 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;4 8 0<br></code>
</div>
<div class="content">
<ul>
<li>Either<ul>
<li>each dimension of each sliced array must be equal,</li>
 <li>or the number of elements moved must match (i.e. the product <code>&lt;rangeAR&gt;*&lt;rangeAC&gt;</code> must equal the product <code>&lt;rangeBR&gt;*&lt;rangeBC&gt;</code>)</li>
 <li>or the size of the slice from <code>A</code> must be <code>1&#215;1</code>.</li>
 </ul>
<li>If B did not exist before this statement was implemented, it would be zero filled where assignments were not explicitly made.</li>
<li>If B did exist before this statement, the values not directly assigned would remain unchanged.</li>
</ul>
<p><b>Reshaping Arrays:</b> Occasionally, it is useful to take an array with one set of dimensions and reshape it to another set. The function <code>reshape( ... )</code> accomplishes this. The command <code>reshape(A, rows, cols, ...)</code> will take the array <code>A</code>, whatever its dimensions, and reform it into an array sized <code>(rows &#215; cols &#215; ...)</code> out to as many dimensions as desired. However, <code>reshape(...)</code> neither discards excess data nor pads the data to fill any empty space. The product of all the original dimensions of <code>A</code> must equal the product of the new dimensions. Try Exercise 4.15 to see how to reshape an array. Here, we first take a 1 x 10 array, A, and attempt to reshape it to 4 x 3. Since the element count does not match, an error results. When we concatenate two zeros to the array A, it has the right element count and the reshape succeeds.
</p>
</div>
<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.16 Linearizing an array</h4>
<code>
>> A = [2 5 7 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;8 0 9 42<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 3 4 2];<br>
>> A > 5<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;0 0 1 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 0 1 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;0 0 0 0<br>
>> ix = find(A > 5)<br>
ix =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 7 8 11<br>
>> A(ix) = A(ix) + 3<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 5 10 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;11 0 12 45<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 3 4 2<br>
>> A(11)<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;42 % (sigh!)</code>
</div>
<div class="content">
<p><b>Linearized Arrays:</b> A discussion of arrays would not be complete without revealing an infamous secret of the MATLAB language: multi-dimensional arrays are not stored in some nice, rectangular chunk of memory. Rather, like all other blocks of memory, the block allocated for an array is sequential, and the array is stored in that space in column order. Normally, if MATLAB behaved as we "have a right to expect," we would not care how an array is stored. However, there are circumstances under which the designers of MATLAB needed to expose this secret. The primary situation in which array linearization becomes evident is the mechanization of the <code>find(...)</code> function. If we perform a logical operation on an array, the result is an array of logical values of the same size as the original array. In general, the true values would be scattered randomly about that resulting array. If we wanted to convert this to a collection of indices, what would we expect to see? The <code>find(...)</code> function has two modes of operation: we can give it separate variables in which to store the rows and columns by saying:<br>
<code>[rows cols] = find(...)</code> <br>
or we can receive back just one result by asking for:<br>
<code>ndx = find(...)</code>.<br>
Indexing with this result exposes the linearized nature of arrays. The way this feature manifests itself is shown in Exercise 4.16.</p>
<p>Here, we build a 4 &#215; 3 array <code>A</code> and calculate the logical array where <code>A</code> is greater than <code>5</code>. When we save the result of finding these locations in the variable <code>ix</code>, we see that this is a vector of values. If we count down the columns from the top left, we see that the second, seventh, eighth, and eleventh values in the linearized version of <code>A</code> are indeed <code>true</code>. We also see that it is legal to use this linearized index vector to access the values in the original array—in this case, to add <code>3</code> to each one. </p>
<div class="container">
  <div class="sidebar_R">
<h4>Exercise 4.17: Running the array manipulation script</h4>
<code>
Run the script in Listing 4.3 and observe the results:<br>
A = <br>
&nbsp;&nbsp;&nbsp;&nbsp;2 5 7 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 3 4 2<br>
rows = <br>
&nbsp;&nbsp;&nbsp;&nbsp;2<br>
cols = <br>
&nbsp;&nbsp;&nbsp;&nbsp;4<br>
odds =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 3<br>
odd columns of A using predefined indices<br>
ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;2 7<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 4<br>
odd columns of A using anonymous indices<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;2 7<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 4<br>
put evens into odd values in a new array<br>
B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;5 0 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;3 0 2<br>
set the even values in B's top row to 99<br>
B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;5 99 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;3 0 2<br>
find the small values in A<br>
small =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 0 0 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 1 0 1<br>
add 10 to the small values<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;12 5 7 13<br>
&nbsp;&nbsp;&nbsp;&nbsp;11 13 4 12<br>
this can be done in one ugly operation<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;12 5 7 13<br>
&nbsp;&nbsp;&nbsp;&nbsp;11 13 4 12<br>
do the same thing with indices<br>
small_index =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;4<br>
&nbsp;&nbsp;&nbsp;&nbsp;7<br>
&nbsp;&nbsp;&nbsp;&nbsp;8<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;112 5 7 113<br>
&nbsp;&nbsp;&nbsp;&nbsp;111 113 4 112<br>
</code>
</div>
<div class="content">
<p><b>Hints:</b><br>
1. It is best not to expose the detailed steps of finding logical
results in arrays, but to use an integrated approach:<br>
<code>A(A>5) = A(A>5) + 3</code><br>
This produces the expected answers without exposing the
nasty secrets underneath.<br>
2. Never use an array linearization as part of your program
logic. It makes the code hideous to look at and/or understand,
and it is never the “only way to do” anything.</p>
<p>Finally, we have a right to express a loud complaint when trying to reference the eleventh element of an array with only three rows. In fact
MATLAB “unwinds” the storage of the array, counts down to the eleventh entry—3 for column 1, 3 for column 2, and 3 for column 3—and then extracts the second element of column 4.</p>
</div>

<p>To understand all these array manipulation ideas fully, you should work carefully through the script in Listing 4.3, study the explanatory notes that follow, and do Exercise 4.17.
<h4>Listing 4.3: Array manipulation script</h4>
<code>% Create a 2 &#215; 4 array A<br>
A = [2 5 7 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 3 4 2]<br>
% Determine the rows and columns in A<br>
[rows, cols] = size(A)<br>
% find the indices of the odd numbered columns<br>
odds = 1:2:cols<br>
% use this explicit index vector to access the odd columns of A<br>
disp('odd columns of A using predefined indices')<br>
A(:, odds)<br>
% Use an anonymous index vector to access the odd columns of A<br>
% Notice that this enables the use of the word 'end.'
disp('odd columns of A using anonymous indices')<br>
A(end, 1:2:end)<br>
% Take copy the even columns in a into the odd columns of B, a new array
disp('put evens into odd values in a new array')<br>
B(:, odds) = A(:, 2:2:end)<br>
disp('set the even values in B''s top row to 99')<br>
B(1, 2:2:end) = 99<br>
% add 10 to the values in A less than 4<br>
disp('find the small values in A')<br>
small = A < 4<br>
disp('add 10 to the small values')<br>
A(small) = A(small) + 10<br>
% Repeat this exercise with anonymous vectors<br>
% Note that the efficiency might be a little less, but <br>
% the clarity of the code has improved<br>
disp('this can be done in one ugly operation')<br>
A(A < 4) = A(A < 4) + 10<br>
% now, to expose the linearized indices when find(...) is used
small_index = find(small)<br>
% then use the linearized index to add 100 to all the small values.
A(small_index) = A(small_index) + 100<br>
</code>
<br> 
Notice that all the results are consistent with our expectations.</p>
</div>
<h2><a name="4_5">4.5  Engineering Example— Computing  Soil  Volume</a></h2>
<p><b>Problem</b><br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="170" src="Fig_4_5.jpg" width="250" /></p>
<figcaption>Fig 4.5 a road through hilly terrain</figcaption></figure>
<p>We consider now an interesting problem from civil engineering.  Whenever a road [or railway track] are being run through hilly terrain, portions of hills need to be removed and valleys filled in.  The preliminary planning for the road location, slope and height must include the problem of moving earth.  It is most economical to use the earth removed from hills to fill in nearby valleys without having to haul surplus earth away or bring in extra fill dirt. Typically, the slopes of the cuttings and embankments are specified, for example, at 45 degrees.  Figure 4.5 illustrates a typical example.</p>
<p><b>Solution</b><br>
<p>Listing 4.4 shows one solution to this problem. Consider Figure 4.6 showing the earth to be removed in red and the earth needed to fill the valley in green. In order to balance the amount of earth to be moved, we need merely to sum the depths of the red patches and subtract the sum of the depth of the green patch. </p>
<p>There are a number of MATLAB language features in Listing 4.4 that will be dealt with in later chapters.  Refer to MATLAB documentation or the subsequent chapters of this text.</p>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="170" src="Fig_4_6.jpg" width="250" /></p>
<figcaption>Fig 4.6 Material to be moved</figcaption></figure>
<h3>Listing 4.4 Computing the earth to be moved</h3>
<code>
clear; clc; close all<br>
% lay out scenery for road cut<br>
    
global x<br>
global y<br>
global z<br>
global A<br>
global yr<br>
global clr<br>
global sxp<br>
global syp<br>
global szp<br>
global road_z<br>
global dbg<br>
global l_edge_ndx<br>
global r_edge_ndx<br>
global top<br>
global bot<br>
    
&nbsp;&nbsp;dbg = fopen('debug.log', 'w');<br>
&nbsp;&nbsp;road_z = 0;<br>
&nbsp;&nbsp;grey = [0.8 0.8 0.8];<br>
&nbsp;&nbsp;load('../xyz.mat')<br>
&nbsp;&nbsp;tth = x;<br>
&nbsp;&nbsp;pphi = y;<br>
&nbsp;&nbsp;zz = z;<br>
&nbsp;&nbsp;% road lines are phi = 2.4 - 2.6<br>
&nbsp;&nbsp;%                th = min - maxA =<br>
&nbsp;&nbsp;%                zz = 0<br>
&nbsp;&nbsp;xr = [th(1) th(1) th(end) th(end)];<br>
&nbsp;&nbsp;yr = [2.4 2.6 2.6 2.4];<br>
&nbsp;&nbsp;[xxr yyr] = meshgrid(xr, yr);<br>
&nbsp;&nbsp;zzr = xxr .* 0;<br>
&nbsp;&nbsp;[rr, rc] = size(xxr);<br>
&nbsp;&nbsp;img = uint8(zeros(rr, rc, 3) + 100);<br>
&nbsp;&nbsp;surf(xxr, yyr, zzr, img)   % road<br>
&nbsp;&nbsp;hold on<br>
&nbsp;&nbsp;% surfaces 45 deg from road edges are<br>
&nbsp;&nbsp;%   z = 2.4 - y<br>
&nbsp;&nbsp;%   z = y - 2.4<br>
&nbsp;&nbsp;%   z = 2.6 + y<br>
&nbsp;&nbsp;%   z = -y - 2.6<br>
&nbsp;&nbsp;zv = 2;<br>
&nbsp;&nbsp;xp = xr;<br>
&nbsp;&nbsp;yp = [yr(1), yr(1)-zv, yr(1)-zv, yr(1)];<br>
&nbsp;&nbsp;[xxp yyp] = meshgrid(xp, yp);<br>
&nbsp;&nbsp;zp = yr(1) - yyp;<br>
&nbsp;&nbsp;sxp{1} = xp;<br>
&nbsp;&nbsp;sxp{2} = xp;<br>
&nbsp;&nbsp;syp{1} = yp;<br>
&nbsp;&nbsp;syp{2} = yp;<br>
&nbsp;&nbsp;szp{1} = zp;<br>
&nbsp;&nbsp;szp{2} = -zp;<br>
&nbsp;&nbsp;yp = [yr(2), yr(2)+zv, yr(2)+zv, yr(2)];<br>
&nbsp;&nbsp;[xxp yyp] = meshgrid(xp, yp);<br>
&nbsp;&nbsp;zp = yr(2) - yyp;<br>
&nbsp;&nbsp;sxp{3} = xp;<br>
&nbsp;&nbsp;sxp{4} = xp;<br>
&nbsp;&nbsp;syp{3} = yp;<br>
&nbsp;&nbsp;syp{4} = yp;<br>
&nbsp;&nbsp;szp{3} = zp;<br>
&nbsp;&nbsp;szp{4} = -zp;<br>
&nbsp;&nbsp;% now, find the contours<br>
&nbsp;&nbsp;% restate the planes as ax + by + cz + d = 0<br>
&nbsp;&nbsp;%<br>
&nbsp;&nbsp;%   p1 : z = 2.4 - y    0   -1   -1   2.4<br>
&nbsp;&nbsp;%   p2 : z = y - 2.4    0    1   -1  -2.4<br>
&nbsp;&nbsp;%   p3 : z = y - 2.6    0    1   -1  -2.6<br>
&nbsp;&nbsp;%   p4 : z = -y + 2.6   0   -1   -1   2.6<br>
&nbsp;&nbsp;%    save x, y, z;<br>
&nbsp;&nbsp;A = [0   -1   -1   2.4<br>
&nbsp;&nbsp;&nbsp;&nbsp;0    1   -1  -2.4<br>
&nbsp;&nbsp;&nbsp;&nbsp;0    1   -1  -2.6<br>
&nbsp;&nbsp;&nbsp;&nbsp;0   -1   -1   2.6];<br>
&nbsp;&nbsp;clr = {'red','green','blue','cyan'};<br>
&nbsp;&nbsp;for n = 1:4<br>
&nbsp;&nbsp;&nbsp;&nbsp;draw_contours(n)<br>
&nbsp;&nbsp;end<br>
&nbsp;&nbsp;% find y values right before road and right after<br>
&nbsp;&nbsp;yps = y(:,1);<br>
&nbsp;&nbsp;% yps covering road<br>
&nbsp;&nbsp;at = yps &gt; yr(1) &amp; yps &lt; yr(2);<br>
&nbsp;&nbsp;fat = find(at);<br>
&nbsp;&nbsp;l_edge_ndx = fat(1)-1;<br>
&nbsp;&nbsp;r_edge_ndx = fat(end)+1;<br>
&nbsp;&nbsp;% populate bot and top surfaces with NaN<br>
&nbsp;&nbsp;[rows cols] = size(x);<br>
&nbsp;&nbsp;bot = zeros(rows, cols) + NaN;<br>
&nbsp;&nbsp;top = bot;<br>
&nbsp;&nbsp;removeCutSurface()<br>
&nbsp;&nbsp;% force road level to be below road<br>
&nbsp;&nbsp;y_road = find(y(:,1) &gt; yr(1) &amp; y(:,1) &lt; yr(2));<br>
&nbsp;&nbsp;y_road = [y_road(1)-1; y_road; y_road(end)+1];<br>
&nbsp;&nbsp;road_strip = z(y_road,:);<br>
&nbsp;&nbsp;too_high = road_strip &gt;= road_z;<br>
&nbsp;&nbsp;road_strip(too_high) = road_z - 0.05;<br>
&nbsp;&nbsp;z(y_road,:) = road_strip;<br>
&nbsp;&nbsp;[rws cls] = size(x);<br>
&nbsp;&nbsp;img = uint8(zeros(rws, cls, 3));<br>
&nbsp;&nbsp;img(:,:,[1 2]) = 140;<br>
&nbsp;&nbsp;surf(x, y, z, img);  % hillside<br>
&nbsp;&nbsp;xlabel('x (th)')<br>
&nbsp;&nbsp;ylabel('y (phi)')<br>
&nbsp;&nbsp;axis equal<br>
&nbsp;&nbsp;axis off<br>
&nbsp;&nbsp;view(78,16)<br>
&nbsp;&nbsp;saveas(gcf,'cutting.jpg')<br>    
&nbsp;&nbsp;hold on<br>
&nbsp;&nbsp;dy = 0.5;<br>
&nbsp;&nbsp;dz = 0.7;<br>
&nbsp;&nbsp;where = ~isnan(bot);<br>
&nbsp;&nbsp;top(where) = zz(where);<br>
&nbsp;&nbsp;sz = size(x);<br>
&nbsp;&nbsp;img = uint8(zeros(sz(1), sz(2), 3));<br>
&nbsp;&nbsp;img(:,:,2) = 255;<br>
&nbsp;&nbsp;surf(x, y+dy, bot+dz, img); % embankment added<br>
&nbsp;&nbsp;xlabel('x (th)')<br>
&nbsp;&nbsp;ylabel('y (phi)')<br>
&nbsp;&nbsp;axis equal<br>
&nbsp;&nbsp;axis off<br>
&nbsp;&nbsp;hold on<br>
&nbsp;&nbsp;[rws cls] = size(x);<br>
&nbsp;&nbsp;img = uint8(zeros(rws, cols, 3));<br>
&nbsp;&nbsp;img(:,:,1) = 255;<br>
&nbsp;&nbsp;surf(x, y+dy, top+dz, img);  % embankment removed<br>
&nbsp;&nbsp;view(78,16)<br>
&nbsp;&nbsp;saveas(gcf,'cutting_removed.jpg')<br>
<br>
function removeCutSurface<br>
&nbsp;&nbsp;global x<br>
&nbsp;&nbsp;global y<br>
&nbsp;&nbsp;global z<br>
&nbsp;&nbsp;[rows, cols] = size(x);<br>
&nbsp;&nbsp;for c = 1:cols<br>
&nbsp;&nbsp;&nbsp;&nbsp;try<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xp = x(1,c);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yps = y(:, c);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% interpolate for the red and blue z values<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make_a_cut(xp, yps, 1, 3, c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% interpolate for the green and cyan z values<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make_a_cut(xp, yps, 2, 4, c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;end<br>
end<br>
<br>
function make_a_cut(xp, yps, a, b, c)<br>
&nbsp;&nbsp;global x<br>
&nbsp;&nbsp;global y<br>
&nbsp;&nbsp;global z<br>
&nbsp;&nbsp;global yr<br>
&nbsp;&nbsp;global lip_x<br>
&nbsp;&nbsp;global lip_y<br>
&nbsp;&nbsp;global lip_z<br>
&nbsp;&nbsp;global dbg<br>
&nbsp;&nbsp;global l_edge_ndx<br>
&nbsp;&nbsp;global r_edge_ndx<br>
&nbsp;&nbsp;global road_z<br>
&nbsp;&nbsp;global top<br>
&nbsp;&nbsp;global bot<br>
    <br>
&nbsp;&nbsp;za = interp1(lip_x{a}, lip_z{a}, xp);<br>
&nbsp;&nbsp;zb = interp1(lip_x{b}, lip_z{b}, xp);<br>
&nbsp;&nbsp;if ~isnan(za) & ~isnan(zb)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ya = interp1(lip_x{a}, lip_y{a}, xp);<br>
&nbsp;&nbsp;&nbsp;&nbsp;yb = interp1(lip_x{b}, lip_y{b}, xp);<br>
&nbsp;&nbsp;&nbsp;&nbsp;cut = yps > ya & yps < yb;<br>
&nbsp;&nbsp;&nbsp;&nbsp;bot(cut,c) = road_z;<br>
&nbsp;&nbsp;&nbsp;&nbsp;z(cut,c) = NaN;<br>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(dbg,'a = [%0.2f,%0.2f]; b = [%0.2f,%0.2f]\n', ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ya, za, yb, zb);<br>
&nbsp;&nbsp;&nbsp;&nbsp;ny = find(cut);<br>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(dbg, 'ny = [ ');<br>
&nbsp;&nbsp;&nbsp;&nbsp;for it = ny<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(dbg, '%d ', it);<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(dbg, ']\n');<br>
&nbsp;&nbsp;&nbsp;&nbsp;if z(ny(1)-1,c) &gt; road_z<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(ny(1)-1:l_edge_ndx,c) = yr(1) - y(ny(1)-1:l_edge_ndx,c);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(l_edge_ndx+1,c) = road_z;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(r_edge_ndx-1,c) = road_z;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(r_edge_ndx:ny(end)+1,c) = y(r_edge_ndx:ny(end)+1,c) - yr(3);<br>
&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(ny(1)-1:l_edge_ndx,c) = -yr(1) + y(ny(1)-1:l_edge_ndx,c);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(l_edge_ndx+1,c) = road_z;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(r_edge_ndx-1,c) = road_z;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(r_edge_ndx:ny(end)+1,c) = -y(r_edge_ndx:ny(end)+1,c) + yr(3);<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;bot(ny(1)-1:l_edge_ndx+1,c) = z(ny(1)-1:l_edge_ndx+1,c);<br>
&nbsp;&nbsp;&nbsp;&nbsp;bot(r_edge_ndx-1:ny(end)+1,c) = z(r_edge_ndx-1:ny(end)+1,c);<br>
&nbsp;&nbsp;end<br>
end<br>
<br>
function draw_contours(ndx)<br>
&nbsp;&nbsp;global x<br>
&nbsp;&nbsp;global y<br>
&nbsp;&nbsp;global z<br>
&nbsp;&nbsp;global A<br>
&nbsp;&nbsp;global clr<br>
&nbsp;&nbsp;global sxp<br>
&nbsp;&nbsp;global syp<br>
&nbsp;&nbsp;global szp<br>
&nbsp;&nbsp;global road_z<br>
&nbsp;&nbsp;global lip_x<br>
&nbsp;&nbsp;global lip_y<br>
&nbsp;&nbsp;global lip_z<br>
    <br>
&nbsp;&nbsp;pln = A(ndx,:);<br>
&nbsp;&nbsp;cl = clr{ndx};<br>
&nbsp;&nbsp;d = x.*pln(1) + y.*pln(2) + z.*pln(3) + pln(4);<br>
&nbsp;&nbsp;[~,hcontour] = contour(x, y, d, 'LevelList', 0);<br>
&nbsp;&nbsp;c = hcontour.ContourMatrix;<br>
&nbsp;&nbsp;delete(hcontour);<br>
<br>    
&nbsp;&nbsp;% Loop through the ContourMatrix<br>
&nbsp;&nbsp;i = 1;<br>
&nbsp;&nbsp;while i &lt; size(c,2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;% Get the X &amp; Y for the next curve<br>
&nbsp;&nbsp;&nbsp;&nbsp;n = c(2,i);<br>
&nbsp;&nbsp;&nbsp;&nbsp;x2 = c(1,i+(1:n));<br>
&nbsp;&nbsp;&nbsp;&nbsp;y2 = c(2,i+(1:n));<br>
&nbsp;&nbsp;&nbsp;&nbsp;% Use interp2 to compute the matching Z values<br>
&nbsp;&nbsp;&nbsp;&nbsp;z2 = interp2(x,y,z, x2,y2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;switch ndx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case {1 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z2(z2 < road_z) = NaN;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case {2 4}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z2(z2 > road_z) = NaN;<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;% Draw that line<br>
&nbsp;&nbsp;&nbsp;&nbsp;%      line(x2,y2,z2,'Color',cl,'LineWidth',2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;z2 = condition(z2, ndx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;lip_x{ndx} = x2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;lip_y{ndx} = y2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;lip_z{ndx} = z2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;% Advance to next curve<br>
&nbsp;&nbsp;&nbsp;&nbsp;i = i+n+1;<br>
&nbsp;&nbsp;end<br>
&nbsp;&nbsp;%     xp = sxp{ndx};<br>
&nbsp;&nbsp;%     yp = syp{ndx};<br>
&nbsp;&nbsp;%     zp = szp{ndx};<br>
&nbsp;&nbsp;%     surf(xp, yp, zp)<br>
end<br>
<br>
function z = condition(z, ndx)<br>
&nbsp;&nbsp;try<br>
&nbsp;&nbsp;&nbsp;&nbsp;nn = find(isnan(z));<br>
&nbsp;&nbsp;&nbsp;&nbsp;d = diff(nn);<br>
&nbsp;&nbsp;&nbsp;&nbsp;at = find(d &gt; 1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;nat = length(at);<br>
&nbsp;&nbsp;&nbsp;&nbsp;% ndx 1 and 3 (red and blue)<br>
&nbsp;&nbsp;&nbsp;&nbsp;%            should have exactly one group of NaNs<br>
&nbsp;&nbsp;&nbsp;&nbsp;%            with real numbers before and after<br>
&nbsp;&nbsp;&nbsp;&nbsp;%  ideally:<br>
&nbsp;&nbsp;&nbsp;&nbsp;%  d = [n1 1 1 1 1 ... 1 1 1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;%  worst case:<br>
&nbsp;&nbsp;&nbsp;&nbsp;%  d = [1 1 n1 1 1 ... 1 1 1 n2 1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;%  put 0 in first 2 and last z values<br>
&nbsp;&nbsp;&nbsp;&nbsp;% ndx 2 and 4 (green and cyan)<br>
&nbsp;&nbsp;&nbsp;&nbsp;%            should have exactly 2 groups of NaNs<br>
&nbsp;&nbsp;&nbsp;&nbsp;%            with numbers only between them<br>
&nbsp;&nbsp;&nbsp;&nbsp;% ideally:<br>
&nbsp;&nbsp;&nbsp;&nbsp;%  d = [1 1 ... 1 1 n2 1 1 ... 1 1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;%  worst case<br>
&nbsp;&nbsp;&nbsp;&nbsp;%  d = [1 1 n1 1 1 ... 1 1 n2 1 1 ... 1 1 n3 1 1 1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;%  put NaN in z(3:(3 + n1 - 1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;%         and z(end-3:-1:end-3-n3+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;%<br>
&nbsp;&nbsp;&nbsp;&nbsp;switch ndx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case {1 3}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if nat &gt; 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error('really bad')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if d(1) == 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(1:at(1)-1) = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;case {2 4}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if nat &gt; 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ouch = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if nat == 3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% fix the front<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%  put NaN in z(3:(3 + n1 - 1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n1 = d(at(1));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(at(1):(at(1) + n1 - 1)) = NaN;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% fix the back<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%         and z(end-3:-1:end-3-n3+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n3 = d(at(3));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(end-at(3):-1:end - at(3) - n3 + 1) = NaN;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elseif nat == 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% find which to fix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if at(1) &lt; 10<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% fix the front<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%  put NaN in z(3:(3 + n1 - 1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n1 = d(at(1));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(at(1):(at(1) + n1 - 1)) = NaN;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% fix the back<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%         or z(end-3:-1:end-3-n3+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n2 = d(at(2));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z(end-at(2):-1:end - at(2) - n2 + 1) = NaN;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error('really bad')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;catch<br>
&nbsp;&nbsp;end<br>
end<br>
</code></p>
<h2>Chapter Summary</h2>

This chapter introduced you to vectors and arrays. For each collection, you saw how to:
<ul>
<li>Create a vectors and arrays by concatenation and a variety of special-purpose functions</li>
<li>Access and remove elements, rows, or columns</li>
<li>Perform mathematical and logical operations on them</li>
<li>Apply library functions, including those that summarize whole
columns or rows</li>
<li>Move arbitrary selected rows and columns from one array to
another</li>
<li>Reshape and linearize arrays</li>
</ul>
</p>

<table align="center">
	<tbody>
		<tr>
			<td><a href="03_Functions.htm">previous</a></td>
			<td><a href="Contents.htm">home</a></td>
			<td><a href="05_Execution.htm">next</a></td>
		</tr>
	</tbody>
</table>


<p align="center"><font size="1">This Web Page was Built with PageBreeze </font><a href="http://pagebreeze.com" target="_blank"><font size="1">Free HTML Editor</font></a><font size="1"> </font></p>
</body>
</html>
