<!DOCTYPE HTML>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="styles/styles.css" />
  <script async src="./javascript/index.js"></script>
<title>01_Introduction</title>
</head>
<body>
<div>#top_nav#</div>
<div class="nav-obj">#nav_obj#</div>

<div class="content">
  <h1 align="center" id="1">Chapter 1: Introduction</h1>

  <!-- Chapter Objectives -->
  <h1>Chapter Objectives</h1>
  <div class="container">
    <p>This chapter presents an overview<a id="1222"></a> of<a id="1225"></a> the historical background of<a id="1226"></a> computing and<a id="852"></a> the computer hardware and<a id="853"></a> software concepts that build the foundation for<a id="1398"></a> the rest of<a id="1227"></a> this book:</p>
    <ul>
    	<li>Hardware architectures</li>
    	<li>Software categories</li>
    	<li>Programming languages</li>
    	<li>Anticipated outcomes</li>
    </ul>
  </div>

  <div class="chp-section" data-sect-num="1" data-sect-name="Background">
    <!-- Background -->
    <h2 id="1_1">1.1 Background</h2>
    <div class="container">
      <p>Advances in technology are achieved in two steps as follows:</p>
      <ul>
      	<li>A visionary conceives an idea that has never been tried before</li>
      	<li>Engineers find or invent tools that will bring that vision to<a id="1062"></a> reality</li>
      </ul>
      <p>The search for<a id="1399"></a> new software tools is therefore an inescapable part of<a id="1228"></a> an engineer&rsquo;s life. The process of<a id="1229"></a> creating<a id="830"></a> these tools frequently spawns sub- problems, which themselves require creative solutions. The pace of<a id="1230"></a> change in our world is increasing, and<a id="854"></a> nowhere is this phenomenon more dramatically obvious than computer science. In the span of<a id="1231"></a> just a few generations, computers have invaded every conceivable aspect of<a id="1232"></a> our lives, and<a id="855"></a> there is no indication that this trend is slowing.</p>
      <p>This book will help<a id="836"></a> you become familiar with<a id="967"></a> one specific programming<a id="1042"></a> tool: MATLAB<a id="1013"></a>. It is intended to<a id="1063"></a> bring you to<a id="1064"></a> a basic proficiency level so that you can confidently proceed on<a id="1004"></a> your own to<a id="1065"></a> learn the features of<a id="1233"></a> other programming<a id="104<a id="1214"></a>3"></a> languages that are useful to<a id="1066"></a> your interests.</p>
      <p>A word of<a id="1234"></a> caution: Learning a programming<a id="1044"></a> language is very much like learning to<a id="1067"></a> speak a foreign language. In order to<a id="1068"></a> find something to<a id="1069"></a> eat in Munich, you must be able to<a id="1070"></a> express yourself in terms a German can understand. This involves knowing not only some vocabulary words, but also the grammatical rules that make those words comprehensible&mdash; in German, for<a id="1400"></a> example<a id="1360"></a>, this means putting the verbs at the ends of<a id="1235"></a> phrases.</p>
      <p>If languages were a strictly theoretical exercise, you could make up your own vocabulary and<a id="856"></a> grammar, and<a id="857"></a> it would undoubtedly be an improvement over existing languages&mdash;especially English, with<a id="968"></a> its incredibly complex spelling and<a id="858"></a> pronunciation rules. However, language is not a theoretical exercise; it is a practical tool for<a id="1401"></a> communication, so we can&rsquo;t make up our own rules, but are constrained to<a id="1071"></a> the vocabulary and<a id="859"></a> grammar expected by the people with<a id="969"></a> whom we want to<a id="1072"></a> converse.</p>
      <p>Similarly, this book is not an abstract text<a id="1378"></a> about the nature<a id="840"></a> of<a id="1236"></a> computer languages. It is a practical guide to<a id="1073"></a> creating<a id="831"></a> solutions to<a id="1074"></a> problems. Accomplishing this involves expressing your solutions in such a form that the computer can &ldquo;understand&rdquo; your solutions; therefore, it requires that you use the vocabulary (i.e., the appropriate key words) and<a id="860"></a> grammar (the syntax) of<a id="1237"></a> the language.</p>
      <p>To become proficient in this, as in any other language, it is not enough to<a id="1075"></a> merely know the grammar and<a id="861"></a> vocabulary. You have to<a id="1076"></a> practice your language skills by communicating. For foreign languages, this means traveling to<a id="1077"></a> the country, immersing yourself in the culture, and<a id="862"></a> talking with<a id="970"></a> people. For computer languages, this means actually writing<a id="849"></a> programs, seeing what they do, and<a id="863"></a> determining how to<a id="1078"></a> use their capabilities to<a id="1079"></a> solve your engineering<a id="789"></a> problems.</p>
    </div>
  </div>

  <div class="chp-section" data-sect-num="2" data-sect-name="History of Computer Architectures">
    <!-- History of Computer Architectures -->
    <h2 id="1_2">1.2 History of<a id="1238"></a> Computer Architectures</h2>
    <div class="container">
      <p>Computing concepts developed as tools to<a id="1080"></a> solve previously intractable problems. This section will trace the growth of<a id="1239"></a> computing architectures, review the basic organization of<a id="1240"></a> computer hardware components, and<a id="864"></a> emphasize the implementation<a id="1218"></a> of<a id="1241"></a> the data<a id="1023"></a> storage and<a id="865"></a> processing<a id="834"></a> capabilities by highlighting three milestones on<a id="1005"></a> the road to<a id="1081"></a> today&rsquo;s computers: Babbage&rsquo;s difference engine, Colossus, and<a id="866"></a> the von<a id="1391"></a> Neumann architecture.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Babbage's Difference Engine">
      <!-- Babbage Difference Engine -->
      <h3 id="1_2_1">1.2.1 Babbage's Difference Engine</h3>
      <div class="container clearfix">
        <div class="float-sm-right card">
          <img src="..\Images\Fig_1_1.JPG" alt="Figure 1.1" class="fig card-image">
          <p class="figure-name card-title">Figure<a id="1424"></a> 1.1: Babbage&rsquo;s Difference Engine</p>
        </div>
        <p>Charles Babbage (1791&ndash;1871) is generally recognized as the earliest pioneer of<a id="1242"></a> the modern computer. Babbage&#39;s <b>difference engine,</b> a relatively simple device that can subtract adjacent values in a column of<a id="1243"></a> numbers<a id="1061"></a>&mdash;is a good example<a id="1361"></a> of<a id="1244"></a> a computing device designed to<a id="1082"></a> improve the speed and<a id="867"></a> repeatability of<a id="1245"></a> mathematical operations<a id="1211"></a>. Babbage was concerned about the process engineers used to<a id="1083"></a> develop the tables of<a id="1246"></a> logarithms and<a id="868"></a> trigonometric functions<a id="1374"></a>. In his day, the only way to<a id="1084"></a> develop these tables was for<a id="1402"></a> mathematicians to<a id="1085"></a> calculate the values in the tables by hand. Sadly, the manufacturing tools and<a id="869"></a> materials available then prevented him from<a id="801"></a> actually building<a id="782"></a> his machine. However, in 1991 the Science Museum in London built a machine to<a id="1086"></a> his specifications, as shown in Figure<a id="1425"></a> 1.1. With only minor changes to<a id="1087"></a> the design, they were able to<a id="1088"></a> make the machine work. Although limited in its flexibility, the machine was able to<a id="1089"></a> compute difference equations up to<a id="1090"></a> the seventh order with<a id="971"></a> up to<a id="1091"></a> 13 significant digits.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Colossus">
      <!-- Colossus -->
      <h3 id="1_2_2">1.2.2 Colossus</h3>
      <div class="container">
        <p>Colossus was a computing machine developed to<a id="1092"></a> solve large, complex problems quickly. Early in the Second World War, Britain was losing the Battle of<a id="1247"></a> the Atlantic&mdash;German U-boats were sinking an enormous number of<a id="1248"></a> cargo ships that were resupplying the Allied war effort. The Government Code and<a id="870"></a> Cypher School was established at Bletchley Hall in Britain with<a id="972"></a> the goal of<a id="1249"></a> breaking<a id="1396"></a> the German codes used to<a id="1093"></a> communicate with<a id="973"></a> their U-boats in the North Atlantic. They were using Enigma machines, relatively simple devices that encrypted messages by shifting characters in the alphabet. However, to<a id="1094"></a> crack the code they needed to<a id="1095"></a> exhaustively evaluate text<a id="1379"></a> shifted by arbitrary amounts. Although the algorithm<a id="772"></a> was known, the manual solution took too long, and<a id="871"></a> it was often too late to<a id="1096"></a> make use of<a id="1250"></a> the information. A computer later named Colossus was designed by Max Newman and<a id="872"></a> was custom built for<a id="1403"></a> this purpose. While not a general-purpose processor, Colossus was fast enough to<a id="1097"></a> crack all but the most sophisticated Enigma codes. Sadly, due to<a id="1098"></a> security concerns, the machine was destroyed when the war ended. However, the dawn of<a id="1251"></a> ubiquitous computing was breaking<a id="1397"></a>, and<a id="873"></a> general-purpose computers were soon to<a id="1099"></a> be available.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="The von Neumann Architecture">
      <!-- von Neumann Architecture -->
      <h3 id="1_2_3">1.2.3 The von<a id="1392"></a> Neumann Architecture</h3>
      <div class="container clearfix">
        <div class="float-sm-right card">
          <img src="..\Images\Fig_1_2.JPG" alt="Figure 1.2" class="fig card-image">
          <p class="figure-name card-title">Figure<a id="1426"></a> 1.2: The von<a id="1393"></a> Neumann Architecture</p>
        </div>
        <p pbzloc="7">These and<a id="874"></a> other contemporary achievements demonstrated the ability of<a id="1252"></a> special-purpose machines to<a id="1100"></a> solve specific problems. However, the creativity of<a id="1253"></a> John von<a id="1394"></a> Neumann ushered in the current era of<a id="1254"></a> general-purpose computing in which computers are flexible enough to<a id="1101"></a> solve an astonishing array<a id="774"></a> of<a id="1255"></a> different problems. Dr. von<a id="1395"></a> Neumann proposed a computer architecture that separated the Central Processing Unit (CPU) from<a id="802"></a> the computer memory and<a id="875"></a> the Input/Output<a id="851"></a> (I/O) devices (see Figure<a id="1427"></a> 1.2).</p>
        <p>Together with<a id="974"></a> binary<a id="779"></a> encoding for<a id="1404"></a> storing numerical<a id="1195"></a> values, this was the genesis of<a id="1256"></a> general-purpose computing as we know it today. Although the implementation<a id="1219"></a> of<a id="1257"></a> each component has improved beyond recognition, the fundamental processing<a id="835"></a> architecture remains unchanged today.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="3" data-sect-name="Modern Computer Software">
    <!-- Modern Computer Software -->
    <h2 id="1_3">1.3 Modern Computer Software</h2>
    <div class="container">
      <p>Computer software contains the instructions that the CPU uses to<a id="1102"></a> run programs. There are several important categories of<a id="1258"></a> software, including operating<a id="1198"></a> systems, software applications, and<a id="876"></a> language compilers<a id="787"></a>. Not all processors need all these facilities.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Operating Systems">
      <!-- Operating Systems -->
      <h3 id="1_3_1">1.3.1 Operating Systems</h3>
      <div class="container">
        <p>The <b>operating<a id="1199"></a> system (OS)</b> serves as the manager of<a id="1259"></a> the computer system as a whole. It controls access to<a id="1103"></a> the processor by users and<a id="877"></a> networked devices, and<a id="878"></a> it organizes the hardware and<a id="879"></a> software according to<a id="1104"></a> the users&rsquo; specifications. The operating<a id="1200"></a> system is the first major software component fetched by the BIOS from<a id="803"></a> mass storage, and<a id="880"></a> it automatically loads and<a id="881"></a> starts the myriad programs that make computers &ldquo;user<a id="1058"></a> friendly.&rdquo; It also provides the tools for<a id="1405"></a> making the computer&rsquo;s peripheral devices&mdash;such as printers, scanners, and<a id="882"></a> DVD drives&mdash;available to<a id="1105"></a> other software. Common modern operating<a id="1201"></a> systems are Microsoft Windows, Linux, UNIX, and<a id="883"></a> Apple Mac OS.</p>
        <p>Operating systems also contain a group of<a id="1260"></a> programs called <b>utilities</b> that allow you to<a id="1106"></a> perform functions<a id="1375"></a>, such as printing files, copying files from<a id="804"></a> one disk to<a id="1107"></a> another, and<a id="884"></a> listing the files that you have saved on<a id="1006"></a> a disk. Although these utilities are common to<a id="1108"></a> most operating<a id="1202"></a> systems, the commands themselves vary from<a id="805"></a> o perating system to<a id="1109"></a> operating<a id="1203"></a> system. While computer systems give the appearance of<a id="1261"></a> stability, like automobiles, they require periodic maintenance to<a id="1110"></a> maintain peak performance.</p>
        <ul>
        	<li>You should protect your computer by installing and<a id="885"></a> configuring utilities that protect it from<a id="806"></a> viruses, intrusive advertising, and<a id="886"></a> external influences that make illegal use of<a id="1262"></a> the processor or its data<a id="1024"></a>. Refer to<a id="1111"></a> the documentation<a id="788"></a> for<a id="1406"></a> your specific operating<a id="1204"></a> system.</li>
        	<li>Over time, most disk drives become fragmented&mdash;the available space gets chopped up into smaller and<a id="887"></a> smaller pieces&mdash;and<a id="888"></a> the performance of<a id="1263"></a> your system begins to<a id="1112"></a> suffer. De-fragmentation of<a id="1264"></a> a large disk drive may be an overnight effort, but should be done periodically.</li>
        	<li>While very reliable, computers are not indestructible. You should establish a regular policy of<a id="1265"></a> backing up your personal files onto removable media. Most operating<a id="1205"></a> systems provide such utilities,<a id="1384"></a> and<a id="889"></a> a number of<a id="1266"></a> services are now available at a modest cost that automatically back up your files to<a id="1113"></a> encrypted storage whenever your computer is connected to<a id="1114"></a> the Internet. You do not need to<a id="1115"></a> back up commercial software that can be reloaded from<a id="807"></a> the manufacturer&rsquo;s installation disks.</li>
        </ul>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Software Tools">
      <!-- Software Tools -->
      <h3 id="1_3_2">1.3.2 Software Tools</h3>
      <div class="container">
        <p>Software tools are commercial programs that have been written to<a id="1116"></a> solve specific problems. They are highly sophisticated, complex applications that use the facilities provided by the operating<a id="1206"></a> system to<a id="1117"></a> enable you to<a id="1118"></a> create, save, recall, manipulate, and<a id="890"></a> present ideas in the form of<a id="1267"></a> data<a id="1025"></a> files on<a id="1007"></a> your computer. The specific nature<a id="841"></a> of<a id="1268"></a> those files depends on<a id="1008"></a> the nature<a id="842"></a> of<a id="1269"></a> the problem. If you need a well-formatted document or report, <b>word processors</b> are programs that enable you to<a id="1119"></a> enter and<a id="891"></a> format<a id="838"></a> text<a id="1380"></a> and<a id="892"></a> graphics. They allow you to<a id="1120"></a> develop documents in outline form; move words, sentences, and<a id="893"></a> paragraphs; and<a id="894"></a> check your spelling and<a id="895"></a> grammar. <b>Desktop publishing</b> combines a very powerful word processor with<a id="975"></a> a high-quality printer to<a id="1121"></a> produce professional-grade documents.</p>
        <p>If you need sophisticated results from<a id="808"></a> tabular data<a id="1026"></a>, <b>spreadsheets<a id="1366"></a></b> let you work easily with<a id="976"></a> data<a id="1027"></a> that can be displayed in a grid<a id="829"></a> of<a id="1270"></a> rows and<a id="896"></a> columns. Most spreadsheet<a id="793"></a> packages include plotting capabilities to<a id="1122"></a> create charts and<a id="897"></a> graphs<a id="792"></a>, so they can be especially useful in analyzing and<a id="898"></a> displaying<a id="837"></a> information.</p>
        <p>If you need to<a id="1123"></a> store, quickly retrieve, and<a id="899"></a> format<a id="839"></a> large amounts of<a id="1271"></a> data<a id="1028"></a>, <b>database management</b> programs are useful tools. They are used by large organizations, such as banks, hospitals, universities, hotels, and<a id="900"></a> airlines, to<a id="1124"></a> store and<a id="901"></a> organize crucial information; they are also used to<a id="1125"></a> analyze large amounts of<a id="1272"></a> scientific data<a id="1029"></a>. Meteorology and<a id="902"></a> oceanography are ex amples of<a id="1273"></a> scientific fields that commonly require large databases for<a id="1407"></a> the storage and<a id="903"></a> analysis of<a id="1274"></a> data<a id="1030"></a>. Computer-aided design (CAD) packages let you define computer models of<a id="1275"></a> real-world objects<a id="1197"></a>, assemble groups of<a id="1276"></a> such models, and<a id="904"></a> then manipulate them graphically. CAD packages are frequently used in engineering<a id="790"></a> applications, and<a id="905"></a> the designs of<a id="1277"></a> most automobiles and<a id="906"></a> aircraft are now &ldquo;paperless&rdquo;&mdash;the essential information is in a CAD database rather than on<a id="1009"></a> paper.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Programming Languages">
      <!-- Programming Languages -->
      <h3 id="1_3_3">1.3.3 Programming Languages</h3>
      <div class="container">
        <p>All programming<a id="104<a id="1215"></a>5"></a> languages are merely tools a programmer uses to<a id="1126"></a> express the logic<a id="997"></a> for<a id="1408"></a> a computer to<a id="1127"></a> implement. Like any spoken language, a computer language is defined<a id="832"></a> by its grammar (syntax) and<a id="907"></a> its vocabulary. There are three necessary attributes of<a id="1278"></a> a computer language: the scope of<a id="1279"></a> the logic<a id="998"></a> expressed in each line of<a id="1280"></a> code (the <strong>power</strong> of<a id="1281"></a> the language), the <strong>clarity </strong>of<a id="1282"></a> each line of<a id="1283"></a> code from<a id="809"></a> the human viewpoint, and<a id="908"></a> its <strong>portability </strong>between different types<a id="845"></a> of<a id="1284"></a> processor. Computer languages are frequently described in terms of<a id="1285"></a> <strong>generations </strong>that reflect the development of<a id="1286"></a> language power, clarity, and<a id="909"></a> portability.</p>
        <p><strong>First-generation</strong>, or machine languages, are the most primitive languages, usually tied closely to<a id="1128"></a> the nature<a id="843"></a> of<a id="1287"></a> the computer hardware. Since the basic logic<a id="999"></a> of<a id="1288"></a> the CPU is binary<a id="780"></a>, the syntax of<a id="1289"></a> machine language is expressed as sequences of<a id="1290"></a> 0s and<a id="910"></a> 1s. This maximizes the control over the processor, but results in programs that are completely incomprehensible to<a id="1129"></a> anyone, including the original programmer, and<a id="911"></a> are absolutely not portable.</p>
        <p>A <strong>second-generation </strong>language, frequently called assembly language, is a means of<a id="1291"></a> expressing machine language in symbolic form where each line of<a id="1292"></a> code usually produces a single machine instruction. While programming<a id="1046"></a> in assembly language is easier than machine language, it is still a tedious process that requires each detailed instruction to<a id="1130"></a> be specified; and<a id="912"></a> like the first-generation languages, it is completely tied to<a id="1131"></a> the nature<a id="844"></a> of<a id="1293"></a> the CPU.</p>
        <p><strong>Third-generation </strong>languages such as C, FOR<a id="1212"></a>TRAN, and<a id="913"></a> BASIC have commands and<a id="914"></a> instructions that are more similar to<a id="1132"></a> spoken languages. One line of<a id="1294"></a> code of<a id="1295"></a> these languages creates many machine level instructions. Consequently, they are much clearer expressions of<a id="1296"></a> the logic<a id="1000"></a> of<a id="1297"></a> a program, and<a id="915"></a> the power of<a id="1298"></a> each instruction is significantly increased. The resulting programs are to<a id="1133"></a> some degree portable between processor types<a id="846"></a>. Third- generation languages and<a id="916"></a> beyond are referred to<a id="1134"></a> as high-level languages.</p>
        <p>The <strong>fourth-generation </strong>languages that include Ada and<a id="917"></a> Java take this trend to<a id="1135"></a> the next level. They are completely portable between supported processor types<a id="847"></a>, and<a id="918"></a> each line of<a id="1299"></a> code creates a significant amount of<a id="1300"></a> machine instructions. MATLAB<a id="1014"></a> and<a id="919"></a> its close<a id="783"></a> competitors, Mathematica, Mathcad, and<a id="920"></a> Maple, are very powerful fourth-generation languages that combine mathematical functions<a id="1376"></a> and<a id="921"></a> commands with<a id="977"></a> extensive capabilities for<a id="1409"></a> presenting results in a graphical form. This combination of<a id="1301"></a> computation and<a id="922"></a> visualization power makes them particularly useful tools for<a id="1410"></a> engineers.</p>
        <p>The current language development trend is to<a id="1136"></a> allow the programmer to<a id="1137"></a> express the overall program logic<a id="1001"></a> in a graphical form and<a id="923"></a> have the programming<a id="1047"></a> tools automatically convert the diagrams to<a id="1138"></a> working programs. Programmers involved with<a id="978"></a> these implementations still need language skills to<a id="1139"></a> complete the implementation<a id="1220"></a> of<a id="1302"></a> the algorithms. The goal of<a id="1303"></a> the fifth generation of<a id="1304"></a> languages is to<a id="1140"></a> allow a programmer to<a id="1141"></a> use natural language. Programmers in this generation would program in the syntax of<a id="1305"></a> natural speech. Implementation of<a id="1306"></a> a fifth-generation language will require the achievement of<a id="1307"></a> one of<a id="1308"></a> the grand challenges of<a id="1309"></a> computer science: computerized speech understanding.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="4" data-sub-name="Running a Computer Program">
      <!-- Running a Computer Program -->
      <h3 id="1_3_4">1.3.4 Running a Computer Program</h3>
      <div class="container">
        <p>For most computer languages, making the program run involves compilation, linking, loading, and<a id="924"></a> then executing the program.</p>
        <p><strong>Compilation</strong>: Programs written in most high-level languages, such as C or Java, need to<a id="1142"></a> be compiled (i.e., translated into machine language) before the instructions can be executed by the computer. A special program called a <strong>compiler </strong>performs this translation. Thus, in order to<a id="1143"></a> write and<a id="925"></a> execute C programs on<a id="1010"></a> a computer, the computer&rsquo;s software must include a C compiler. If any errors are detected by the compiler during compilation, the compiler generates corresponding error messages. Programmers must correct the program statements and<a id="926"></a> then perform the compilation step again. The errors identified during this stage are called <strong>compile-time errors<a id="786"></a></strong>. For example<a id="1362"></a>, if you want to<a id="1144"></a> divide the value<a id="1385"></a> stored in a variable<a id="1386"></a> called sum by 3, the correct expression in C is <code>sum/3;</code>. If you incorrectly write the expression using the backslash, as in <code>sum\3;</code>, you will get a compiler error. For non-trivial programs, the process of<a id="1310"></a> correcting statements (or debugging<a id="1359"></a>) and<a id="927"></a> recompiling often must be repeated several times before the program compiles without compiler errors. When there are no compiler errors, the compiler generates a program in machine language that performs the steps specified by the original C program. The original C program is referred to<a id="1145"></a> as the source code, and<a id="928"></a> the machine-language version is called the object code. Thus, the source code and<a id="929"></a> the object code specify the same logic<a id="1002"></a>, but the source code is specified in a high- level language and<a id="930"></a> the object code is specified in machine language.</p>
        <p><strong>Linking</strong>: Once the program has compiled correctly, additional steps are necessary to<a id="1146"></a> prepare the object code for<a id="1411"></a> execution<a id="794"></a>. A <strong>linker<a id="994"></a> </strong>will search libraries of<a id="1311"></a> built-in capabilities required by this program and<a id="931"></a> collect them in a single executable file stored on<a id="1011"></a> the hard drive. Errors generated in this phase are typically caused by the programmer referring to<a id="1147"></a> program modules that are not, in fact, defined<a id="833"></a> in the current context.</p>
        <p><strong>Loading</strong>: A loader<a id="996"></a> is then used to<a id="1148"></a> copy the executable program into memory where its instructions can be executed by the computer.</p>
        <p><strong>Execution</strong>: New errors, synonymously called <strong>execution<a id="795"></a> errors, runtime<a id="1357"></a> errors, logic<a id="1003"></a> errors</strong>, or <strong>program bugs<a id="1213"></a></strong>, may be identified in this stage. Execution errors often cause the termination of<a id="1312"></a> a program. For example<a id="1363"></a>, the program statements may attempt to<a id="1149"></a> perform a division<a id="775"></a> by zero, which usually generates an execution<a id="796"></a> error. Some execution<a id="797"></a> errors, however, do not stop the program from<a id="810"></a> executing, but they cause incorrect results to<a id="1150"></a> be computed. These types<a id="848"></a> of<a id="1313"></a> errors can be caused by programmer errors in determining the correct steps in the solutions and<a id="932"></a> by errors in the data<a id="1031"></a> processed by the program. When execution<a id="798"></a> errors occur because of<a id="1314"></a> errors in the program statements, you must correct th e errors in the source program and<a id="933"></a> then begin again with<a id="979"></a> the compilation step. Even when a program appears to<a id="1151"></a> execute properly, you must check the results carefully to<a id="1152"></a> be sure that they are correct. The computer will perform the steps precisely as you specify them. If you specify the wrong steps, the computer will execute these wrong (but syntactically legal) steps and<a id="934"></a> present you with<a id="980"></a> an answer that is incorrect.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="5" data-sub-name="Running an Interpreted Program">
      <!-- Running an Interpreted Program -->
      <h3 id="1_3_5">1.3.5 Running an Interpreted Program</h3>
      <div class="container">
        <p>An interpreted<a id="963"></a> language is one that does not appear to<a id="1153"></a> require compilation. Rather, the environment in which it is used gives the user<a id="1059"></a> the impression that the instructions are taken one at a time and<a id="935"></a> executed directly. The advantage of<a id="1315"></a> interpreted<a id="964"></a> code is that the programmer can run programs a line at a time or from<a id="811"></a> a stored text<a id="1381"></a> file, see the results immediately, and<a id="936"></a> apply a number of<a id="1316"></a> tools to<a id="1154"></a> find out why the results were not as expected. Programmers can rapidly develop and<a id="937"></a> execute programs (scripts) that contain commands and<a id="938"></a> executable instructions that allow them to<a id="1155"></a> gather data<a id="1032"></a>, perform calculations, observe the results, and<a id="939"></a> then execute other scripts<a id="1358"></a>. This interactive environment does not require the formal<a id="800"></a> compilation, linking/loading, and<a id="940"></a> execution<a id="799"></a> process described earlier for<a id="1412"></a> high-level computer languages.</p>
        <p pbzloc="8">The disadvantages of<a id="1317"></a> interpreted<a id="965"></a> code are numerous. The code is often very slow to<a id="1156"></a> run relative to<a id="1157"></a> compiled code because every line must be syntactically analyzed at run-time. In order to<a id="1158"></a> reduce the impact of<a id="1318"></a> this as much as possible, the interpreter will often make use of<a id="1319"></a> a compilation step that is hidden from<a id="812"></a> users. Also, because there is no explicit compilation step, the programmer does not have the compiler&rsquo;s protection from<a id="813"></a> syntax errors. Typographical errors that cause unknown assets to<a id="1159"></a> be referenced from<a id="814"></a> a program cannot be caught by the linker<a id="995"></a>. In fact, all programming<a id="1048"></a> errors&mdash;syntactic, typographical<a id="1383"></a>, and<a id="941"></a> logical<a id="776"></a>&mdash;are postponed until the moment the interpreter tries to<a id="1160"></a> deal with<a id="981"></a> the offending line of<a id="1320"></a> code. They all become run-time errors.</p>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="4" data-sect-name="Anticipated Outcomes">
    <!-- Anticipated Outcomes -->
    <h2 id="1_4">1.4 Anticipated Outcomes</h2>
    <div class="container">
      <p>To conclude this chapter, we list in increasing order of<a id="1321"></a> importance three outcomes for<a id="1413"></a> a diligent student: a brief introduction<a id="1040"></a> to<a id="1161"></a> MATLAB<a id="1015"></a>, some understanding of<a id="1322"></a> programming<a id="1049"></a> concepts, and<a id="942"></a> improvement in their problem-solving<a id="1041"></a> skills.</p>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Introduction to MATLAB">
      <!-- Intro to MATLAB -->
      <h3 id="1_4_1">1.4.1 Introduction to<a id="1162"></a> MATLAB<a id="1016"></a></h3>
      <div class="container">
        <p>MATLAB<a id="1017"></a> is a highly successful engineering<a id="791"></a> programming<a id="1050"></a> language that includes not only the capabilities needed in this text<a id="1382"></a> to<a id="1163"></a> introduce programming<a id="1051"></a> to<a id="1164"></a> novices, but also a vast collection of<a id="1323"></a> tools in toolboxes that enable professional engineers to<a id="1165"></a> be highly productive. It is very likely that you will encounter MATLAB<a id="1018"></a> in your career as an engineer. Th e concepts you learn in this book will ensure that you know what to<a id="1166"></a> do when faced with<a id="982"></a> a MATLAB<a id="1019"></a> program.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Learning Programming Concepts">
      <!-- Learning Programming Concepts -->
      <h3 id="1_4_2">1.4.2 Learning Programming Concepts</h3>
      <div class="container">
        <p>Even if you never see MATLAB<a id="1020"></a> again, you will certainly either need to<a id="1167"></a> use other programming<a id="105<a id="1216"></a>2"></a> languages or be able to<a id="1168"></a> converse effectively with<a id="983"></a> other engineers who<a id="1423"></a> do. Converting to<a id="1169"></a>, or writing<a id="850"></a> accurate specifications for<a id="1414"></a>, other languages is greatly simplified if you have a general idea of<a id="1324"></a> the capabilities of<a id="1325"></a> that language. When faced with<a id="984"></a> a different programming<a id="1053"></a> language, if the student has an understanding of<a id="1326"></a> the basic underlying programming<a id="1054"></a> concepts, the transition from<a id="815"></a> MATLAB<a id="1021"></a> to<a id="1170"></a> the new language becomes just one question&mdash;&ldquo;How do I express the concepts I need in the new language?&rdquo; We therefore have chosen to<a id="1171"></a> explain each programming<a id="1055"></a> concept in a language-independent way before discussing the MATLAB<a id="1022"></a> implementation<a id="1221"></a> of<a id="1327"></a> that concept.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Problem-Solving Skills">
      <!-- Problem-Solving Skills -->
      <h3 id="1_4_3">1.4.3 Problem-Solving Skills</h3>
      <div class="container clearfix">
        <div class="float-sm-right card">
          <img src="..\Images\Fig_1_3.JPG" alt="Figure 1.3" class="fig card-image">
          <p class="figure-name card-title">Figure<a id="1428"></a> 1.3: Problem Solving Strategy</p>
        </div>
        <p>More important even than the computing concepts inherent in all computer languages is the ability to<a id="1172"></a> use those concepts as tools to<a id="1173"></a> solve a problem. Before we even start to<a id="1174"></a> program, we have to<a id="1175"></a> develop an idea of<a id="1328"></a> how to<a id="1176"></a> solve the problem before us. If we think about a computer program as a logical<a id="777"></a> component that co nsumes data<a id="1033"></a> in one form and<a id="943"></a> produces data<a id="1034"></a> in another, we can think about problem solving as the process of<a id="1329"></a> desi gning a collection of<a id="1330"></a> solutions to<a id="1177"></a> sub-problems. A brief illustration and<a id="944"></a> example<a id="1364"></a> will suffice. In general terms, solutions to<a id="1178"></a> nontrivial problems are found by the two-pronged approach illustrated in Figure<a id="1429"></a> 1.3. We can consider the original information and<a id="945"></a> ask ourselves what could be done with<a id="985"></a> that information using existing tools, and<a id="946"></a> we can also consider the objective and<a id="947"></a> the different ways in which that objective might be achieved. The process of<a id="1331"></a> creative problem solving then becomes a search for<a id="1415"></a> a match between states that can be reached from<a id="816"></a> the given data<a id="1035"></a> and<a id="948"></a> states from<a id="817"></a> which the answer can be reached.</p>
        <p>For example<a id="1365"></a>, say you have a big collection of<a id="1332"></a> baseball cards and<a id="949"></a> you want to<a id="1179"></a> find the names<a id="1387"></a> of<a id="1333"></a> the 10 &ldquo;qualified&rdquo; players with<a id="986"></a> the highest lifetime batting averages. To qualify, the players must have been in the league at least five years, had at least 100 plate appearances per year, and<a id="950"></a> made fewer than 10 errors per year. The cards contain all the relevant information for<a id="1416"></a> each player. You just have to<a id="1180"></a> organize the cards to<a id="1181"></a> solve the problem. Clearly there are a number of<a id="1334"></a> steps between the stack<a id="1367"></a> of<a id="1335"></a> cards and<a id="951"></a> the solution. In no particular order, these are:</p>
        <ol type="a">
        	<li>Write down the names<a id="1388"></a> of<a id="1336"></a> the players from<a id="818"></a> some cards</li>
        	<li>Sort the stack<a id="1368"></a> of<a id="1337"></a> cards by the lifetime batting average</li>
        	<li>Select all players from<a id="819"></a> the stack<a id="1369"></a> with<a id="987"></a> five years or more in the league</li>
        	<li>Select all players from<a id="820"></a> the stack<a id="1370"></a> with<a id="988"></a> fewer than 10 errors per year</li>
        	<li>Select all players from<a id="821"></a> the stack<a id="1371"></a> with<a id="989"></a> over 100 plate appearances per year</li>
        	<li>Keep the first 10 players from<a id="822"></a> the stack<a id="1372"></a></li>
        </ol>
        <p>When you think about it from<a id="823"></a> right to<a id="1182"></a> left as shown in Figure<a id="1430"></a> 1.3, step a is probably the last step and<a id="952"></a> step f is probably the step before that. The hard work starts when you think about it from<a id="824"></a> left to<a id="1183"></a> right. Intuitively, when you think about sorting<a id="784"></a> the stack<a id="1373"></a> of<a id="1338"></a> cards, this seems like a lengthy process. Since the so rting should probably be done on<a id="1012"></a> a small number of<a id="1339"></a> cards, you should do all the selecting before the sorting<a id="785"></a>. Continuing that line of<a id="1340"></a> reasoning, you would reduce the total effort if the first selection pass was the criterion that eliminated most cards. You might even consider combining all three selection steps into one. One logical<a id="778"></a> way to<a id="1184"></a> find the players&#39; names<a id="1389"></a> that you need would be to<a id="1185"></a> perform the steps in this order: c, d, and<a id="953"></a> e in any order, followed by b, f, and<a id="954"></a> then a.</p>
      </div>
    </div>
  </div>

  <!-- Chapter Summary -->
  <h2>Chapter Summary</h2>
  <div class="container">
    <p>This chapter presented an overview<a id="1223"></a> of<a id="1341"></a> the historical background of<a id="1342"></a> computing and<a id="955"></a> the computer hardware and<a id="956"></a> software concepts that build the foundation for<a id="1417"></a> the rest of<a id="1343"></a> this book:</p>
    <ul>
    	<li>The spectrum of<a id="1344"></a> software products, ranging from<a id="825"></a> operating<a id="1207"></a> systems to<a id="1186"></a> the many flavors of<a id="1345"></a> specific programming<a id="1056"></a> tools.</li>
    	<li>The rich variety of<a id="1346"></a> programming<a id="105<a id="1217"></a>7"></a> languages currently in use, and<a id="957"></a> the place of<a id="1347"></a> interpreted<a id="966"></a> programs in that spectrum as a legitimate fourth-generation language.</li>
    	<li>The basics of<a id="1348"></a> problem solving as a search for<a id="1418"></a> a path from<a id="826"></a> the data<a id="1036"></a> provided to<a id="1187"></a> the answers required.</li>
    </ul>
  </div>

  <!-- Self Test -->
  <h2>Self Test</h2>
  <div class="container">
    <p>Use the following questions to<a id="1188"></a> check your understanding of<a id="1349"></a> the material in this chapter:</p>

    <h3>True or False</h3>
    <ol>
    	<li>Computers were originally conceived as tools for<a id="1419"></a> solving specific problems.</li>
    	<li>Bill Gates designed the first working computer.</li>
    	<li>Programs cannot interact with<a id="990"></a> the world outside the computer without an operating<a id="1208"></a> system.</li>
    	<li>Programs cannot interact with<a id="991"></a> the world outside the computer without drivers.</li>
    	<li>Programs cannot interact with<a id="992"></a> the world outside the computer without hardware interfaces.</li>
    	<li>Application programs have access to<a id="1189"></a> shared memory.</li>
    	<li>An algorithm<a id="773"></a> bridges the gap between the available data<a id="1037"></a> and<a id="958"></a> the result to<a id="1190"></a> be achieved.</li>
    </ol>

    <h3>Fill in the Blanks</h3>
    <ol>
    	<li>A computer language is not a(n) ______________ exercise; it is a_____________tool for<a id="1420"></a> communication and<a id="959"></a> problem solving.</li>
    	<li>Together with<a id="993"></a> the use of<a id="1350"></a> binary<a id="781"></a> encoding for<a id="1421"></a> storing numerical<a id="1196"></a> values, __________________ was the genesis of<a id="1351"></a> general-purpose computing as we know it today.</li>
    	<li>Most operating<a id="1209"></a> systems today use___________________, which is actually a data<a id="1038"></a> file containing an image<a id="1224"></a> of<a id="1352"></a> everything you would like to<a id="1191"></a> have in RAM.</li>
    	<li>Operating systems contain a group of<a id="1353"></a> programs ___________ _____that allow you to<a id="1192"></a> perform functions<a id="1377"></a>, such as printing, copying files, and<a id="960"></a> listing the file names<a id="1390"></a>.</li>
    	<li>Many are loaded automatically when the operating<a id="1210"></a> system starts, and<a id="961"></a> others are loaded upon user<a id="1060"></a> request.</li>
    	<li>Even when a program appears to<a id="1193"></a> execute properly, you must check the results carefully to<a id="1194"></a> find errors.</li>
    	<li>Problem solving is the process of<a id="1354"></a> designing a collection of<a id="1355"></a> ____________.</li>
    	<li>The process of<a id="1356"></a> problem solving is a search for<a id="1422"></a> a match between _____________________one can achieve from<a id="827"></a> the given data<a id="1039"></a> and<a id="962"></a> __________________from<a id="828"></a> which the answer can be achieved.</li>
    </ol>
  </div>
</div>


</body>
</html>

