<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<meta name="GENERATOR" content="PageBreeze Free HTML Editor (http://www.pagebreeze.com)">
<meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-1" >
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
<link rel="stylesheet" href="styles/styles.css" />
<title>Preface</title>
</head>
<body>
<div>#top_nav#</div>
<div class="nav-obj">#nav_obj#</div>
<div class="content">
	<h1 align="center">Preface</h1>

	<p style="margin-left: 40px; margin-right: 40px"><q cite="Laurence Sterne (1713â€“1768), British author, clergyman">That <a id="479"></a><a id="491"></a><a id="503"></a><a id="515"></a>of all the several ways <a id="480"></a><a id="492"></a><a id="504"></a><a id="516"></a>of beginning a book which are now in practice throughout the known world, I am confident my own way <a id="481"></a><a id="493"></a><a id="505"></a><a id="517"></a>of doing it is the best&mdash;I&rsquo;m sure it is the most religious&mdash;for I begin <a id="379"></a><a id="391"></a>with <a id="367"></a><a id="549"></a>writing the first sentence, and trusting <a id="422"></a>to Almighty God for the rest. </q></p>

	<p style="text-align: right; margin-right: 40px">Laurence Sterne (1713&ndash;1768), British author, clergyman<br>
	</p>

	<p>This book introduces the power, satisfaction, and joy <a id="482"></a><a id="494"></a><a id="506"></a><a id="518"></a>of computing <a id="423"></a>to beginning <a id="322"></a>engineering students who have little or no previous computing experience. It began as a snapshot <a id="483"></a><a id="495"></a><a id="507"></a><a id="519"></a>of the content <a id="484"></a><a id="496"></a><a id="508"></a><a id="520"></a>of a Georgia Tech course that introduces engineers <a id="424"></a>to computing. However, it has been extensively enhanced <a id="425"></a>to meet the needs <a id="485"></a><a id="497"></a><a id="509"></a><a id="521"></a>of a wider audience <a id="486"></a><a id="498"></a><a id="510"></a><a id="522"></a>of students and educators who want <a id="426"></a>to understand programming for other reasons. In this book, <a id="427"></a>to understand computing, we use the basic syntax and capabilities <a id="487"></a><a id="499"></a><a id="511"></a><a id="523"></a>of <a id="406"></a>MATLAB, a user-friendly language that is emerging as one <a id="488"></a><a id="500"></a><a id="512"></a><a id="524"></a>of the most popular computing languages in <a id="323"></a>engineering. We also recognize that a programming language merely exists as an imperfect medium by which we express solutions <a id="428"></a>to problems. Like any other language, if a programming language is not used continually, any skill temporarily acquired will be lost. The course for which this book is offered as a resource is taught <a id="429"></a>to freshmen in most Engineering schools. The author was approached by a faculty member whose primary audience was college seniors.  After the usual introductions, the faculty member made the observation that we must be doing something wrong because his students did not know how <a id="430"></a>to program. This observation seemed <a id="431"></a>to be at odds <a id="380"></a><a id="392"></a>with the course evaluation strategy whereby a student could not pass the class without successfully <a id="368"></a><a id="550"></a>writing programs that solved non-trivial problems. So I asked how much programming the students in that discipline used during their sophomore and junior years, and was told that in those years, the students were too busy <a id="381"></a><a id="393"></a>with their core <a id="308"></a>classes <a id="432"></a>to exercise their programming skills.</p>

	<h1>Text Books Past, Present and Future</h1>

	<p>In the past, a number <a id="489"></a><a id="501"></a><a id="513"></a><a id="525"></a>of paper editions <a id="490"></a><a id="502"></a><a id="514"></a><a id="526"></a>of this <a id="537"></a>text were printed by Pearson Addison Wesley, and I will always be grateful for the support provided by their staff over the years driving this <a id="538"></a>text towards the goal of helping students <a id="433"></a>to learn how to solve problems by <a id="369"></a><a id="551"></a>writing programs. The lasting legacy <a id="336"></a><a id="434"></a>from the paper editions was a collection of files containing the textual material and the fixed <a id="359"></a><a id="535"></a>images and listings illustrating the material. <br>
	This edition is the first of two &quot;giant steps for mankind&quot; moving completely away <a id="337"></a><a id="435"></a>from paper <a id="539"></a>text books to Web-based reference material.

	<p>We will of course be able to use <a id="312"></a><a id="360"></a><a id="362"></a>color and animations whenever appropriate</p>

	<p>We are no longer page limited by paper constraints of page <a id="558"></a>size and layout and the total page count.</p>

	<h1>Important Attributes that survive the Transition</h1>

	Three important features of the <a id="540"></a>text survived the transition away <a id="338"></a><a id="436"></a>from paper: the pedagogical style, the philosophy of teaching and the use of graphics to illustrate code features:</p>


	<h2>1. Pedagogical Style</h2>

	<p>Computing is not a spectator sport. Students learn computing by using a computing system to solve problems. This <a id="541"></a>text not only presents computing concepts and their <a id="407"></a>MATLAB <a id="468"></a>implementation, but also offers students extensive hands-<a id="455"></a>on exercises. The <a id="542"></a>text illustrates the ideas <a id="382"></a><a id="394"></a>with <a id="350"></a>examples <a id="339"></a><a id="437"></a>from the world of <a id="324"></a>engineering, provides style points, and presents sample problems that students might encounter. Each chapter includes topics that go a step beyond the basic content of an introductory class. This gives professors the choice to progress slowly, and more thoroughly, through the material in two semesters. It also offers advanced students enrichment materials for their personal study.</p>

	<h2>2. The overall philosophy</h2>
The overall philosophy of this <a id="543"></a>text approaches programming tools in the following manner:
	<ol>
		<li>Explain a computing concept in general</li>
		<li>Discuss its <a id="469"></a>implementation in <a id="408"></a>MATLAB</li>
		<li>Provide exercises to master the concept</li>
	</ol>

	<h2>3. Graphical illustrations</h2>
	<p>To <a id="354"></a>help facilitate students&rsquo; understanding of the concept and its <a id="470"></a>implementation, the <a id="544"></a>text uses two features: general templates and <a id="409"></a>MATLAB listings. The general templates provide a foundation for students to understand concepts in general and can be applied to any language. The <a id="410"></a>MATLAB listings show students how to implement concepts in <a id="411"></a>MATLAB and include detailed explanations of the code.</p>

	<h1>Features of the Text that have been Retained</h1>
	<p>Some features of the paper <a id="545"></a>text editions were retained. In some cases, they were significantly changed to take advantage of the technically advanced delivery medium.
	<p><strong>Exercises</strong>: Allow students a &ldquo;Do It Yourself&rdquo; approach to master concepts by trying what they just learned. Exercises follow each new topic.</p>

	<p><strong>Style Points</strong>: Style Points advise students about <a id="370"></a><a id="552"></a>writing quality code that is easy to understand, debug, and reuse.</p>

	<p><strong>Hints: </strong>Hints enrich students&rsquo; understanding of a topic. They are interspersed through the book at points where students may benefit <a id="340"></a><a id="438"></a>from a little extra &ldquo;aside.&rdquo;</p>

	<p><strong>Engineering Examples</strong>: Engineering Examples provide robust models and apply to real-world issues that will motivate students. Examples <a id="341"></a><a id="439"></a>from different <a id="325"></a>engineering disciplines are presented at the <a id="318"></a><a id="320"></a>end of each chapter.</p>

	<p><strong>Special Characters, Reserved Words, and Functions</strong> provide a <a id="528"></a>quick reference for the key <a id="412"></a>MATLAB principles discussed in each chapter.</p>

	<p><strong>Self Test</strong>: Self Tests <a id="355"></a>help students to check their understanding of the material in each chapter.</p>

	<p><strong>Programming Projects</strong>: Offer a variety of large-<a id="475"></a>scale projects that students can work <a id="456"></a>on to solidify their skills</p>

	<h1>Features of the Text that have been Removed</h1>
	<p>
	In the first three editions of this <a id="546"></a>text, the paper editions, we used to make available to students and lecturers a huge zip file. It contained several <a id="366"></a>types of material believed to be helpful to the teaching process. With this new, web-based edition and carefully considering how best to teach these topics, we have abandoned that zip file. </p>
	<h2>1. Solutions to selected Programming Projects</h2>
	The point of the programming projects is not to enable students to write exactly the right code, but to create their own solution to the problems.  If the solutions were available, there is a serious danger that students will look at the solution, perhaps understand how it works and copy it into a note book, believing that they have learned that kind of solution.  In fact, this short-cut to the answer has deprived the student of the opportunity to struggle <a id="383"></a><a id="395"></a>with the form and <a id="471"></a>implementation of the program that solves this problem.</p>

	<h2>2. Source code for all <a id="413"></a>MATLAB listings</h2>
	<p>Another aspect of programming is that an expert programmer rarely starts <a id="384"></a><a id="396"></a>with a blank screen. In his initial <a id="418"></a>problem solving analysis, the programmer frequently recognizes similarity to other programs he has written or that are available and documented elsewhere.  In this edition of the web-based <a id="547"></a>text, the listings are actually in scrollable <a id="561"></a>windows that allow students to copy and extract as much as they need ready to be adapted to the needs of the specific solution required.</p>

	<h2>3. Lecture slides</h2>
	<p>At the risk of kicking over some sacred cows, I have a passionate dislike for teaching programming <a id="309"></a>classes <a id="342"></a><a id="440"></a>from fixed projection media. I recall a painful experience sitting in the back of a lecture hall to observe a novice instructor. He was standing <a id="385"></a><a id="397"></a>with his back to the students, scratching his head and observing that he had no idea what that slide meant. When the teaching materials are available like a politician's teleprompter, there is an overpowering temptation to just read the slides, thereby removing <a id="343"></a><a id="441"></a>from the lecture any opportunity to demonstrate the thought processes behind solving a particular kind of problem.</p>

	<h1>Back to the Future</h1>
	<p>What <a id="317"></a>else could possibly be done in the next major release?  I mentioned earlier that one advantage of having the listings live in a window would be for a student to be able to paste code <a id="344"></a><a id="442"></a>from that window into the programming environment and then experiment <a id="386"></a><a id="398"></a>with the code and perhaps adapt it to solving a different problem. But what if that window was actually an edit/execute programming environment?  Students could then look at the listing and experiment right there <a id="387"></a><a id="399"></a>with the effect of changes.<br>
	While simple in concept, there are numerous technical and business / licensing issues that will require significant effort to overcome.</p>
	<h1>Chapter Overview</h1>

	<p>Chapter 1: <em>Introduction </em>discusses the history of <a id="314"></a>computer architectures as they apply to computing systems today. The chapter provides an <a id="474"></a>overview of computer hardware and software and how programs execute.</p>

	<p>Chapter 2: <em>Basics </em>discusses some basic concepts of computing and then introduces the basic <a id="364"></a><a id="404"></a><a id="453"></a>operation of the <a id="414"></a>MATLAB <a id="419"></a>user interface. The chapter also describes how to capture simple <a id="415"></a>MATLAB programs in the form of <a id="476"></a>scripts.</p>

	<p>Chapter 3: <em>Functions </em>describes how to implement <a id="467"></a>procedural abstraction by defining reusable code blocks.</p>

	<p>Chapter 4: <em>Vectors and Arrays </em>introduces the fundamental machinery that sets <a id="416"></a>MATLAB apart <a id="345"></a><a id="443"></a>from other languages&mdash;its ability to perform mathematical and <a id="306"></a><a id="464"></a><a id="556"></a>logical <a id="462"></a><a id="472"></a>operations <a id="457"></a>on <a id="358"></a>homogeneous <a id="310"></a>collections of <a id="421"></a>numbers.</p>

	<p>Chapter 5: <em>Execution Control </em>describes the common techniques used to control the <a id="332"></a>execution of code blocks&mdash;conditional <a id="365"></a><a id="405"></a><a id="454"></a>operation and <a id="374"></a>iteration.</p>

	<p>Chapter 6: <em>Strings </em>discusses how <a id="417"></a>MATLAB operates <a id="458"></a>on variables containing <a id="548"></a>text.</p>

	<p>Chapter 7: <em>Cell Arrays and Structures</em> discusses two kinds of <a id="357"></a>heterogeneous data <a id="311"></a>collections accessed by index and by name.</p>

	<p>Chapter 8: <em>File Input and Output </em>describes three levels of ability provided in MATLAB for transferring data to and <a id="346"></a><a id="444"></a>from data files&mdash;saving workspaces, specific tools that read and write specific data files, and general-purpose tools for <a id="353"></a>processing any kind of file.</p>

	<p>Chapter 9: <em>Recursion </em>discusses and illustrates a widely used alternative approach to repetitive code <a id="333"></a>execution.</p>

	<p>Chapter 10: <em>Principles of Problem Solving </em>introduces ideas that <a id="356"></a>help students design solutions to new problems and avoid the &ldquo;blank sheet of paper&rdquo; syndrome&mdash;how to start a program.</p>

	<p>Chapter 11: <em>Plotting </em>takes the student <a id="347"></a><a id="445"></a>from basic plotting in two dimensions to the advanced tools that draw representations of three-dimensional <a id="452"></a>objects <a id="388"></a><a id="400"></a>with smooth <a id="478"></a>shading and even multiple light effects.</p>

	<p>Chapter 12: <em>Matrices </em>describes specific MATLAB capabilities that implement <a id="420"></a>matrix algebra.</p>

	<p>Chapter 13: <em>Images </em>discusses how to use <a id="554"></a>vector and <a id="302"></a>array algebra to manipulate <a id="313"></a><a id="361"></a><a id="363"></a>color pictures.</p>

	<p>Chapter 14:&nbsp;<em>Sound </em>shows how to analyze, synthesize, and operate <a id="459"></a>on <a id="529"></a>sound files.</p>

	<p>Chapter 15: <em><a id="447"></a>Numerical Methods </em>introduces <a id="446"></a>numerical techniques that commonly occur in <a id="326"></a>engineering: <a id="373"></a><a id="451"></a>interpolation, <a id="315"></a><a id="448"></a>curve fitting, <a id="372"></a><a id="450"></a>integration, and <a id="316"></a><a id="449"></a>differentiation.</p>

	<p>Chapter 16: <em>Sorting </em>presents five algorithms for ordering <a id="466"></a>data, each of which has applicability under certain circumstances&mdash;Insertion Sort, Bubble Sort, Quick Sort, Merge Sort, and Radix Sort&mdash;and then compares their performance <a id="460"></a>on large quantities of data.</p>

	<p>Chapter 17: <em>Processing Graphs </em>discusses how to represent <a id="331"></a><a id="348"></a>graphs in general and then how to solve two important <a id="327"></a>engineering problems&mdash;finding a minimal spanning tree and finding an optimal path between two <a id="352"></a>nodes of the graph.</p>

	<p><em>Appendices </em>provide a summary of the MATLAB special characters, reserved words, and <a id="531"></a>functions used throughout the text, the <a id="301"></a>ASCII <a id="403"></a>character set, the internal number representation inside the computer, and answers to the True or False and Fill in the Blank questions.</p>

	<h1>Paths through the Book</h1>

	<p>Not all courses that cover programming and MATLAB follow the same syllabus. &ldquo;Engineering Computation <a id="389"></a><a id="401"></a>with MATLAB&rdquo; is designed to facilitate teaching the material <a id="390"></a><a id="402"></a>with different styles and at different speeds. For <a id="477"></a><a id="527"></a><a id="560"></a>example, Chapters 3, 4, and 5 cover <a id="371"></a><a id="553"></a>writing your own <a id="532"></a>functions, MATLAB <a id="303"></a>array <a id="530"></a><a id="536"></a>manipulation and <a id="375"></a>iteration. There are three schools of thought about the appropriate way to introduce these concepts. One school would introduce <a id="304"></a>array constructs first and follow up with the more &ldquo;traditional&rdquo; concept of <a id="376"></a>iteration; another would teach <a id="377"></a>iteration first and deal with the MATLAB-specific <a id="305"></a>array <a id="463"></a><a id="473"></a>operations later; and the third would treat <a id="533"></a>functions first. In practice, over the years, our course has shifted to a <a id="534"></a>functions-first approach so that we can use <a id="334"></a><a id="335"></a>function interfaces to isolate students&rsquo; code for automated code grading. However, should you prefer <a id="378"></a>iteration or arrays first, Chapters 3, 4, and 5 can be used in any order you wish. <br>
	Chapters 6&ndash;9 should be taught in sequence&mdash;there are dependencies between chapters that would make it awkward change the order. Chapter 10 is an important chapter that is difficult to place <a id="461"></a>on a class schedule. Where it stands in the book appears to be a <a id="307"></a><a id="465"></a><a id="557"></a>logical position. However, at that point in the semester, beginning students are still not ready to think about larger problems. I have usually covered this material (if at all) at the <a id="319"></a><a id="321"></a>end of each semester by way of review. Chapter 11 provides basic plotting capability and is necessary for the remaining chapters. After that, Chapters 12&ndash;17 are virtually independent and can be taught in any order, but should follow Chapters 2&ndash;11.</p>

	<h1>Supplementary Materials</h1>
	We do provide with this web-based text access to video mini-lectures created by the author and his fellow instructors Kantwon Rogers and Cedric Stallworth.  These mini-lectures allow students to observe in condensed form the process of solving problems.
	<br> These mini-lectures link the student to a vast library of programming problems organized by topic and difficulty levels. </p>

	<h1>Acknowledgments</h1>

	<p>The underlying philosophy of this book and the material that forms its skeleton originated in the work of Professor Russell Shackelford around 1996. Dr. Melody Moore, currently an Associate Professor in the Interactive Computing department of the College of Computing at Georgia Tech, was instrumental in <a id="349"></a><a id="555"></a>creating many of the teaching materials (then as overhead transparencies) from which this class was first taught. I am deeply indebted to Professor James Craig from the Aerospace Engineering department at Georgia Tech, who joined me in co-teaching the first <a id="328"></a>engineering version of CS1, taught me much about MATLAB, and pioneered this class from the original 35 students to its current <a id="559"></a>size of over 1,000 <a id="329"></a>engineering students per semester. This <a id="330"></a>engineering class became a vessel for introducing the students to the MATLAB language.</p>
	<p>The material has benefited from the efforts of every Georgia Tech teaching assistant (TA), graduate student, instructor, and professor who has taught CS1, a list too long to enumerate. In particular, those wonderfully creative TAs who developed the ideas for <a id="351"></a>examples used in this text have enriched it immeasurably.<br>
	My thanks to current instructors Kantwon Rogers and Cedric Stallworth for their diligence in developing video mini-lectures and the many conversations over the years about how best to teach programming to students.<br>
	Thanks also to Amanda Walters whose diligence and deep understanding of programming with html transformed our initial rough draft into a work of elegance.<br>
	I also wish to credit Professor Aaron Bobick with an important contribution made in the course of one short conversation. Professor Bobick taught CS1 with me in the fall of 2004. Early in the semester he made a very simple request: he said it would be easier for him to teach the class if we explicitly expressed the computing concepts inherent in each lesson, rather than leaving him&mdash;and the students&mdash;to tease the concepts out of the teaching materials. That conversation was responsible for pulling the class back from the brink of being merely a MATLAB programming class to one deeply rooted in CS concepts. "And the rest is history."</p>
</div>


</body>
</html>

