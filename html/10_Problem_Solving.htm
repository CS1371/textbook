<!DOCTYPE HTML>
<html>
<head>
<title>10_Problem_Solving</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
<link rel="stylesheet" href="styles/styles.css" />
<script async src="./javascript/index.js"></script>
</style>
</head>
<body>
  <div>#top_nav#</div>
  <div class="nav-obj">#nav_obj#</div>


<div class="content">
  <h1 id="10" align="center">Chapter 10: Problem Solving</h1>

  <!-- Chapter Objectives -->
  <h1>Chapter Objectives</h1>
  <div class="container">
    <p>This chapter presents an overview of framing the solutions to problems:</p>
    <ul>
      <li>We begin with simple problems that can be solved in a single step</li>
      <li>We continue<a id="5234">!</a> to strategies for<a id="5311">!</a> solving more complex problems involving data<a id="5236">!</a> collections by dividing the solution into the following fundamental operations<a id="5389">!</a> that can be performed on any collection<a id="5143">!</a> of data<a id="5237">!</a>:<ol>
      <li>Basic Computations</li>
      <li>Inserting</li>
      <li>Traversing</li>
      <li>Building </li>
      <li>Mapping</li>
      <li>Filtering</li>
      <li>Folding</li>
      <li>Searching</li>
      <li>Sorting</li>
    </ul>
    <p>Then we will briefly discuss how to combine these fundamental tools to solve more complex data<a id="5238">!</a> manipulation problems.</p>
  </div>

  <!-- Introduction -->
  <h1>Introduction</h1>
  <div class="container">
    <p>Programming is really all about applying the computer<a id="5233">!</a> as a tool to solve problems. One of the most difficult tasks facing novice programmers is the blank sheet of paper. Faced with a problem you have never seen before, how do you start to solve it? The problem-solving<a id="5404">!</a> style recommended in this text<a id="5431">!</a> is first to identify the basic character<a id="5137">!</a> of the data<a id="5239">!</a> and the basic operation(s) we are asked to perform. If these two ideas are clear<a id="5138">!</a>, we can create a template or outline of the solution and begin to fill in the blanks.  As we gain more experience with the language, we have more computing tools to apply, and we can attack larger, more complex problems. We now have sufficient tools available to consider a more principled approach to data<a id="5240">!</a> manipulation and problem solving. We will begin with the typical plan for<a id="5312">!</a> solving simple problems in one step and then continue<a id="5235">!</a> to consider assembling multiple steps to solve more complex problems.</p>
  </div>

  <div class="chp-section" data-sect-num="1" data-sect-name="Solving Simple Problems">
    <!-- Solving Simple Problems -->
    <h2 id="10_1">10.1	Solving Simple Problems</h2>
    <div class="container clearfix">
      <div class="float-sm-right card style-points">
        <p class="card-title">Style Points 10.1</p>
        <p class="card-text">You might question the necessity of putting a "simple" bit of code<a id="5139">!</a> through a rigorous analysis. However, the time when you first write a module and start using it is the time of closest scrutiny of that module.  It is amazing how quickly three things happen:
          <ol>
            <li>You trust that module implicitly to do the right thing</li>
            <li>You use it in circumstances for<a id="5313">!</a> which it was not intended</li>
            <li>You wish you had paid more attention to defining error conditions in it.
            </li>
          </ol>
        </p>
      </div>

      <p>In Chapter 2 we saw the basic plan for<a id="5314">!</a> solving simple problems:</p>
      <ul>
        <li>Define the input data<a id="5241">!</a></li>
        <li>Define the output data<a id="5242">!</a></li>
        <li>Discover the underlying equations to solve the problem</li>
        <li>Implement the solution</li>
        <li>Test the results</li>
        <li>Repair the code<a id="5140">!</a> until it conforms to the specifications</li>
      </ul>
      <p>This plan works whenever the problem is simple enough to be able to visualize the complete solution. Typically, however, problems are more complex and require a number of steps to be assembled.</p>
    </div>
  </div>

  <div class="chp-section" data-sect-num="2" data-sect-name="Assembling Solution Steps">
    <!-- Assembling Solution Steps -->
    <h2 id="10_2">10.2	Assembling Solution Steps</h2>
    <div class="container">
      <p>Problem complexity frequently comes in the form of data<a id="5243">!</a> collections that need to be transformed into other collections or summarized as intermediate results. Identifying the operation(s) that will create the output from the input requires some experience. The rest of this chapter provides some guidelines for<a id="5315">!</a> identifying elementary steps whose solutions can be combined to create solutions to many complex problems.</p>
    </div>
  </div>

  <div class="chp-section" data-sect-num="3" data-sect-name="Summary of Operations">
    <!-- Summary of Operations -->
    <h2 id="10_3">10.3	Summary of Operations</h2>
    <div class="container">
      <p>First, we document the operations<a id="5390">!</a> we expect to be able to perform on collections. Table 10.1 lists the generic operations<a id="5391">!</a>, a brief description of each, and a discussion of the consequences.</p>
      <table class="table">
        <thead class="thead-light">
          <tr>Table 10.1: Summary of Operations</tr>
          <tr>
            <th>Operation</th>
            <th>Description</th>
            <th>Consequence</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Basic Step</td>
            <td>Perform elementary operation(s)</td>
            <td>Resulting value(<a id="5440">!</a>s)</td>
          </tr>
          <tr>
            <td>Insert</td>
            <td>Inserts one item into a collection<a id="5144">!</a></td>
            <td>Collection with one more item</td>
          </tr>
          <tr>
            <td>Build</td>
            <td>Creates a collection<a id="5145">!</a> from a data<a id="5244">!</a> source (external file or traversing another collection<a id="5146">!</a>); usually accomplished by starting with an empty<a id="5289">!</a> collection<a id="5147">!</a> and inserting<a id="5355">!</a> one item at a time</td>
            <td>A new collection<a id="5148">!</a> of data<a id="5245">!</a></td>
          </tr>
          <tr>
            <td>Traverse</td>
            <td>Touches each item of data<a id="5246">!</a> in the collection<a id="5149">!</a> - frequently used to display or copy a collection<a id="5150">!</a></td>
            <td>The collection<a id="5151">!</a> is unchanged</td>
          </tr>
          <tr>
            <td>Map</td>
            <td>Changes the content of some or all of the items in the collection<a id="5152">!</a></td>
            <td>A new collection<a id="5153">!</a> of the same length, but the content of some or all items is changed</td>
          </tr>
          <tr>
            <td>Filter</td>
            <td>Removes some items from the collection<a id="5154">!</a></td>
            <td>A new collection<a id="5155">!</a> with reduced length, but the content of the items remains unchanged</td>
          </tr>
          <tr>
            <td>Fold</td>
            <td> Traverses the collection<a id="5156">!</a>, summarizing the contents with a single result (e.g., sum, max, or mean)</td><td>A single result summarizing the collection<a id="5157">!</a> in some way; the collection<a id="5158">!</a> is unchanged</td>
          </tr>
          <tr>
            <td>Search</td>
            <td>Traverses the collection<a id="5159">!</a> until an item matches a given search criterion and then stops, returning the result</td>
            <td>A single result or the indication that the desired match was not achieved; the collection<a id="5160">!</a> is unchanged</td>
          </tr>
          <tr>
            <td>Sort</td>
            <td>Puts the collection<a id="5161">!</a> in order by some specific criterion</td>
            <td>A new collection<a id="5162">!</a> of the same length</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="chp-subsection" data-sub-num="1" data-sub-name="Basic Arithmetic Operations">
      <!-- Arithmetic Operations -->
      <h3 id="10_3_1">10.3.1	Basic Arithmetic Operations</h3>
      <div class="container">
        <p>The simple problem solution described in Section 10.1 frequently needs to be used as part of a larger problem solution. We include that activity in this list for<a id="5316">!</a> completeness.</p>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="2" data-sub-name="Inserting into a Collection">
       <!-- Inserting into a Collection -->
      <h3 id="10_3_2">10.3.2	Inserting into a Collection</h3>
      <div class="container clearfix">
        <p>Inserting an item into a collection<a id="5163">!</a> is a process usually used to build or maintain a collection<a id="5164">!</a> of information. In this text<a id="5432">!</a>, we have seen four basic data<a id="5247">!</a> collection<a id="5165">!</a> types to which insertion<a id="5359">!</a> applies: vectors<a id="5442">!</a>, arrays, cell<a id="5133">!</a> arrays, and structure<a id="5416">!</a> arrays. We will discuss the peculiarities of each collection<a id="5166">!</a> and then the common processing algorithm that can be used to insert a new entry into the collection<a id="5167">!</a>.</p>
        <ul>
          <li>Vectors and arrays are very flexible collections in the MATLAB<a id="5375">!</a> language, and suffer only from the obvious limitations that one can add only numbers<a id="5379">!</a> to a vector data<a id="5248">!</a>, that data<a id="5249">!</a> must be inserted a row or column<a id="5231">!</a> at a time, and that the size of the item inserted must match the existing array<a id="5113">!</a> rows or columns</li>
          <li>Cell arrays can be indexed like numerical<a id="5381">!</a> arrays and can contain any object; however, to compare one element to another usually requires a special-purpose comparison function<a id="5339">!</a></li>
          <li>Structure arrays as a collection<a id="5168">!</a> behave like cell<a id="5134">!</a> arrays, except that any structure<a id="5417">!</a> inserted must have the same fields as those in the existing structure<a id="5418">!</a></li>
        </ul>
        <p>In general, inserting<a id="5356">!</a> into any of these collections involves insertion<a id="5360">!</a> into the front of the collection<a id="5169">!</a>, the back of the collection<a id="5170">!</a>, or at some position in the middle in order to keep the collection<a id="5171">!</a> in order by a specific comparison method.</p>
        <p><b>Inserting at the front</b> is accomplished by concatenating the new element before the existing collection<a id="5172">!</a>.</p>
        <p><b>Inserting at the back</b> is accomplished by concatenating the new element after the existing collection<a id="5173">!</a>.</p>
        <p><b>Inserting in order</b> is usually accomplished using a while<a id="5447">!</a> loop. If we are inserting<a id="5357">!</a> item into a collection<a id="5174">!</a> <code>C</code>, we will use a while<a id="5448">!</a> loop to find the index of the insertion<a id="5361">!</a> point, <code>ins</code>, and then concatenate the three parts of the new collection<a id="5175">!</a>. Figure 10.1 shows the flowchart that applies here.</p>
        <div class="card-deck">
          <div class="col-sm-8">
            <div class="exercise">#exercise_10_1#</div>
          </div>
          <div class="col-sm-4 card">
            <img src="..\Images\Fig_10_1.JPG" alt="Figure 10.1" class="fig card-img">
            <p class="figure-name card-title">Figure 10.1: Insert in Order</p>
          </div>
        </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="3" data-sub-name="Traversing a Collection">
      <!-- Traversing a Collection -->
      <h3 id="10_3_3">10.3.3	Traversing a Collection</h3>
      <div class="container clearfix">
        <p>Traversal involves moving across all elements<a id="5280">!</a> of a collection<a id="5176">!</a> and performing some step (not necessarily the same step) on each element without changing that element. Figure 10.2 illustrate the flowchart for<a id="5317">!</a> traversing a collection<a id="5177">!</a>. They assume that you are doing something like writing a file that needs to be initialized and finalized. These two steps may not always be required.</p>
        <div class="card-deck">
          <div class="col-sm-8">
            <div class="exercise">#exercise_10_2#</div>
          </div>
          <div class="col-sm-4 card">
              <img src="..\Images\Fig_10_2.JPG" alt="Figure 10.2" class="fig-long card-img">
              <p class="figure-name card-title">Figure 10.2: Traversing a Collection</p>
          </div>
        </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="4" data-sub-name="Building a Collection">
      <!-- Building a Collection -->
      <h3 id="10_3_4">10.3.4	Building a Collection</h3>
      <div class="container clearfix">
        <p>In practice, frequently we combine traversal of one collection<a id="5178">!</a> and building<a id="5127">!</a> of another to copy data<a id="5250">!</a> from one collection<a id="5179">!</a> into another. Building a collection<a id="5180">!</a> is the process of beginning with an empty<a id="5290">!</a> collection<a id="5181">!</a> and assembling data<a id="5251">!</a> elements<a id="5281">!</a> by inserting<a id="5358">!</a> them one at a time into the new collection<a id="5182">!</a>. The size of the collection<a id="5183">!</a> increases continually until the process is finished. Figure 10.3 illustrates the algorithm for<a id="5318">!</a> building<a id="5128">!</a> a collection<a id="5184">!</a>.</p>
        <div class="card-deck">
          <div class="col-sm-8">
            <div class="exercise">#exercise_10_3#</div>
          </div>
          <div class="col-sm-4 card">
              <img src="..\Images\Fig_10_3.JPG" alt="Figure 10.3" class="fig-long card-img">
              <p class="figure-name card-title">Figure 10.3: Building a Collection</p>
          </div>
        </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="5" data-sub-name="Mapping a Collection">
      <!-- Mapping a Collection -->
      <h3 id="10_3_5">10.3.5	Mapping a Collection</h3>
      <div class="container clearfix">
        <p>The purpose of mapping<a id="5368">!</a> is to transform a collection<a id="5185">!</a> by changing the data<a id="5252">!</a> in some or all of its elements<a id="5282">!</a> according to some functional<a id="5354">!</a> description without changing its length. It is distinct from traversal because its intent is to change the data<a id="5253">!</a> elements<a id="5283">!</a>. While many languages permit collections to be modified in place, the MATLAB<a id="5376">!</a> language usually requires you to create a new collection<a id="5186">!</a>. However, this is still considered mapping<a id="5369">!</a>. The scalar<a id="5407">!</a> mathematical and logical<a id="5365">!</a> operations<a id="5392">!</a> on vectors<a id="5443">!</a> are good examples of mapping<a id="5370">!</a>. Figure 10.4illustrates the basic algorithm for<a id="5319">!</a> mapping<a id="5371">!</a>.</p>
        <div class="card-deck">
          <div class="col-sm-8">
            <div class="exercise">#exercise_10_4#</div>
          </div>
          <div class="col-sm-4 card">
              <img src="..\Images\Fig_10_4.JPG" alt="Figure 10.4" class="fig-long card-img">
              <p class="figure-name card-title">Figure 10.4: Mapping a Collection</p>
          </div>
        </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="6" data-sub-name="Filtering a Collection">
      <!-- Filtering a Collection -->
      <h3 id="10_3_6">10.3.6	Filtering a Collection</h3>
      <div class="container clearfix">
        <p>Filtering involves removing items from a collection<a id="5187">!</a> according to specified selection criteria. The data<a id="5254">!</a> contents of the remaining items in the collection<a id="5188">!</a> should not be changed, and the collection<a id="5189">!</a> will usually be shorter than before.  Filtering always requires that a new collection<a id="5190">!</a> be built on the filtered items. Figure 10.5 illustrates the general algorithm for<a id="5320">!</a> filtering<a id="5301">!</a> a collection<a id="5191">!</a>.</p>
        <div class="card-deck">
          <div class="col-sm-8">
            <div class="exercise">#exercise_10_5#</div>
          </div>
          <div class="col-sm-4 card">
              <img src="..\Images\Fig_10_5.JPG" alt="Figure 10.5" class="fig-long card-img">
              <p class="figure-name card-title">Figure 10.5: Filtering a Collection</p>
          </div>
        </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="7" data-sub-name="Folding a Collection">
      <!-- Folding a Collection -->
      <h3 id="10_3_7">10.3.7	Folding a Collection</h3>
      <div class="container clearfix">
        <p>Folding is the name given to summarizing a collection<a id="5192">!</a>. It is a special case<a id="5129">!</a> of traversal where all of the items in the collection<a id="5193">!</a> are summarized as a single result. The collection<a id="5194">!</a> is not altered in size or values by the operation<a id="5386">!</a>. Totaling, averaging, and finding the largest element in a vector are typical examples of folding<a id="5304">!</a>.Figure 10.6 shows the basic algorithm for<a id="5321">!</a> folding<a id="5305">!</a> a collection<a id="5195">!</a>. The general form of a fold should be to initialize the summary value<a id="5435">!</a> and then traverse the whole collection<a id="5196">!</a>, updating the summary when necessary. There is an interesting problem in determining the starting value<a id="5436">!</a> for<a id="5322">!</a> a fold. If that value<a id="5437">!</a> is not chosen well, there may be no relevant results in the collection<a id="5197">!</a>.  A good approach is to initialize the state with the value<a id="5438">!</a> of the first entry in the collection<a id="5198">!</a>. This raises another issue to make sure that you deal with an empty<a id="5291">!</a> input collection<a id="5199">!</a>.</p>
        <div class="card-deck">
          <div class="col-sm-8">
            <div class="exercise">#exercise_10_6#</div>
          </div>
          <div class="col-sm-4 card">
              <img src="..\Images\Fig_10_6.JPG" alt="Figure 10.6" class="fig-long card-img">
              <p class="figure-name card-title">Figure 10.6: Folding a Collection</p>
          </div>
        </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="8" data-sub-name="Searching a Collection">
      <h3 id="10_3_8">10.3.8	Searching a Collection</h3>
      <div class="container clearfix">
        <p>Searching is the process of traversing the collection<a id="5200">!</a> and applying a specified test to each element in turn, terminating the process as soon as the test is satisfied. This is superficially similar to filtering<a id="5302">!</a>, except that it is not necessary to touch all the elements<a id="5284">!</a> of the collection<a id="5201">!</a>; the search stops as soon as one element of the collection<a id="5202">!</a> matches the search criteria. If the criteria are extremely complex, it is sometimes advisable to perform a mapping<a id="5372">!</a> or folding<a id="5306">!</a> before the search is performed. Figure 10.7 illustrates one way to implement searching<a id="5408">!</a> a collection<a id="5203">!</a> using a for<a id="5323">!</a> loop with a break<a id="5125">!</a> exit. There are always two exit criteria from a search — finding what you seek and failing to find it. Searching can also be implemented with a while<a id="5449">!</a> loop, but the multiple exit criteria make the code<a id="5141">!</a> generally more complex.</p>
        <div class="card-deck">
          <div class="col-sm-8">
            <div class="exercise">#exercise_10_7#</div>
          </div>
          <div class="col-sm-4 card">
              <img src="..\Images\Fig_10_7.JPG" alt="Figure 10.7" class="fig-long card-img">
              <p class="figure-name card-title">Figure 10.7: Searching a Collection</p>
          </div>
        </div>
      </div>
    </div>

    <div class="chp-subsection" data-sub-num="9" data-sub-name="Sorting a Collection">
      <h3 id="10_3_9">10.3.9	Sorting a Collection</h3>
      <div class="container">
        <p>Sorting involves reordering the elements<a id="5285">!</a> in a collection<a id="5204">!</a> according to a specified ranking function<a id="5340">!</a> that defines which item “comes before” another. Sorting is computationally expensive. However, if a large collection<a id="5205">!</a> of data<a id="5255">!</a> is stable—items are added or removed infrequently—but is frequently searched for<a id="5324">!</a> specific items, keeping the data<a id="5256">!</a> sorted can greatly improve the efficiency of the searches. Chapter 16 is devoted to the details of sorting<a id="5410">!</a> algorithms<a id="5111">!</a>, but the concept is included here to complete the list of operations<a id="5393">!</a> we can perform on a collection<a id="5206">!</a>.  In general, the built-in sort function<a id="5341">!</a> can sort either a vector (of numbers<a id="5380">!</a>, of course) or a cell<a id="5135">!</a> array<a id="5114">!</a> with either one row or one column<a id="5232">!</a> containing strings<a id="5414">!</a>.  Cell arrays are sorted alphabetically.  In either case<a id="5130">!</a>, it returns not only the sorted values but also the order in which the original data<a id="5257">!</a> were used to produce the sort.</p>
        <div class="exercise">#exercise_10_8#</div>
        <p><b>Notes:</b></p>
        <ul>
          <li>Since the sort was sensitive to case<a id="5131">!</a>, 'In' was ranked before 'a'.</li>
          <li>Repeated words were retained, indicating that the word 'a' was the 10th and 17th words in the original sentence</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="chp-section" data-sect-num="4" data-sect-name="Solving Larger Problems">
    <!-- Solving Larger Problems -->
    <h2 id="10_4">10.4 Solving Larger Problems</h2>
    <div class="container clearfix">
      <div class="float-sm-right">
        <div class="card">
            <img src="..\Images\Fig_10_8a.JPG" alt="Figure 10.8a" class="fig card-img">
            <p class="figure-name card-title">Fig 10.8a: Baseball Player Problem</p>
        </div>
        <div class="card">
            <img src="..\Images\Fig_10_8b.JPG" alt="Figure 10.8b" class="fig card-img">
            <p class="figure-name card-title">Fig 10.8b: The Last Step</p>
        </div>
        <div class="card">
            <img src="..\Images\Fig_10_8c.JPG" alt="Figure 10.8c" class="fig card-img">
            <p class="figure-name card-title">Fig 10.8c: The Last But One Step</p>
        </div>
        <div class="card">
            <img src="..\Images\Fig_10_8d.JPG" alt="Figure 10.8d" class="fig card-img">
            <p class="figure-name card-title">Fig 10.8d: The First Step</p>
        </div>
      </div>
      <p>Problem statements are rarely simple enough to be able to seize one of the above steps and solve the whole problem. Usually, the solution involves choosing a number of known operations<a id="5394">!</a> and performing those operations<a id="5395">!</a> in order to solve the complete problem. Solution steps are combined in one of two ways—in sequence or nested. When considering the overall strategy for<a id="5325">!</a> solving a problem, one might identify steps A and B as contributing to the solution. Your logical<a id="5366">!</a> statement might say either “do A and then B” sequential steps—or “for<a id="5326">!</a> each part of A, do B”—nested steps.  For example, consider the baseball card problem originally proposed in Chapter 1. You have collected over the years a huge number of baseball cards, and you wish to find the names of the 10 “qualified” players with the highest lifetime batting average.</p>
      <p>To qualify, the players must have been in the league at least five years, had at least 100 plate appearances per year, and made less<a id="5364">!</a> than 10 errors per year.  The first step is to build a collection<a id="5207">!</a> containing the relevant information on the cards for<a id="5327">!</a> each player, and the use of a structure<a id="5419">!</a> array<a id="5115">!</a> seems a good choice. Next, we need to operate on this collection<a id="5208">!</a> to solve the problem. Consider again the overall problem situation, as shown in Figure 10.8a. The original data<a id="5258">!</a> are the structure<a id="5420">!</a> array<a id="5116">!</a> containing all the player data<a id="5259">!</a>. The final result is a list of 10 names of the qualified players with the highest batting averages. There may be more than one sequence of operations<a id="5396">!</a> to solve this problem, and some may be more efficient than others.  First, we consider the operations<a id="5397">!</a> that could be performed on the original data<a id="5260">!</a>. Since the end<a id="5292">!</a> result is a collection<a id="5209">!</a>, it is unlikely that the first step would reduce the collection<a id="5210">!</a> to one answer. This eliminates folding<a id="5307">!</a> and searching<a id="5409">!</a>. Since the collection<a id="5211">!</a> is already built, we do not need to insert or build, leaving four possible operations<a id="5398">!</a> to consider—traversal, mapping<a id="5373">!</a>, filtering<a id="5303">!</a>, and sorting<a id="5411">!</a>.  Now, consider the last operation<a id="5387">!</a>—it seems reasonable that the last thing to do is a mapping<a id="5374">!</a>—taking the 10 selected structures and extracting the names.  Now, we must think about how to find these 10 structures. If we had a collection<a id="5212">!</a> of qualified players sorted by their batting average, we could accomplish this with a special filter taking the first 10 from these sorted, qualified players (Fig 10.8b).</p>
      <p>Backing up one more step, we can see that the sorted collection<a id="5213">!</a> we need is just a sort of the qualified players, and we can chain these steps together to solve the whole problem. (Figures 10.8c and 10.8d)</p>
    </div>
  </div>

  <div class="chp-section" data-sect-num="5" data-sect-name="Engineering Example - Processing Geopolitical Data">
    <!-- Engineering Example -->
    <h2 id="10_5">10.5  Engineering Example - Processing Geopolitical Data</h2>
    <div class="container clearfix">
      <p>Imagine that you have decided to move your prosperous business overseas to the country with the most business-friendly environment. After considerable study, you decide that the best measure of friendliness would be to compute the rate of growth of the gross domestic product for<a id="5328">!</a> candidate countries, subtract their rate of population growth, and use this measure to choose the best country. An Internet search provides an interesting source of data<a id="5261">!</a>. Figure 10.9 shows an excerpt from a spreadsheet containing historical data<a id="5262">!</a> for<a id="5329">!</a> 154 countries from Penn World Table Version 9.1. described in detail in this paper: Feenstra, Robert C., Robert Inklaar and Marcel P. Timmer (2015), "The Next Generation of the Penn World Table" American Economic Review, 105(10), 3150-3182, found at <a style="color:black;" href="https://www.rug.nl/ggdc/">www.ggdc.net</a></p>
      <div class="card">
          <img src="..\Images\Fig_10_9.JPG" alt="Figure 10.9" class="fig fig-wide card-img">
          <p class="figure-name card-title">Fig 10.9: World Data Example</p>
      </div>
      <p>The data<a id="5263">!</a> columns of interest to us contain the following information:
      <ul>
        <li><code>contrycode</code>: a TLA for<a id="5330">!</a> each country (col A)</li>
        <li><code>country</code>: name of the country (col B)</li>
        <li><code>year</code>: year for<a id="5331">!</a> which values are quoted (col C)</li>
        <li><code>rgdpe</code>: Expenditure-side real GDP at chained PPPs (in mil. 2011US$) (col E)</li>
        <li><code>pop</code>: Population in millions (col G)</li>
      </ul>
      <p>Figure 10.9 also illustrates one of the weaknesses of spreadsheets<a id="5413">!</a>: they are inherently two dimensional, and the data<a id="5264">!</a> in this case<a id="5132">!</a> are three dimensional; each country has several sets of data<a id="5265">!</a> as functions of the year when the information was recorded. Therefore, the data<a id="5266">!</a> must be massaged into a  form more useful to us. A careful examination of the data<a id="5267">!</a> also reveals the following challenges:</p>
      <ul>
        <li>The years in which the data<a id="5268">!</a> were available vary from country to country—most have data<a id="5269">!</a> from 1950 to 2017</li>
        <li>There are some places within the numerical<a id="5382">!</a> data<a id="5270">!</a> where the values are not available, signified by the blank cells at those locations.</li>
      </ul>
      <p>Our algorithm must take into account the variable<a id="5441">!</a> number of years and the potential presence of strings<a id="5415">!</a> within the data<a id="5271">!</a>. Fortunately, the Matlab <code>xlsread(<a id="5450">!</a>...)</code> function<a id="5342">!</a> discussed earlier recognizes this situation and inserts <code>NaN<a id="5378">!</a></code> in the numerical<a id="5383">!</a> data<a id="5272">!</a> fields. To ensure clarity and reliability in our solution, we need a careful design for<a id="5332">!</a> this data<a id="5273">!</a> processing task as follows.</p>
      <ul>
        <li>Looking at the end<a id="5293">!</a> result desired, eventually we need to fold a collection<a id="5214">!</a> of data<a id="5274">!</a> about each country and choose the friendliest one.</li>
        <li>The information describing each country must include not only its name, but also vectors<a id="5444">!</a> of the population and CGDP as a function<a id="5343">!</a> of the year. It seems that a structure<a id="5421">!</a> array<a id="5117">!</a> by country would be an appropriate form for<a id="5333">!</a> the data<a id="5275">!</a>.</li>
        <li>Therefore, before actually solving the problem, we have to build this structure<a id="5422">!</a>.</li>
        <li>Having built the structure<a id="5423">!</a>, the folding<a id="5308">!</a> operation<a id="5388">!</a> to find the friendliest country follows the folding<a id="5309">!</a> template shown in Section 10.3.7.</li>
      </ul>
      <p>Listing 10.1 shows the script that accomplishes this analysis, although most of the work is actually done in the following functions. When we run this program<a id="5406">!</a>, we see the following result:</p>
      <div class="listing">#listing_10_1#</div>
      <p><code>>>best country is Bosnia and Herzegovina</code<a id="5142">!</a>></p>
      <p>This may not be exactly the result we were hoping for<a id="5334">!</a>. In Chapter 16 we will revisit this example with some better tools that will allow us to apply additional criteria to selecting countries.</p>
    </div>
  </div>

  <!-- Chapter Summary -->
  <h2>Chapter Summary</h2>
  <div class="container">
    <p>This chapter presented the fundamental operations<a id="5399">!</a> that can be applied to problem solving:</p>
    <ul>
      <li>Using normal arithmetic<a id="5112">!</a> operations<a id="5400">!</a> with specific input and output values</li>
      <li>Inserting new elements<a id="5286">!</a> in a collection<a id="5215">!</a></li>
      <li>Traversing a collection<a id="5216">!</a></li>
      <li>Building a collection<a id="5217">!</a> by repetitive insertion<a id="5362">!</a></li>
      <li>Mapping a collection<a id="5218">!</a> - changing the values of the data<a id="5276">!</a> items in the
      collection<a id="5219">!</a>, but not the number of them</li>
      <li>Filtering a collection<a id="5220">!</a> - reducing the number of entries, but not
      changing the data<a id="5277">!</a> contents of the collection<a id="5221">!</a></li>
      <li>Folding the values in a collection<a id="5222">!</a> into a single quantity</li>
      <li>Searching for<a id="5335">!</a> a specific match in a collection<a id="5223">!</a></li>
      <li>Sorting a collection<a id="5224">!</a></li>
    </ul>
    <p>Then we briefly discussed how to combine these fundamental tools to solve more complex data<a id="5278">!</a> manipulation problems.</p>
  </div>
<h2>Self Test</h2>
<div class="container">

Use the following questions to check your understanding of the material in this
chapter:
<h3>True or False</h3>
<ol>
<li>Copying the elements<a id="5287">!</a> of a structure<a id="5424">!</a> array<a id="5118">!</a> into a cell<a id="5136">!</a> array<a id="5119">!</a> is a
combination of traversal and insertion<a id="5363">!</a>.</li>
      <li>If you map a collection<a id="5225">!</a>, you must change at least one of its elements<a id="5288">!</a>.</li>
      <li>When you filter a collection<a id="5226">!</a>, at least one data<a id="5279">!</a> element is changed.</li>
      <li>The function<a id="5344">!</a> max(<a id="5377">!</a>...) is not folding<a id="5310">!</a> because it returns two values.</li>
      <li>You can use a for<a id="5336">!</a> loop to search a collection<a id="5227">!</a> even if you need to
stop the search when you find the answer.</li>
      <li>Sorting must involve putting the items in a collection<a id="5228">!</a> in numerical<a id="5384">!</a>
order (ascending or descending).</li>
</ol>
<h3>Fill in the Blanks</h3>
<ol>
<li>The problem-solving<a id="5405">!</a> style recommended in this text<a id="5433">!</a> is to identify
the ___________and the _____________.</li>
      <li>Building is usually the process of ____________ and ___________
_______________.</li>
      <li>Mapping may involve combining _____________ of the same length.</li>
      <li>We _______________ vectors<a id="5445">!</a> by applying built-in logical<a id="5367">!</a> operations<a id="5401">!</a>
and then indexing with the results to produce new, shorter arrays.</li>
      <li>Totaling, averaging, and finding the smallest element in a vector are
typical examples of _____________.</li>
      <li>There are almost always two exit criteria for<a id="5337">!</a> a search: ___________
_______________ or ________________.</li>
      <li>To save a collection<a id="5229">!</a> to a text<a id="5434">!</a> file, you ____________ the collection<a id="5230">!</a>
____________ it to the file.</li>
</ol>

<h3>Programming Projects</h3>
<ol><p>
<li>The purpose of this problem is to write a set of functions that
calculate the volume of a slant cylinder with an irregular pentagonal
cross section shown in Figure 10.10. </p>
      <div class="card">
          <img src="..\Images\Fig_10_10.JPG" alt="Figure 10.10" class="fig card-img">
          <p class="figure-name card-title">Fig 10.10: The Problem</p>
      </div>
<p>You will be given two vectors<a id="5446">!</a>, x and y, containing the coordinates of
the corners of the pentagon, and the value<a id="5439">!</a> h , the vertical height of
the cylinder. We will need to break<a id="5126">!</a> this problem apart, writing
functions to solve each part:
<ul>
<li>The volume of the cylinder is the area of the pentagon multiplied by
the vertical height; write a function<a id="5345">!</a> polyval(<a id="5403">!</a>x, y, h) to solve this.</li>
      <li>The area of the pentagon is the sum of the areas of three
triangles shown in Figure 10.11. </p>
      <div class="card">
          <img src="..\Images\Fig_10_11.JPG" alt="Figure 10.11" class="fig card-img">
          <p class="figure-name card-title">Fig 10.11: The Base</p>
      </div>
<p>So we need to write a function<a id="5346">!</a>
pent_area(x, y) that asks for<a id="5338">!</a> the area of the three triangles and
adds them together.</li>
      <li>Given the coordinates of the corners of a triangle, we need a
function<a id="5347">!</a> tri_area(x, y) to calculate the area of the triangle—see
Figure 10.12. </p>
      <div class="card">
          <img src="..\Images\Fig_10_12.JPG" alt="Figure 10.12" class="fig card-img">
          <p class="figure-name card-title">Fig 10.12: Area of a Triangle</p>
      </div>
<p>To compute the area of the triangle, we need the
values of a, b, and c . So if we had the lengths of the lines, the area
of the triangle is given by Heron's formula:<br>
A = ( s(s-a)(s-b)(s-c) )<br>
where s is half the sum of a, b, and c.</li>
      <li>So we need a function<a id="5348">!</a> tri_side(x, y) that computes the length
of a line when given its end<a id="5294">!</a> points.</li>
      <li>Then, we can put the pieces back together by calling the functions
with the right parameters<a id="5402">!</a>, and then build and test polyvol using
the test cases provided.</li>
</ul>
      <li>This problem is about processing structure<a id="5425">!</a> arrays. Write a function<a id="5349">!</a>
named structSort that sorts a structure<a id="5426">!</a> array<a id="5120">!</a> based on a given field<a id="5296">!</a>
that contains numerical<a id="5385">!</a> values. Your function<a id="5350">!</a> should take in a
structure<a id="5427">!</a> array<a id="5121">!</a> and a string that should correspond to one of the
field<a id="5297">!</a> names of the structure<a id="5428">!</a> array<a id="5122">!</a> and return the original structure<a id="5429">!</a> array<a id="5123">!</a>
sorted on the given field<a id="5298">!</a>. It should check to be sure that the
specified field<a id="5299">!</a> name is in fact one of the fields of the structure<a id="5430">!</a> array<a id="5124">!</a>,
and call the error(<a id="5295">!</a>...) function<a id="5351">!</a> if it is not.
Test your function<a id="5352">!</a> by using the buildCDs script from Chapter 7,
using the input function<a id="5353">!</a> to specify the sorting<a id="5412">!</a> field<a id="5300">!</a>.</li>
 
</ol>
</div>
</div>


</body>
</html>

