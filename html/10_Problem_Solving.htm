<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"> 
<html> 
<head> 
<title>10_Problem_Solving</title> 
<link rel="stylesheet" href="styles/styles.css" /> 
<script async src="./javascript/index.js"></script> 
<style>
table, th, td {
  border: 1px solid black;
}
</style>
</head> 
<body bgcolor="#ffffff"> 
<h1 align="center">Chapter 10: Problem Solving</h1> 

<table align="center"> 
<tbody> 
<tr> 
<td><a href="09_Recursion.htm">previous</a></td> 
<td><a href="Contents.htm">home</a></td> 
<td><a href="11_Plotting.htm">next</a></td> 
</tr> 
</tbody> 
</table>
<ul>
<li><a href="#10_1">10.1	Solving Simple Problems</a>
<li><a href="#10_2">10.2	Assembling Solution Steps</a>
<li><a href="#10_3">10.3	Summary of Operations</a>
<ul>
    <li><a href="#10_3_1">10.3.1	Basic Arithmetic Operations</a>
    <li><a href="#10_3_2">10.3.2	Inserting into a Collection</a>
    <li><a href="#10_3_3">10.3.3	Traversing a Collection</a>
    <li><a href="#10_3_4">10.3.4	Building a Collection</a>
    <li><a href="#10_3_5">10.3.5	Mapping a Collection</a>
    <li><a href="#10_3_6">10.3.6	Filtering a Collection</a>
    <li><a href="#10_3_7">10.3.7	Folding a Collection</a>
    <li><a href="#10_3_8">10.3.8	Searching a Collection</a>
    <li><a href="#10_3_9">10.3.9	Sorting a Collection</a>
</ul>
<li><a href="#10_4">10.4	Solving Larger Problems</a>
<li><a href="#10_5">10.5	Engineering Example— Processing Geopolitical Data</a>
</ul>
<h1>Chapter Objectives</h1>

This chapter presents an overview of framing the solutions to problems: <ul>
<li>We begin with simple problems that can be solved in a single step</li>
<li>We continue to strategies for solving more complex problems involving data collections by dividing the solution into the following fundamental operations that can be performed on any collection of data:<ol> 
<li>Basic Computations</li>
<li>Inserting</li>
<li> Traversing</li>
<li>Building </li>
<li> Mapping</li>
<li>Filtering</li>
<li>Folding</li>
<li>Searching</li>
<li>Sorting</li>
</ol>
</ul> 

Then we will briefly discuss how to combine these fundamental tools to solve more complex data manipulation problems. 

<h1>Introduction</h1>
  Programming is really all about applying the computer as a tool to solve problems. One of the most difficult tasks facing novice programmers is the blank sheet of   paper. Faced with a problem you have never seen before, how do you start to solve it? The problem-solving style recommended in this text is first to identify the basic character of the data and the basic operation(s) we are asked to perform. If these two ideas are clear, we can create a template or outline of the solution and begin to fill in the blanks.  As we gain more experience with the language, we have more computing tools to apply, and we can attack larger, more complex problems. We now have sufficient tools available to consider a more principled approach to data manipulation and problem solving. We will begin with the typical plan for solving simple problems in one step and then continue to consider assembling multiple steps to solve more complex problems.  
<h2><a name="10_1">10.1	Solving Simple Problems</a></h2>
 In Chapter 2 we saw the basic plan for solving simple problems:<ul>
<li>Define the input data</li>
<li>Define the output data</li>
<li>Discover the underlying equations to solve the problem</li>
<li>Implement the solution</li>
<li>Test the results</li>
<li>Repair the code until it conforms to the specifications</li>
</ul>
This plan works whenever the problem is simple enough to be able to visualize the complete solution. Typically, however, problems are more complex and require a number of steps to be assembled.  
<h2><a name="10_2">10.2	Assembling Solution Steps</a></h2>
 Problem complexity frequently comes in the form of data collections that need to be transformed into other collections or summarized as intermediate results. Identifying the operation(s) that will create the output from the input requires some experience. The rest of this chapter provides some guidelines for identifying elementary steps whose solutions can be combined to create solutions to many complex problems.  
<h2><a name="10_3">10.3	Summary of Operations</a></h2>
 First, we document the operations we expect to be able to perform on collections. Table 10.1 lists the generic operations, a brief description of each, and a discussion of the consequences. <br>
 <h3><center>Table 10.1: Summary of Operations</center></h3>
 <table>
<tr><th>Index</th><th>Operation</th><th>Description</th><th>Consequence</th></tr>
<tr><td>1</td><td>Basic Step</td><td>Perform elementary operation(s)</td><td>Resulting value(s)</td></tr>
<tr><td>2</td><td>Insert</td><td>Inserts one item into a collection</td><td>Collection with one more item</td></tr>
<tr><td>3</td><td>Build</td><td>Creates a collection from a data source
(external file or traversing another collection);
usually accomplished by starting with an empty
collection and inserting one item at a time
</td><td>A new collection of data</td></tr>
<tr><td>4</td><td>Traverse</td><td>Touches each item of data in the collection—
frequently used to display or copy a collection</td><td>The collection is unchanged</td></tr>
<tr><td>5</td><td>Map</td><td>Changes the content of some or all of the items
in the collection</td><td>A new collection of the same
length, but the content of some
or all items is changed</td></tr>
<tr><td>6</td><td>Filter</td><td>Removes some items from the collection</td><td>A new collection with reduced
length, but the content of the
items remains unchanged</td></tr>
<tr><td>7</td><td>Fold</td><td> Traverses the collection, summarizing the contents
with a single result (e.g., sum, max, or mean)</td><td>A single result summarizing the
collection in some way; the
collection is unchanged</td></tr>
<tr><td>8</td><td>Search</td><td>Traverses the collection until an item matches a
given search criterion and then stops, returning
the result</td><td>A single result or the indication that
the desired match was not achieved;
the collection is unchanged</td></tr>
<tr><td>9</td><td>Sort</td><td>Puts the collection in order by some specific
criterion</td><td>A new collection of the same
length</td></tr>
</table>
<div class="container">
  <div class="sidebar_R">
<h4>Style Points 10.1</h4>
You might question the necessity of putting a "simple" bit of code through a rigorous analysis. However, the time when you first write a module and start using it is the time of closest scrutiny of that module.  It is amazing how quickly three things happen: 1. you trust that module implicitly to do the right thing, 2. you use it in circumstances for which it was not intended, and 3. you wish you had paid more attention to defining error conditions in it.</div>

<div class="container">
 <br>The following paragraphs illustrate these fundamental operations, using the array of structures from Chapter 7 as examples. The discussion of each step takes the form of a written description, a flowchart, and a template for writing the code.  
<h3><a name="10_3_1">10.3.1	Basic Arithmetic Operations</a></h3>
 The simple problem solution described in Section 10.1 frequently needs to be used as part of a larger problem solution. We include that activity in this list for completeness.  
 </div>
<h3><a name="10_3_2">10.3.2	Inserting into a Collection</a></h3>
 Inserting an item into a collection is a process usually used to build or maintain a collection of information. In this text, we have seen four basic data collection types to which insertion applies: vectors, arrays, cell arrays, and structure arrays. We will discuss the peculiarities of each collection and then the common processing algorithm that can be used to insert a new entry into the collection.
 <ul>
<li>Vectors and arrays are very flexible collections in the MATLAB language, and suffer only from the obvious limitations that one can add only numbers to a vector data, that data must be inserted a row or column at a time, and that the size of the item inserted must match the existing array rows or columns</li>
<li>Cell arrays can be indexed like numerical arrays and can contain any object; however, to compare one element to another usually requires a special-purpose comparison function</li>
<li>Structure arrays as a collection behave like cell arrays, except that any structure inserted must have the same fields as those in the existing structure</li></ul>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_10_1.jpg" width="250" /></p></center>
<figcaption><b><center>Fig 10.1: Insert in Order</center></b></figcaption></figure>
 
In general, inserting into any of these collections involves insertion into the front of the collection, the back of the collection, or at some position in the middle in order to keep the collection in order by a specific comparison method.<br><br>
<b>Inserting at the front</b> is accomplished by concatenating the new element before the existing collection. For example, adding item to the front of an existing cell array, <code>C</code>, is accomplished as follows:<br><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;>> C = [{item} C] % note the braces needed for a cell array</code><br><br>
<b>Inserting at the back</b> is accomplished by concatenating the new element after the existing collection. For example, adding item to the back of an existing cell array, <code>C</code>, is accomplished as follows:<br><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;>> C = [C {item}] % note the braces needed for a cell array</code><br><br>
<b>Inserting in order</b> is usually accomplished using a while loop. If we are inserting item into a collection <code>C</code>, we will use a while loop to find the index of the insertion point, <code>ins</code>, and then concatenate the three parts of the new collection. Figure 10.1 shows the flowchart that applies here.  For example, adding <code>item</code> in order to a vector, <code>v</code>, is accomplished as follows:<br><br>
<code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;ins = <font color="#ff8000">1</font>;  <font color="#00A000">% initialize the result</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% set up the first pass of the while loop</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">while</font> ins <= length(v) && before(item, v(ins))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% you provide a function before(a, b) that returns</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%   true if a comes before b in your ordering</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ins = ins + <font color="#ff8000">1</font>; <font color="#00A000">% next value</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% when you find the right place, concatenate the three parts</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;v = [v(<font color="#ff8000">1</font>:ins-<font color="#ff8000">1</font>) item v(ins:end)]<br>
<br><br>
</strong></code>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_10_2.jpg" width="250" /></p></center>
<figcaption><b><center>Fig 10.2: Traversing a Collection</center></b></figcaption></figure>
where <code>before(a,b)</code> is a generic comparator that determines whether <code>a</code> comes before <code>b</code> in the ordering scheme. Notice that this covers the cases where <code>item</code> must be the first or last item in the collection. Consequently, we could include the case of front or back insertion by having <code>before(a,b)</code> return <code>true</code> for inserting in the front and <code>false</code> for inserting at the back.<br><br> 
<h3><a name="10_3_3">10.3.3	Traversing a Collection</a></h3>
 Traversal involves moving across all elements of a collection and performing some step (not necessarily the same step) on each element without changing that element. Figure 10.2 illustrate the flowchart for traversing a collection. They assume that you are doing something like writing a file that needs to be initialized and finalized. These two steps may not always be required. <br>
 For example, suppose you just want to list the titles of your cd collection:<br>
<code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% nothing to do on entry</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> cd = cds<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% cd is a structure with a field "title"</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'Title: %s\n'</font>, cd.title); <font color="#00A000">% print the title</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% nothing to do on exit</font><br>
<br><br><br><br><br><br>
</strong></code>

<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_10_3.jpg" width="250" /></p></center>
<figcaption><b><center>Fig 10.3: Building a Collection</center></b></figcaption></figure>
<br><br><br><br>
<h3><a name="10_3_4">10.3.4	Building a Collection</a></h3>
 In practice, frequently we combine traversal of one collection and building of another to copy data from one collection into another. Building a collection is the process of beginning with an empty collection and assembling data elements by inserting them one at a time into the new collection. The size of the collection increases continually until the process is finished. Figure 10.3 illustrates the algorithm for building a collection.<br>
For example, we might want to build a structure array from a cell array with three columns for <code>title</code>, <code>artist</code> and <code>date</code>.  The code to do this would be:<br><br>
<code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% initialize the empty structure array</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;res = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ndx = 1:length(ca)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% create a new structure</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str = struct(<font color="#c000c0">'title'</font>, ca{ndx,1}, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'<font color="#c000c0">artist'</font>, ca{ndx,2}, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'<font color="#c000c0">date'</font>, ca{ndx,3});<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% append to the emerging result</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = [res str]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% nothing to do on exit</font><br>
</strong></code>
<br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_10_4.jpg" width="250" /></p></center>
<figcaption><b><center>Fig 10.4: Mapping a Collection</center></b></figcaption></figure>
<br><br>
 
<h3><a name="10_3_5">10.3.5	Mapping a Collection</a></h3>
 The purpose of mapping is to transform a collection by changing the data in some or all of its elements according to some functional description without changing its length. It is distinct from traversal because its intent is to change the data elements. While many languages permit collections to be modified in place, the MATLAB language usually requires you to create a new collection. However, this is still considered mapping. The scalar mathematical and logical operations on vectors are good examples of mapping. Figure 10.4illustrates the basic algorithm for mapping.<br>
For example, continuing the previous example, we might want to have a numerical value for the year in the <code>cds</code>. When adding a field, you should build a new structure array with the new field added.  The code to do this would be:<br>
<br>
<code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% initialize the empty structure array</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;new_cds = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> item = cds<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% add the field (assuming that the last 4 digits of the date is the year)</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item.year = str2num(item.date(end-3:end))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% append to the emerging result</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_cds = [new_cds str]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% nothing to do on exit</font><br>
</strong></code>
<br><br><br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_10_5.jpg" width="250" /></p></center>
<figcaption><b><center>Fig 10.5: Filtering a Collection</center></b></figcaption></figure>
<br><br><br><br><br><br><br>

<h3><a name="10_3_6">10.3.6	Filtering a Collection</a></h3>
 Filtering involves removing items from a collection according to specified selection criteria. The data contents of the remaining items in the collection should not be changed, and the collection will usually be shorter than before.  Filtering always requires that a new collection be built on the filtered items. Figure 10.5 illustrates the general algorithm for filtering a collection.<br>
For example, we might want a list of all the <code>cds</code> recorded before 2010.  The code to do this would be:<br><br>
<br>
<code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% initialize the empty structure array</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;new_cds = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> item = cds<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% apply a test to determine whether to keep this item</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> item.year < 2010<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% if so, append to the emerging result</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_cds = [new_cds item]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% nothing to do on exit</font><br>
</strong></code>
<br><br><br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_10_6.jpg" width="250" /></p></center>
<figcaption><b><center>Fig 10.6: Folding a Collection</center></b></figcaption></figure>
<br><br><br><br>  
<h3><a name="10_3_7">10.3.7	Folding a Collection</a></h3>
 Folding is the name given to summarizing a collection. It is a special case of traversal where all of the items in the collection are summarized as a single result. The collection is not altered in size or values by the operation. Totaling, averaging, and finding the largest element in a vector are typical examples of folding.Figure 10.6 shows the basic algorithm for folding a collection. The general form of a fold should be to initialize the summary value and then traverse the whole collection, updating the summary when necessary. There is an interesting problem in determining the starting value for a fold. If that value is not chosen well, there may be no relevant results in the collection.  A good approach is to initialize the state with the value of the first entry in the collection. This raises another issue to make sure that you deal with an empty input collection.<br>
 For example, we might want to find the oldest CD in a collection. The code to do this would be:<br><br>
<code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% check that collection is not empty</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% initialize the results</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> isempty(cds)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_value = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_index = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_value = cds(1).year;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_index = 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ndx = 2:length(cds) <font color="#00A000">% we need the index value</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item = cds(ndx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% should we keep this one?</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> item.year < current_value<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% if so, keep the new value</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_value = cds(ndx).year;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_index = ndx;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% nothing to do on exit</font><br>
</strong></code>
<br><br><br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="300" src="Fig_10_7.jpg" width="250" /></p></center>
<figcaption><b><center>Fig 10.7: Searching a Collection</center></b></figcaption></figure>
<br><br><br><br>

<h3><a name="10_3_8">10.3.8	Searching a Collection</a></h3>
 Searching is the process of traversing the collection and applying a specified test to each element in turn, terminating the process as soon as the test is satisfied. This is superficially similar to filtering, except that it is not necessary to touch all the elements of the collection; the search stops as soon as one element of the collection matches the search criteria. If the criteria are extremely complex, it is sometimes advisable to perform a mapping or folding before the search is performed. Figure 10.7 illustrates one way to implement searching a collection using a for loop with a break exit. There are always two exit criteria from a search — finding what you seek and failing to find it. Searching can also be implemented with a while loop, but the multiple exit criteria make the code generally more complex.  <br>
 For example, suppose we want to find the <code>cd</code> titled "A Hard Days Night." If we thought there were more than one, we might do a filter instead of a search.  This code will only inform you of the first occurrence.<br><br>
 <code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% initialize the result</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;found = false<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist = <font color="#c000c0">''</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> item = cds<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% apply a test to determine whether this is what we want</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> strcmp(item.year, <font color="#c000c0">'A Hard Days Night'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% if so, exit with found set</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;artist = item.artist;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> found<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'found a cd recorded by %s\n'</font>, artist);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'not found\n'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
</strong></code>
<br><br><br>

<h3><a name="10_3_9">10.3.9	Sorting a Collection</a></h3>
 Sorting involves reordering the elements in a collection according to a specified ranking function that defines which item “comes before” another. Sorting is computationally expensive. However, if a large collection of data is stable—items are added or removed infrequently—but is frequently searched for specific items, keeping the data sorted can greatly improve the efficiency of the searches. Chapter 16 is devoted to the details of sorting algorithms, but the concept is included here to complete the list of operations we can perform on a collection.  In general, the built-in sort function can sort either a vector (of numbers, of course) or a cell array with either one row or one column containing strings.  Cell arrays are sorted alphabetically.  In either case, it returns not only the sorted values but also the order in which the original data were used to produce the sort.  For example, suppose we want to alphabetize some words.  Consider this code:<br><br>
<code><strong>
>> ca = {'In','general','the','built-in','sort','function','can','sort','either','a','vector','of','numbers','of','course','or', ...
   'a','cell','array','with','either','one','row','or','one','column','containing','strings'};<br>
   <br>
>> [sorted, order] = sort(ca)<br>
<br>
sorted =<br>
&nbsp;&nbsp;1×28 cell array<br>
&nbsp;&nbsp; Columns 1 through 8<br>
&nbsp;&nbsp;{'In'}    {'a'}    {'a'}    {'array'}    {'built-in'}    {'can'}    {'cell'}    {'column'}<br>
&nbsp;&nbsp; Columns 9 through 14<br>
&nbsp;&nbsp; {'containing'}    {'course'}    {'either'}    {'either'}    {'function'}    {'general'}<br>
&nbsp;&nbsp;Columns 15 through 23<br>
&nbsp;&nbsp; {'numbers'}    {'of'}    {'of'}    {'one'}    {'one'}    {'or'}    {'or'}    {'row'}    {'sort'}<br>
&nbsp;&nbsp;Columns 24 through 28<br>
&nbsp;&nbsp;{'sort'}    {'strings'}    {'the'}    {'vector'}    {'with'}<br>
<br>
&nbsp;&nbsp;order =<br>
&nbsp;&nbsp;Columns 1 through 17<br>
&nbsp;&nbsp;1    10    17    19     4     7    18    26    27    15     9    21     6     2    13    12    14<br>
&nbsp;&nbsp;Columns 18 through 28<br>
&nbsp;&nbsp;22    25    16    24    23     5     8    28     3    11    20<br>
>> 
</strong></code><br>

<b>Notes:</b> <ul>
<li>Since the sort was sensitive to case, 'In' was ranked before 'a'.</li>
<li>Repeated words were retained, indicating that the word 'a' was the 10th and 17th words in the original sentence</li>
</ul>
   
 
 <br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="120" src="Fig_10_8a.jpg" width="500" /></p></center>
<figcaption><b><center>Fig 10.8a: Baseball Player Problem</center></b></figcaption></figure>
<h2><a name="10_4">10.4 Solving Larger Problems</a></h2>
 Problem statements are rarely simple enough to be able to seize one of the above steps and solve the whole problem. Usually, the solution involves choosing a number of known operations and performing those operations in order to solve the complete problem. Solution steps are combined in one of two ways—in sequence or nested. When considering the overall strategy for solving a problem, one might identify steps A and B as contributing to the solution. Your logical statement might say either “do A and then B” sequential steps—or “for each part of A, do B”—nested steps.  For example, consider the baseball card problem originally proposed in Chapter 1. You have collected over the years a huge number of baseball cards, and you wish to find the names of the 10 “qualified” players with the highest lifetime batting average. <br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="150" src="Fig_10_8b.jpg" width="500" /></p></center>
<figcaption><b><center>Fig 10.8b: The Last Step</center></b></figcaption></figure>
To qualify, the players must have been in the league at least five years, had at least 100 plate appearances per year, and made less than 10 errors per year.  The first step is to build a collection containing the relevant information on the cards for each player, and the use of a structure array seems a good choice. Next, we need to operate on this collection to solve the problem. Consider again the overall problem situation, as shown in Figure 10.8a. The original data are the structure array containing all the player data. The final result is a list of 10 names of the qualified players with the highest batting averages. There may be more than one sequence of operations to solve this problem, and some may be more efficient than others.  First, we consider the operations that could be performed on the original data. Since the end result is a collection, it is unlikely that the first step would reduce the collection to one answer. This eliminates folding and searching. Since the collection is already built, we do not need to insert or build, leaving four possible operations to consider—traversal, mapping, filtering, and sorting.  Now, consider the last operation—it seems reasonable that the last thing to do is a mapping—taking the 10 selected structures and extracting the names.  Now, we must think about how to find these 10 structures. If we had a collection of qualified players sorted by their batting average, we could accomplish this with a special filter taking the first 10 from these sorted, qualified players (Fig 10.8b). <br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="150" src="Fig_10_8c.jpg" width="500" /></p></center>
<figcaption><b><center>Fig 10.8c: The Last But One Step</center></b></figcaption></figure>
Backing up one more step, we can see that the sorted collection we need is just a sort of the qualified players, and we can chain these steps together to solve the whole problem. (Figures 10.8c and 10.8d. <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="150" src="Fig_10_8d.jpg" width="500" /></p></center>
<figcaption><b><center>Fig 10.8d: The First Step</center></b></figcaption></figure>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<h2><a name="10_5">10.5  Engineering Example—Processing Geopolitical Data</a></h2>

<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="250" src="Fig_10_9.jpg" width="500" /></p></center>
<figcaption><b><center>Fig 10.9: World Data Example</center></b></figcaption></figure>
Imagine that you have decided to move your prosperous business overseas to the country with the most business-friendly environment. After considerable study, you decide that the best measure of friendliness would be to compute the rate of growth of the gross domestic product for candidate countries, subtract their rate of population growth, and use this measure to choose the best country. An Internet search provides an interesting source of data. Figure 10.9 shows an excerpt from a spreadsheet containing historical data for 154 countries from Penn World Table Version 9.1. described in detail in this paper: Feenstra, Robert C., Robert Inklaar and Marcel P. Timmer (2015), "The Next Generation of the Penn World Table" American Economic Review, 105(10), 3150-3182, available for download at www.ggdc.net/pwt<br>
  The data columns of interest to us contain the following information:<ul>
<li><code>contrycode</code>: a TLA for each country (col A)</li>
<li><code>country</code>: name of the country (col B)</li>
<li><code>year</code>: year for which values are quoted (col C)</li>
<li><code>rgdpe</code>: Expenditure-side real GDP at chained PPPs (in mil. 2011US$) (col E)</li>
<li><code>pop</code>: Population in millions (col G)</li>
</ul>
Figure 10.9 also illustrates one of the weaknesses of spreadsheets: they are inherently two dimensional, and the data in this case are three dimensional; each country has several sets of data as functions of the year when the information was recorded. Therefore, the data must be massaged into a  form more useful to us. A careful examination of the data also reveals the following challenges:<ul>
<li>The years in which the data were available vary from country to country—most have data from 1950 to 2017</li>
<li>There are some places within the numerical data where the values are not available, signified by the blank cells at those locations.</li>
</ul>

Our algorithm must take into account the variable number of years and the potential presence of strings within the data. Fortunately, the Matlab <code>xlsread(...)</code> function discussed earlier recognizes this situation and inserts <code>NaN</code> in the numerical data fields. To ensure clarity and reliability in our solution, we need a careful design for this data processing task as follows.<ul>

<li>Looking at the end result desired, eventually we need to fold a collection of data about each country and choose the friendliest one.</li>
<li>The information describing each country must include not only its name, but also vectors of the population and CGDP as a function of the year. It seems that a structure array by country would be an appropriate form for the data.</li>
<li>Therefore, before actually solving the problem, we have to build this structure.</li>
<li>Having built the structure, the folding operation to find the friendliest country follows the folding template shown in Section 10.3.7.</li>
</ul>

Listing 10.1 shows the script that accomplishes this analysis, although most of the work is actually done in the following functions. When we run this program, we see the following result:<br>
<h3> Listing 10.1: Finding the best country</h2>
<code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Country analysis</font><br>
<font color="#0000ff">function</font> findBestCountry<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% build the country array</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;worldData = buildData(<font color="#c000c0">'../World_data.xlsx'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;best = findBest(worldData);<br>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'best country is %s\n'</font>, <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;worldData(best)<font color="#ff8000">.name</font>)<br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> besti = findBest(worldData)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% find the index of the best country</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% according to the criterion in the function</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% fold</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;best = fold(worldData(<font color="#ff8000">1</font>));<br>
&nbsp;&nbsp;&nbsp;&nbsp;besti = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ndx = <font color="#ff8000">2</font>:length(worldData)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntry = worldData(ndx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tryThis = fold(cntry);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> tryThis > best<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best = tryThis;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;besti = ndx;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> ans = fold(st)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% s1 is the rate of growth of population</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;pop = st.pop(~isnan(st.pop));<br>
&nbsp;&nbsp;&nbsp;&nbsp;yr = st.year(~isnan(st.pop));<br>
&nbsp;&nbsp;&nbsp;&nbsp;s1 = slope(yr, pop)/mean(pop);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% s2 is the rate of growth of the GDP</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;gdp = st.gdp(~isnan(st.gdp));<br>
&nbsp;&nbsp;&nbsp;&nbsp;yr = st.year(~isnan(st.gdp));<br>
&nbsp;&nbsp;&nbsp;&nbsp;s2 = slope(yr, gdp)/mean(gdp);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Measure of merit is how much faster</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% the gdp grows than the population</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;ans = s2 - s1;<br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> sl = slope(x, y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Estimate the slope of a curve</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> length(x) == <font color="#ff8000">0</font> || x(end) == x(<font color="#ff8000">1</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(<font color="#c000c0">'bad data'</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sl = (y(end) - y(<font color="#ff8000">1</font>))/(x(end) - x(<font color="#ff8000">1</font>));<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<br>
<font color="#0000ff">function</font> worldData = buildData(name)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% read the spreadsheet into a data array</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% and a text cell array</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;[nums, txt, raw] = xlsread(name,<font color="#c000c0">'data'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;country = <font color="#c000c0">' '</font>; % force the first data row<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% to change the country</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;cntry_index = <font color="#ff8000">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Traverse the data and cell arrays producing</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% an array of structures,</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% one for each country</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> row = <font color="#ff8000">1</font>:length(nums)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Because the text data in txt contains</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% the header row of the spreadsheet,</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% the data at a given numerical row belongs to the country</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% whose name is at txt{row+1}.</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% if the country name changes,</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% begin a new structure.</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> ~strcmp(txt{row+<font color="#ff8000">1</font>, <font color="#ff8000">2</font>}, country)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;col = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;country = txt{row+<font color="#ff8000">1</font>, <font color="#ff8000">2</font>};<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntry_index = cntry_index + <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntry.year = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntry.pop = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntry.gdp = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntry.name = country;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntry.year(col) = nums(row, <font color="#ff8000">1</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntry.gdp(col) = nums(row, <font color="#ff8000">2</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntry.pop(col) = nums(row, <font color="#ff8000">4</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;col = col + <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worldData(cntry_index) = cntry;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
</strong></code>

<br><br>
<code>>>best country is Bosnia and Herzegovina</code><br><br>

This may not be exactly the result we were hoping for. In Chapter 16 we will revisit this example with some better tools that will allow us to apply additional criteria to selecting countries.

<h2>Chapter Summary</h2>

This chapter presented the fundamental operations that can be applied to problem solving:<ul>
<li>Using normal arithmetic operations with specific input and output values</li>
<li>Inserting new elements in a collection</li>
<li>Traversing a collection</li>
<li>Building a collection by repetitive insertion</li>
<li>Mapping a collection—changing the values of the data items in the
collection, but not the number of them</li>
<li>Filtering a collection—reducing the number of entries, but not
changing the data contents of the collection</li>
<li>Folding the values in a collection into a single quantity</li>
<li>Searching for a specific match in a collection</li>
<li>Sorting a collection</li>
</ul>

Then we briefly discussed how to combine these fundamental tools to solve more complex data manipulation problems


[Special Characters]

[Problems]


<table align="center"> 
<tbody> 
<tr> 
<td><a href="09_Recursion.htm">previous</a></td> 
<td><a href="Contents.htm">home</a></td> 
<td><a href="11_Plotting.htm">next</a></td> 
</tr> 
</tbody> 
</table> 

</body> 
</html> 
-1.000000e+00 
