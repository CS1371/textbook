<!DOCTYPE HTML>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="styles/styles.css" />
  <script async src="./javascript/index.js"></script>
<title>Appendix D</title>
</head>
<body>
<div>#top_nav#</div>
<div class="nav-obj">#nav_obj#</div>

<div class="content">
  <h1 align="center" id="1">Appendix D - Answers to Self-Test Questions</h1>
<h2>Chapter 1</h2>
<h3>Answers to True or False</h3>
<ol><li>True.</li>
<li>False. Although Charles Babbage is usually credited with the design of the
first computer<a id="8626">!</a>, one could argue that the counting boards in use in 500 BC from
which the abacus was derived would qualify as a computer<a id="8627">!</a> design.</li>
<li>False. Operating systems arrived on the scene quite late in the development of
computers. Before then, the computer<a id="8628">!</a> ran one application that did all the work,
and this is still possible today.</li>
<li>False. The driver is just a pluggable operating<a id="8764">!</a> system component.</li>
<li>True. For a computer<a id="8629">!</a> to be useful, there has to be hardware to carry data<a id="8639">!</a> to and
from the processor.</li>
<li>True.</li>
<li>False. A solution solves the whole problem by assembling solutions to manageable
subproblems. An algorithm is a series of steps to solve a small subproblem.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>theoretical; practical</li>
<li>the Von Neumann architecture</li>
<li>virtual memory</li>
<li>utilities</li>
<li>application programs</li>
<li>logic<a id="8739">!</a></li>
<li>solutions to subproblems</li>
<li>states; states</li></ol>
<h2>Chapter 2</h2>
<h3>Answers to True or False</h3>
<ol><li>True.</li>
<li>False. Written correctly, algorithms<a id="8576">!</a> can be generalized to solve a range of subproblems.</li>
<li>True. Both functional<a id="8728">!</a> and object-oriented<a id="8763">!</a> programs require procedural<a id="8779">!</a> components
to function<a id="8712">!</a> on a processor.</li>
<li>True.</li>
<li>False. This is merely the assignment<a id="8592">!</a> of the sum of x and y to z; you cannot make
any inference about the value<a id="8808">!</a> of y from this expression.</li>
<li>False. Untyped languages merely leave the programmer free of needing to define the type of data<a id="8640">!</a>. The CPU has to have information about the nature of each
data<a id="8641">!</a> item in order to process it correctly.</li>
<li>True.</li>
<li>False. In general, especially in MATLAB<a id="8745">!</a>, the class of an item refers to its data<a id="8642">!</a>
type. The more restrictive definition combining the data<a id="8643">!</a> type with the operations<a id="8765">!</a>
performed on it is an OOP restriction.</li>
<li>False. You must use scripts<a id="8791">!</a> for<a id="8695">!</a> permanent command storage.</li>
<li>True.</li>
<li>True. Clicking the icon to the left brings up the Document window.</li>
<li>False. Double-clicking a fi le name opens the fi le in the editor.</li>
<li>True.</li>
<li>True.</li>
<li>False. The asterisk indicates that the fi le has been changed since it was saved.</li>
<li>False. Comments appear only in the text<a id="8805">!</a> of the script for<a id="8696">!</a> human understanding
of the logic<a id="8740">!</a>.</li>
<li>False. Only the % hot key saves before executing.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>Abstraction</li>
<li>An algorithm</li>
<li>side effects</li>
<li>a numeric character<a id="8612">!</a></li>
<li>name; type</li>
<li>class; object; class</li>
<li>perform calculations; perform calculations</li>
<li>double-click; repeat the execution<a id="8687">!</a></li>
<li>name; current value<a id="8809">!</a>; data<a id="8644">!</a> type</li>
<li>double-click</li>
<li>double-click; variable<a id="8816">!</a> name</li>
<li>automatically; MATLAB<a id="8746">!</a> command</li>
<li>percent sign (%)</li>
<li>ignore; the end<a id="8681">!</a> of the current line</li></ol>
<h2>Chapter 3</h2>
<h3>Answers to True or False</h3>
<ol><li>False. Homogeneous collections must consist of data<a id="8645">!</a> of the same type. This
could be double, logical<a id="8741">!</a>, char, or any of the types you saw in this text<a id="8806">!</a>.</li>
<li>True.</li>
<li>False. Because a column<a id="8623">!</a> vector has more columns than rows, it returns the
number of columns.</li>
<li>True. Regrettably, you can. This is the array<a id="8582">!</a> linearization. Should you use this?
No.</li>
<li>False. Either array<a id="8583">!</a> can be a scalar<a id="8787">!</a> quantity (a 1 x 1 array<a id="8584">!</a>).</li>
<li>True, as long as the indices in the index vector do not exceed the dimensions of A.</li>
<li>False. The position of the values in the logical<a id="8742">!</a> index vector corresponds
to the position of values in the vector being indexed. Longer logical<a id="8743">!</a> index
vectors<a id="8823">!</a> are reaching beyond the end<a id="8682">!</a> of the original vector.</li>
<li>True.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>numerical<a id="8756">!</a> value<a id="8810">!</a>; position in the vector</li>
<li>starting value<a id="8811">!</a>; increment; ending value<a id="8812">!</a></li>
<li>elements<a id="8674">!</a>; true values</li>
<li>parentheses</li>
<li>have the same dimensions; a scalar<a id="8788">!</a></li>
<li>the empty<a id="8679">!</a> vector, []; complete rows or columns</li>
<li>bad; logical<a id="8744">!</a> difficulties; indexing; copy the rows and columns you want to keep</li></ol>
<h2>Chapter 4</h2>
<h3>Answers to True or False</h3>
<ol><li>False. Comments are colored green; keywords that control execution<a id="8688">!</a> are colored
blue.</li>
<li>False. The MATLAB<a id="8747">!</a> editor inserts indentation only to clarify for<a id="8697">!</a> the reader the
flow of control in a script.</li>
<li>True. If the if statement has no else<a id="8678">!</a> clause, or the switch<a id="8804">!</a> statement has no
otherwise clause and the data<a id="8646">!</a> provided matches none of the specified cases.</li>
<li>True.</li>
<li>False. The result that invalidates all other &<a id="8772">!</a>&<a id="8773">!</a> expressions is false<a id="8689">!</a>.</li>
<li>True. But you can still use break<a id="8600">!</a> to exit the loop early.</li>
<li>False. But it ought to be. This is really bad programming<a id="8781">!</a> practice.</li>
<li>False. The expression specifi es the reason to stay in the loop.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>key command words</li>
<li>all(<a id="8579">!</a>...)</li>
<li>otherwise</li>
<li>true</li>
<li>variable<a id="8817">!</a>; values of data<a id="8647">!</a></li>
<li>for<a id="8698">!</a> or while<a id="8824">!</a>; innermost containing</li></ol>
<h2>Chapter 5</h2>
<h3>Answers to True or False</h3>
<ol><li>False. Functions have access to all the system data<a id="8648">!</a> and functions and can also
reach global<a id="8729">!</a> data<a id="8649">!</a> directly.</li>
<li>False. Although this ought to be True. MATLAB<a id="8748">!</a> calls user-defined functions by
the name of the m-fi le, and ignores the name specified there.</li>
<li>True.</li>
<li>False. Functions can be defi ned with no parameters<a id="8768">!</a> required.</li>
<li>False. Any result for<a id="8699">!</a> which a variable<a id="8818">!</a> is not provided by the caller is ignored.</li>
<li>False. This is merely a convention suggested to clarify the source of their
definition.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>Procedural abstraction<a id="8573">!</a></li>
<li>actual<a id="8574">!</a>; formal<a id="8710">!</a></li>
<li>vector-like container of variable<a id="8819">!</a> names</li>
<li>Local<a id="8737">!</a> Scope</li>
<li>first; first function<a id="8713">!</a>; other auxiliary<a id="8593">!</a> functions in the same file</li></ol>
<h2>Chapter 6</h2>
<h3>Answers to True or False</h3>
<ol><li>False. Casting changes the way the computer<a id="8630">!</a> views a piece of data<a id="8650">!</a> without
changing it.</li>
<li>True.</li>
<li>False. It can be represented within a string by inserting<a id="8732">!</a> two successive quote
marks: (' ').</li>
<li>False. MATLAB<a id="8749">!</a> will automatically cast the string to its ASCII<a id="8580">!</a> values first.</li>
<li>True. But they have to be explicitly converted to characters and concatenated
into one string.</li>
<li>False. Unequal length strings<a id="8799">!</a> are reported as not being equal<a id="8686">!</a>.</li>
<li>True.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>a special internal representation</li>
<li>characters; numbers<a id="8755">!</a>; punctuation marks; 0–127</li>
<li>uint8(...); each letter</li>
<li>format<a id="8711">!</a> control string; value<a id="8813">!</a> parameters<a id="8769">!</a></li>
<li>if; cannot</li>
<li>char(<a id="8611">!</a>...); pads them with blanks</li></ol>
<h2>Chapter 7</h2>
<h3>Answers to True or False</h3>
<ol><li>False. None of the collective operations<a id="8766">!</a> defined for<a id="8700">!</a> numerical<a id="8757">!</a> arrays can be
applied to cell<a id="8604">!</a> arrays or structures.</li>
<li>True.</li>
<li>True.</li>
<li>True.</li>
<li>False. It returns a new structure<a id="8801">!</a> with the fi eld and value<a id="8814">!</a> removed.</li>
<li>True.</li>
<li>False. If stra is a structure<a id="8802">!</a> array<a id="8585">!</a> with the field<a id="8690">!</a> data<a id="8651">!</a>, the expression {stra.data<a id="8652">!</a>}
will extract all the values into a cell<a id="8605">!</a> array<a id="8586">!</a>.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>extracted one at a time; replaced</li>
<li>arrays; containers</li>
<li>cell<a id="8606">!</a> containing 42</li>
<li>str.(field) = 42</li>
<li>struct(...); field<a id="8691">!</a> name as a string; cell<a id="8607">!</a> array<a id="8587">!</a> of field<a id="8692">!</a> contents</li></ol>
<h2>Chapter 8</h2>
<h3>Answers to True or False</h3>
<ol><li>True. Although the actual<a id="8575">!</a> storage technique on a hard drive may have blocks
of characters distributed randomly on its surface<a id="8803">!</a>, the software that reads and
writes the disk serializes the characters.</li>
<li>False. You save the variable<a id="8820">!</a> names and their current values, not the programs
that generated the data<a id="8653">!</a>.</li>
<li>False. While some applications permit delimited<a id="8669">!</a> strings<a id="8800">!</a> to be embedded in comma-
or tab-delimited<a id="8670">!</a> fi les, MATLAB<a id="8750">!</a>’s readers read only numerical<a id="8758">!</a> data<a id="8654">!</a> into arrays.</li>
<li>False. You can use the qualifi er 'a' to indicate that you will append to the end<a id="8683">!</a>
of an existing file.</li>
<li>True. If you read past the end<a id="8684">!</a> of a fi le, a numerical<a id="8759">!</a> –1 is returned.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>values; organization</li>
<li>numerical<a id="8760">!</a> values; double array<a id="8588">!</a>; text<a id="8807">!</a> data<a id="8655">!</a>; cell<a id="8608">!</a> array<a id="8589">!</a>; both string and numerical<a id="8761">!</a>
data<a id="8656">!</a>; cell<a id="8609">!</a> array<a id="8590">!</a></li>
<li>numerical<a id="8762">!</a> array<a id="8591">!</a>; filled with zero</li>
<li>system dependent (for example, in the standard version on a PC, this is indicated
by returning a file handle of –1)</li></ol>
<h2>Chapter 9</h2>
<h3>Answers to True or False</h3>
<ol><li>True.</li>
<li>False. If that function<a id="8714">!</a> or any function<a id="8715">!</a> it calls throws an exception, all the
frames down to the function<a id="8716">!</a> containing a try ... catch<a id="8603">!</a> block are popped off
the stack<a id="8797">!</a>.</li>
<li>False. Tail recursive functions perform the math "on the way in."</li>
<li>True. But this is a bad practice.</li>
<li>False. MATLAB<a id="8751">!</a> actually does not care what the name of the fi le is. When a function<a id="8717">!</a>
is called, MATLAB<a id="8752">!</a> finds the function<a id="8718">!</a> by fi le name and starts the first function<a id="8719">!</a>
in that file whatever it is called. Local<a id="8738">!</a> functions in the file must be called
from that first function<a id="8720">!</a>.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>an alternative technique</li>
<li>wrapper<a id="8826">!</a> function<a id="8721">!</a>; check for<a id="8701">!</a> erroneous data<a id="8657">!</a></li>
<li>runtime<a id="8786">!</a> errors; programming<a id="8782">!</a> errors; bad data<a id="8658">!</a></li>
<li>any tests or setup; as a helper<a id="8730">!</a> to the main function<a id="8722">!</a> call</li>
<li>compute; estimating the answer; recursive function<a id="8723">!</a>.</li></ol>
<h2>Chapter 10</h2>
<h3>Answers to True or False</h3>
<ol><li>True.</li>
<li>False. All the elements<a id="8675">!</a> might fail a test you apply to determine whether to
change them or not.</li>
<li>False. Filtering might remove elements<a id="8676">!</a> from the collection<a id="8617">!</a>, but those that remain
are not changed.</li>
<li>False. It really is folding<a id="8693">!</a> because the two results are different attributes of the
same element of the collection<a id="8618">!</a>.</li>
<li>True. The break<a id="8601">!</a> statement allows you to exit a for<a id="8702">!</a> loop early; the code<a id="8616">!</a> is a little
obscure if written this way.</li>
<li>False. Sorting requires some criterion for<a id="8703">!</a> deciding that one element must precede
another—alphabetical order is a good example.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>character<a id="8613">!</a> of the data<a id="8659">!</a>; basic operation(s) we are asked to perform</li>
<li>beginning with an empty<a id="8680">!</a> collection<a id="8619">!</a>; inserting<a id="8733">!</a> elements<a id="8677">!</a> one at a time</li>
<li>two or more collections</li>
<li>filter</li>
<li>folding<a id="8694">!</a></li>
<li>finding what you seek; failing to find it</li>
<li>traverse; writing</li></ol>
<h2>Chapter 11</h2>
<h3>Answers to True or False</h3>
<ol><li>True. If the x vector is omitted, 1:N is assumed for<a id="8704">!</a> the independent parameter,
and if the str is omitted, a solid blue line is used.</li>
<li>False. To apply to a specific data<a id="8660">!</a> plot, the enhancement functions must follow
the plotting function<a id="8724">!</a>.</li>
<li>False. Any area not provided with a plot remains blank.</li>
<li>True.</li>
<li>False. Bodies of rotation, for<a id="8705">!</a> example, use one of the axis directions as an independent
parameter.</li>
<li>False. It is the x and z axes (those axes not the axis of rotation).</li>
<li>False. The curve<a id="8633">!</a> does not need to be continuous.</li>
<li>False. You can rotate the data<a id="8661">!</a> to align an arbitrary axis with the x-axis, perform
the body of rotation there, and invert the rotation.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>new figure; the next higher</li>
<li>clf<a id="8614">!</a>; close<a id="8615">!</a> all</li>
<li>dependent; separate; independent</li>
<li>z; an x-y plaid<a id="8776">!</a></li>
<li>plaid<a id="8777">!</a>; angles</li>
<li>linear<a id="8735">!</a> curve<a id="8634">!</a>; specified axis</li>
<h2>Chapter 12</h2>
<h3>Answers to True or False</h3>
<ol><li>True. Even the most primitive data<a id="8662">!</a> members encapsulate their data<a id="8663">!</a> and control
the operations<a id="8767">!</a> that can be performed on the data<a id="8664">!</a>.</li>
<li>False. It also works if one or both of the matrices<a id="8753">!</a> are scalar<a id="8789">!</a>.</li>
<li>True, only if one is a scalar<a id="8790">!</a>; otherwise, False. If A and B are not square<a id="8795">!</a>, one
will fail; even if they are square<a id="8796">!</a>, they will have different answers.</li>
<li>True.</li>
<li>False. It is equivalent to back dividing: A \ B.</li>
<li>True.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>data<a id="8665">!</a>; procedural<a id="8780">!</a></li>
<li>column<a id="8624">!</a>; row</li>
<li>translate the object; perform the rotation; translate the rotated object back to P</li>
<li>N independent; N unknown; N * (N + 1) constant</li></ol>
<h2>Chapter 13</h2>
<h3>Answers to True or False</h3>
<ol><li>False. 0 is the absence of light, which will give a black<a id="8599">!</a> screen.</li>
<li>True. imread(...) can be adapted to read any supported image fi le, returning
different results for<a id="8706">!</a> different image styles.</li>
<li>True.</li>
<li>False. For two reasons—it only works for<a id="8707">!</a> 2-D arrays, and the rotation is counter-
clockwise.</li>
<li>True. Consider Figure 13.18 . The original number of 1600x1200x3 pixels<a id="8774">!</a> has
been reduced to a smattering of pixels<a id="8775">!</a> of interest.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>three; uint8; 0–255</li>
<li>pixel; uint8</li>
<li>decoded; true color<a id="8621">!</a>; three color<a id="8622">!</a> layers.</li>
<li>figure window; image(<a id="8731">!</a>...)</li>
<li>Cropping; shrinking<a id="8792">!</a>; stretching<a id="8798">!</a></li>
<li>transpose; major diagonal<a id="8671">!</a></li></ol>
<h2>Chapter 14</h2>
<h3>Answers to True or False</h3>
<ol><li>True.</li>
<li>False. Removing samples raises the frequency.</li>
<li>False. The number of bits<a id="8598">!</a> in the recording<a id="8785">!</a> has no significant effect on an
untrained ear.</li>
<li>True.</li>
<li>True.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>amplitude; frequency</li>
<li>A/D<a id="8572">!</a>; D/A; pressure</li>
<li>7; 5; 2; 12</li>
<li>sound<a id="8794">!</a> energy; frequency band</li></ol>
<h2>Chapter 15</h2>
<h3>Answers to True or False</h3>
<ol><li>True. The provision is that while<a id="8825">!</a> the linear<a id="8736">!</a> interpolation<a id="8734">!</a> does not give an error,
it returns NaN<a id="8754">!</a> for<a id="8708">!</a> data<a id="8666">!</a> points that are out of range.</li>
<li> True. There is a unique cubic<a id="8631">!</a> parametric<a id="8770">!</a> curve<a id="8635">!</a> between each pair of points. The
curve<a id="8636">!</a> is parametric<a id="8771">!</a> rather than a function<a id="8725">!</a> of the independent variable<a id="8821">!</a> in order
to permit the curve<a id="8637">!</a> to "double back" if necessary for<a id="8709">!</a> smoothness.</li>
<li>False. All curve<a id="8638">!</a> fitting does is provide the coefficients of a polynomial<a id="8778">!</a>. You can
insert any value<a id="8815">!</a> of the independent variable<a id="8822">!</a>.</li>
<li>True.</li>
<li>True. Simpson’s<a id="8793">!</a> rule better captures fluctuations in the function<a id="8726">!</a> being integrated.</li>
<li>False. The diff(<a id="8672">!</a>...) function<a id="8727">!</a> shortens the vector by one element.</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>Interpolation</li>
<li>coefficients of the equation; sum of the squared distances</li>
<li>central<a id="8610">!</a> difference approximation<a id="8581">!</a>; slope</li>
<li>cumsum(<a id="8632">!</a>...); dot<a id="8673">!</a> product; the data<a id="8667">!</a> vector; a vector of time differences</li>
<li>critical point; differentiating</li></ol>
<h2>Chapter 16</h2>
<h3>Answers to True or False</h3>
<ol><li>True. First we perform all the algebra to reduce the compound<a id="8625">!</a> expression to a
sequential series of O(…) values, and then we add them and remove any terms
that increase more slowly with N than other terms.</li>
<li>False. Linear search algorithms<a id="8577">!</a> are O(N), but binary<a id="8597">!</a> search is O(log N).</li>
<li>True. Mathematicians have proven that one cannot sort with a faster Big<a id="8594">!</a> O.
However, better algorithms<a id="8578">!</a> can provide a constant multiplier improvement.</li>
<li>False. Most of them have some kind of optimization that reduces the length of
the minor passes.</li>
<li>True. Since Big<a id="8595">!</a> O should refl ect the worst case<a id="8602">!</a> performance, and quick<a id="8783">!</a> sort on
a sorted collection<a id="8620">!</a> is O(N<sup>2</sup> ).</li></ol>
<h3>Answers to Fill in the Blanks</h3>
<ol><li>Big<a id="8596">!</a> O; work; data<a id="8668">!</a></li>
<li>N</li>
<li>Merge; quick<a id="8784">!</a></li>
<li>Bubble; Quick</li>
<li>ad at the end<a id="8685">!</a>; or string</li>
 </div>


</body>
</html>


