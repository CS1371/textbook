<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"> 
<html> 
<head> 
<title>07_Structures</title> 
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />    <link rel="stylesheet" href="styles/styles.css" />
<link rel="stylesheet" href="styles/styles.css" /> 
<script async src="./javascript/index.js"></script> 
</head> 
<body bgcolor="#ffffff"> 
<h1 align="center">Chapter 7: Cell Arrays and Structures</h1> 

<table align="center"> 
<tbody> 
<tr> 
<td><a href="06_Strings.htm">previous</a></td> 
<td><a href="Contents.htm">home</a></td> 
<td><a href="08_File_I_O.htm">next</a></td> 
</tr> 
</tbody> 
</table>
<ul>
<li><a href="#7_1">7.1  Concept: Collecting Dissimilar  Objects</a>
<li><a href="#7_2">7.2   Cell Arrays</a>
<ul>
    <li><a href="#7_2_1">7.2.1  Creating Cell Arrays</a>
    <li><a href="#7_2_2">7.2.2  Accessing Cell Arrays</a>
    <li><a href="#7_2_3">7.2.3  Using Cell Arrays</a>
    <li><a href="#7_2_4">7.2.4  Processing Cell Arrays</a>
</ul>
<li><a href="#7_3">7.3  Structures</a>
<ul>
    <li><a href="#7_3_1">7.3.1  Constructing and Accessing One Structure</a>
    <li><a href="#7_3_2">7.3.2  Constructor Functions</a>
</ul>
<li><a href="#7_4">7.4   Structure Arrays</a>
<ul>
    <li><a href="#7_4_1">7.4.1  Constructing Cell Arrays</a>
    <li><a href="#7_4_2">7.4.2  Accessing Structure Elements</a>
    <li><a href="#7_4_3">7.4.3  Manipulating Structures</a>
</ul>
<li><a href="#7_5">7.5  Comparing Cell Arrays to Structure Arrays</a>
<li><a href="#7_6">7.6  Engineering Example: Assembling a Physical Structure</a>
</ul>
<h2>Chapter Objectives</h2>

<p>This chapter discusses the nature, implementation, and behavior of collections that may contain data items of any class, size, or shape. We will deal with two different heterogeneous storage mechanisms: 
<ul>
<li>Those accessed by index (cell arrays) </li>

<li>Those accessed by field name (structures) </li>
</ul>
In addition, we will consider collecting structures into arrays of structures. 
<! ––<video width="320" height="240" autoplay>
  <source src="klein_bottle.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>––>
<h1>Introduction</h1>
 This chapter covers data collections that are more general and flexible than the <b>homogeneous</b> arrays we have considered so far. Conceptually, <b>heterogeneous</b> collections may contain objects of any type, rather than just numbers. Consequently, none of the collective operations defined for numerical arrays can be applied to cell arrays or structures. To perform most operations on their contents, the items must be extracted one at a time and replaced if necessary. We will consider three different mechanisms for building heterogeneous collections:
 <ui>
 <li>you access components of a <b>cell array</b> with a numerical index;</li>
 <li>you access components of a <b>structure</b> with a symbolic field name; and</li>
 <li>you access components of a <b>structure array</b> by way of a numerical index to reach a specific structure then a symbolic field name.</li>  
 </ui></p>
<h2><a name="7_1">7.1	Concept: Collecting Dissimilar Objects</a></h2>
<p>Heterogeneous collections permit objects of different data types to be grouped in a collection. They allow data abstraction to apply to a much broader range of content. However, the fact that the contents of these collections may be of any data type severely restricts the operations that can be performed on the collections as a whole. Whereas a significant number of arithmetic and logical operations can be performed on whole number arrays, algorithms that process heterogeneous collections almost always deal with the data contents one item at a time.<br>
<b>Insignificant Footnote:</b> There is a fundamental aspect of computing that is carefully hidden by the Matlab but fully exposed in other languages especially Java. That aspect is this: computer languages that deal with complex concepts such as the subject of this chapter actually need to implement the classes that define behavior in a hierarchy.  At the root of that hierarchy in Java is a class called Object, and all Java classes actually respond as if they were Objects in addition to their specific behavior.  Matlab hides exactly the same behavior. Hence, while we discuss these collections as if they were heterogeneous, because of this hierarchy, the Matlab infrastructure treats them as homogeneous collections of Objects.</p>

<h2><a name="7_2">7.2	Cell Arrays</a></h2>

<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="250" src="Fig_7_1.jpg" width="450" /></p>
<figcaption><b><center>Fig 7.1 Conceptual Cell Array</center></b></figcaption></figure>

Cell arrays, as the name suggests, have the general form of arrays and can be indexed numerically as arrays. However, each element of a cell array should be considered as a container in which one data object of any class can be stored. They can be treated as arrays of containers for the purpose of concatenation and slicing. However, if you wish to access or modify the contents of the containers, the cells must be accessed individually.<br>
<b>Nomenclature:</b> Cells and cell arrays have dual meanings.  In one sense, the braces specify a <b>cell</b>, a <b>container</b> of whatever is inside the braces. The other sense suggests that within the cell is an arbitrary <b>collection of objects</b> we will refer to as a cell's <b>contents</b>.
 
<h3><a name="7_2_1">7.2.1	Creating Cell Arrays</a></h3>
Cell arrays may be constructed in the following ways: 
 <ui>
 <li>By assigning values individually to a variable indexed with braces:<br>
 <code>>> A{1} = 42<br>
 A =<br>
 &nbsp;&nbsp;&nbsp;&nbsp;[42] </li></code>
 <li>By assigning anything contained within braces individually to a variable normally indexed with parentheses:<br>
 <code>>> B(1) = {[4 6]};<br>
 B =<br>
 &nbsp;&nbsp;&nbsp;&nbsp;[1x2 double] </code></li>
 <li>By concatenating cell contents using braces <code>{. . .}:<br>
 >> C = {3, [1,2,3], 'abcde'}<br>
 C = <br>
 &nbsp;&nbsp;&nbsp;&nbsp;[3] [1x3 double] 'abcde'</li></code>
 <li>By concatenating cell containers:<br>
 <code>>> D = [A B C {'xyz'}]<br>
 D = <br>
&nbsp;&nbsp;&nbsp;&nbsp;[42] [1x2 double] [3] [1x3 double] 'abcde' 'xyz'</li> </code> 
<div class="container">
  <div class="sidebar_R">
<h4>Exercise 7.1 Cell Arrays Distributing Data</h4>
<code>
>> A = { 3, [1,2,3] 'abcde'}<br>
A =<br>
[3] [1x3 double] 'abcde'<br>
>> A{1:2} <font color="#00A000">% fetching multiple cells makes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% multiple assignments</font><br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;3<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 2 3<br>
>> [x y] = A{1:2}<font color="#00C000"> % providing variables<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% causes appropriate assignments</font><br>
x =<br>
&nbsp;&nbsp;&nbsp;&nbsp;3<br>
y =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 2 3<br>
>> B = A{1:2}<font color="#00C000"> % can't provide one variable<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% for multiple assignments</font><br>
<font color="#A00000">??? Illegal right-hand side in assignment.<br>
Too many elements.</font><br>
>> B([1 3]) = A([1 2])<font color="#00C000"> % can provide indexed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% spaces for multiple assignments. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Notice that B(2) wasn't assigned;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% filled with []</font><br>
B =<br>
&nbsp;&nbsp;&nbsp;&nbsp;[3] [] [1x3 double]<br>
>> B{[1 3]} = A{[1 2]}<font color="#00C000"> % Left hand side cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% indexing fails</font><br>
<font color="#A00000">??? Illegal right-hand side in assignment.<br>
Too many elements.</font><br>
>> [a, b, c] = deal(A{:})<font color="#00C000"> % deal(...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% indexed to deliver cells<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% works</font><br>
a =<br>
&nbsp;&nbsp;&nbsp;&nbsp;3<br>
b =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 2 3<br>
c =<br>
&nbsp;&nbsp;&nbsp;&nbsp;abcde<br>
>> [a, b] = deal(A)<font color="#00C000"> % deal(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% without extracting cells delivers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% just one object to each<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% LHS variable</font><br>
a =<br>
&nbsp;&nbsp;&nbsp;&nbsp;[3] [1x3 double] 'abcde'<br>
b =<br>
&nbsp;&nbsp;&nbsp;&nbsp;[3] [1x3 double] 'abcde'<br>
>> B = A(1:2)<font color="#00C000"> % This is normal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% indexing applied to cells</font><br>
B =<br>
[3] [1x3 double]<br>
>> F{2} = 42<font color="#00C000"> % So is this</font><br>
F =<br>
[] [42]<br>
>> F{3} = {42}<font color="#00C000"> % Braces on both sides of the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% assignment cause a container<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% cell to be stored</font><br>
F =<br>
[] [42] {1x1 cell}<br>
</code>
</div>
<div class="container">
<br>
 Based on these examples, we observe the following:
<ul>
<li>A cell array can contain any legal MATLAB object</li>
<li>Just as with numerical arrays, cell arrays can be created "on the fly" by assigning values to an indexed variable. </li>
<li> When the values from a cell array are displayed, their appearance is different from that of the contents of a numerical array.
<ul>
<li>Individual numbers, vectors and arrays are shown in brackets, for example, <code>[1 2 3];</code></li>
<li>larger numerical arrays display their size, for example, <code>[2&#215;3 double]</code>; and</li>
<li>character strings are displayed with the enclosing quotes, for example, <code>'abcde'</code>. </li>
</li>
</ul>
</ul>
<h3><a name="7_2_2">7.2.2	Accessing Cell Arrays</a></h3>
Since cell arrays can be considered as conventional arrays of containers, the containers can be accessed and manipulated normally. For example, continuing the previous examples, we have the following:<br>
 <code>>> E = D(2) % parentheses - fetching a container<br>
E = <br>
&nbsp;&nbsp;&nbsp;&nbsp;[4 6]</code><br>
However, braces are used to access the contents of the containers as follows:<br>
<code>>> D{2} % braces - fetching the contents<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;4 6</code><br>
Exercise 7.1 shows details of cell indexing behavior. <br>
<b>Lessons to learn:</b>
<ui>
<li>If the right-hand side of an assignment statement results in multiple cell arrays, the assignment must be to the same number of variables.</li>
<li> The built-in function <code>deal(...)</code> is used to make these allocations.</li>
 <li>When we extract the contents of multiple cells using, for example,<code> A{1:2}</code>, this results in multiple assignments being made. </li>
 <li>These multiple assignments must go to separate variables. This is the fundamental mechanism behind returning multiple results from a function.</li>
 <li>These multiple assignments cannot be made to a single variable; sufficient storage must be provided either as a collection of variables or explicitly as a vector.</li>
 <li>Cell arrays can be “sliced” with normal vector indexing assignments as long as the sizes match on the left and right sides of the assignment. Any unassigned array elements are filled with an empty vector.</li>
 <li>The assignment <code>B{[1 3]} = A{[1 2]}</code> that produced an error needs some thought. Since <code>A{[1 2]}</code> produces two separate assignments, MATLAB will not assign the answers, even to the right number of places in another cell array.</li>
<li> The <code>deal(...)</code> function is provided to capture these multiple results in different variables. Notice the difference between using <code>A{:}</code> and <code>A</code> as a parameter to <code>deal(...)</code>. When <code>deal(...)</code> is provided with a parameter other than a collection of cells, it merely copies that parameter to each variable.</li>
<li>Assignments work normally if cell arrays are treated as vectors and the extraction of items can be indexed — <code>s</code> is a vector of the sums of the elements in <code>A</code>.</li>
<li>When accessing cell arrays, it is normal to have braces on one side or the other of an assignment; it is rarely appropriate to have braces on both sides of an assignment. The result in the last example is that a container is loaded into the third container in the cell array.</li>  
</div>
<h3><a name="7_2_3">7.2.3	Using Cell Arrays</a></h3>
 There are a number of uses for cell arrays, some of which will be evident in upcoming chapters. For now, the following examples will suffice:<ul>
 <li>Containing lists of possible values for switch/case statements, as we saw in Chapter 4</li>
 <li>Substituting for parameter lists in function calls.  For example, suppose you have a function largest(a, b, c) that consumes three variables and produces the largest of the three values provided. It can be used in the following styles, as shown in Listing 7.1. <br>
 </div>
 <h4>Listing 7.1: Cell arrays of parameters</h4>
 <code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;clear; clc<br>
&nbsp;&nbsp;&nbsp;&nbsp;A = <font color="#ff8000">4</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;B = <font color="#ff8000">6</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;C = <font color="#ff8000">5</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;N = largest(A, B, C) <font color="#00A000">% Conventional function call</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;params = { <font color="#ff8000">4</font>, <font color="#ff8000">6</font>, <font color="#ff8000">5</font> };<br>
&nbsp;&nbsp;&nbsp;&nbsp;N = largest(params{<font color="#ff8000">1</font>:<font color="#ff8000">3</font>})
 <font color="#00A000">% Explicit parameter list</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;N = largest({<font color="#ff8000">4</font>, <font color="#ff8000">6</font>, <font color="#ff8000">5</font>})
 <font color="#00A000">% Implicit parameter list</font><br>
 <br>
<font color="#0000ff">function</font> it = largest(r, s, t)<br>
&nbsp;&nbsp;&nbsp;&nbsp;it = max([r s t]);<br>
<font color="#0000ff">end</font><br>
</strong></code>

<h3><a name="7_2_4">7.2.4	Processing Cell Arrays</a></h3>
 <div class="container">
  <div class="sidebar_R">
<h4>Template 7.1 General Template for Processing a Cell Array</h4>
<code>&lt;initialize result&gt;<br>
for &lt;index specification&gt;<br>
&nbsp;&nbsp;&lt;extract an element&gt;<br>
&nbsp;&nbsp;&lt;check the element accordingly&gt;<br>
&nbsp;&nbsp;&lt;process the element accordingly&gt;<br>
end<br>
&lt;finalize result&gt;<br></code>
</div>
<div class="container">
 The general template for processing cell arrays is shown in Template 7.1. Checking the class of the element can be achieved in one of two ways:
 <ul>
 <li>The function <code>class(item)</code> returns a string specifying the item type that can be used in a switch statement</li>
 <li>Individual test functions can be used in an <code>if... elseif</code> construct; examples of the individual test functions are <code>isa(item, 'class')</code>, <code>iscell(...)</code>, <code>ischar(...)</code>, <code>islogical(...)</code>, <code>isnumeric(...)</code>, and <code>isstruct(...)</code>. </li>
 </ul>
 <p>For example, suppose you are provided with a cell array and have been asked for a function that finds the total length of all the vectors it contains. The function might look like that shown in Listing 7.2. 
 <h4>Listing 7.2: Cell array processing example</h4>
 </div>
 <code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;clear; clc<br>
&nbsp;&nbsp;&nbsp;&nbsp;it = totalNums({<font color="#ff8000">1</font>:<font color="#ff8000">3</font> {<font color="#ff8000">4</font> <font color="#ff8000">9</font>} <font color="#ff8000">42</font> {{{<font color="#ff8000">4</font>}}}})<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
<font color="#0000ff">function</font> ans = totalNums(ca)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% count the numbers in a cell array</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;ans = <font color="#ff8000">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> in = <font color="#ff8000">1</font> :length(ca)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item = ca{in} ; <font color="#00A000">% extract the item</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type = class(item); <font color="#00A000">% determine its type</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">switch</font> type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">case</font> <font color="#c000c0">'double'</font>  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% add the number to the total</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Recall that the size(...) function returns<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% a vector of the sizes of each dimension. The total number <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%of numbers is therefore the product of these values.</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans = ans + prod(size(item));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">case</font> <font color="#c000c0">'cell'</font> <font color="#00A000">% use this function on the embedded cell array</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans = ans + totalNums(item);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% ignore any other types</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
</strong></code>
MATLAB provides two functions that can cast data between a cell array containing only numbers, <code>ca</code>, and a numerical array, <code>arr</code>:<br>
<code>arr = cell2num(ca) % consumes a cell array and returns a numerical array<br>
</code>and<br>
<code>ca = num2cell(arr) % consumes a number array and returns a cell array<br>
</code> 
<h2><a name="7_3">7.3 Structures</a></h2>
<figure style="float: right; margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="250" src="Fig_7_2.jpg" width="450" /></p>
<figcaption><b><center>Fig 7.2 Conceptual Structure Array</center></b></figcaption></figure>

 Where cell arrays implemented the concept of homogeneous collections as indexed collections, a structure provides for items to be accessed by field name rather than by indexing. Most modern languages implement the concept of a structure in a similar style. The data contained in a structure are referenced by field name, for example, <code>item1</code>. The rules for making a field name are the same as those for a variable. Fields of a structure, like the elements of a cell array, are heterogeneous — they can contain any MATLAB object. First, we will see how to construct and manipulate one structure, and then how to aggregate individual structures into an array of structures.  
<h3><a name="7_3_1">7.3.1	Constructing and Accessing One Structure</a></h3>
 To set the value of items in a structure <code>A</code>, the syntax is as follows:<br>
<code>&gt;&gt;  A.item1 = 'abcde'<br>
A =<br> 
&nbsp;&nbsp;&nbsp;&nbsp;item1: 'abcde'<br>
&gt;&gt; A.item2 = 42<br>A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;item1: 'abcde'<br>
&nbsp;&nbsp;&nbsp;&nbsp;item2: 42<br></code>
Notice that MATLAB displays the elements of an emerging structure by name. Fields in a structure are accessed in the same way — by using the dotted notation.<br>
<code>&gt;&gt; A.item2 = A.item2 ./ 2<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;item1: 'abcde'<br>
&nbsp;&nbsp;&nbsp;&nbsp;item2: 21<br>
</code>
You can determine the names of the fields in a structure using the built-in function <code>fieldnames(...)</code>. It returns a cell array containing the field names as strings.<br>
<code>>> names = fieldnames(A)<br>
names = <br>
&nbsp;&nbsp;&nbsp;&nbsp;'item1' 'item2'<br></code>
Fields can also be accessed “indirectly” by setting a variable to the name of the field, and then by using parentheses to indicate that the variable contents should be used as the field name:<br>
<code>>> fn = names{1};<br>
>> A.(fn) = [A.(fn) 'fg']<br>
A =<br>
&nbsp;&nbsp;&nbsp;&nbsp;item1: 'abcdefg'<br>
&nbsp;&nbsp;&nbsp;&nbsp;item2: 21</code><br>
 <div class="container">
  <div class="sidebar_R">
<h4>Exercise 7.2: Building structures</h4>

Suppose that you want to use structures to maintain your address book. In the
Command window, enter the following commands:<br>
<code>>> entry.first = 'Fred'<br>
entry =<br>
&nbsp;&nbsp;&nbsp;&nbsp;first: 'Fred'<br>
>> entry.last = 'Jones';<br>
>> entry.phone = '(123) 555-1212'<br>
entry =<br>
&nbsp;&nbsp;&nbsp;&nbsp;first: 'Fred”<br>
&nbsp;&nbsp;&nbsp;&nbsp;last: 'Jones'<br>
&nbsp;&nbsp;&nbsp;&nbsp;phone: '(123) 555-1212'<br>
>> entry.phone<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;(123) 555-1212<br>
>> date.day = 31;<br>
>> date.month = 'February';<br>
>> date.year = 1965<br>
date =<br>
&nbsp;&nbsp;&nbsp;&nbsp;day: 31<br>
&nbsp;&nbsp;&nbsp;&nbsp;month:'February'<br>
&nbsp;&nbsp;&nbsp;&nbsp;year: 1965<br>
>> entry.birth = date<br>
entry =<br>
&nbsp;&nbsp;&nbsp;&nbsp;first: 'Fred'<br>
&nbsp;&nbsp;&nbsp;&nbsp;last: 'Jones'<br>
&nbsp;&nbsp;&nbsp;&nbsp;phone: '(123) 555-1212'<br>
&nbsp;&nbsp;&nbsp;&nbsp;birth: [1x1 struct]<br>
>> entry.birth<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;day: 31<br>
&nbsp;&nbsp;&nbsp;&nbsp;month: 'February'<br>
&nbsp;&nbsp;&nbsp;&nbsp;year: '1965'<br>
>> entry.birth.year<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;1965<br></code>
</div>
 You can also remove a field from a structure using the built-in function <code>rmfield(...)</code>. Its specification is:<br>
 <code>function &lt;res&gt; = rmfield(&lt;str&gt;, &lt;fld_name&gt;)</code><br>
 where <code>&lt;str&gt;</code> represents a structure consumed by the function<br>
<code>&lt;fld_name&gt;</code> represents a field name and<br>
<code>&lt;res&gt;</code> represents a structure returned with the field removed. <br>
You must remember the scope rules for variables within a function. Code inside a function has no ability to "reach outside" that function to affect any changes at all to the workspace of the code that called the function. The only real problem here is the name of the function, <code>rmfield(...)</code>, which suggests that mystically, this function removes the field in <code>&lt;fld_name&gt;</code> from the structure <code>&lt;str&gt;</code> passed in. It probably should have been called <code>return_a_copy_of_the_structure_with_the_specified_field_removed(...)</code>!<br>
 
 Exercise 7.2 gives you an opportunity to understand how to build structures. Here we build a typical structure that could be used as one entry in a telephone book. Since phone numbers usually contain punctuation, we could store them as strings. Notice that since a structure may contain any object, it is quite legal to make a structure containing a date and insert that structure in the date field of the entry. The structure display function, however, does not display the contents of the structures.  
<h3><a name="7_3_2">7.3.2	Constructor Functions</a></h3>
 This section discusses functions that assign their parameters to the fields of a structure and then return that structure. You do this, as opposed to “manually” entering data into structures, for the following reasons:
 <ul>
 <li>Manual entry can result in strange behavior due to typographical errors or having fields in the wrong order</li>
 <li>The resulting code is generally more compact and easier to understand</li>
 <li>When constructing collections of structures, it enforces consistency across the collections.
</li>
 </ul> There are two approaches to the use of constructor functions: using built-in capabilities or writing your own constructor. <br>
<b>Built-in Constructor: </b> There is a built-in function, <code>struct(...)</code>, that consumes pairs of entries, each consisting of a field name as a string and a cell array of field contents and produces a structure. If all the cell arrays have more than one entry, this actually creates a structure array, as discussed in Section 7.4.1.  The following command would construct the address book entry created in the previous section. Note the use of ellipses <code>(...)</code> to indicate to the MATLAB machinery that the logic is continued onto the next line.<br>
 
 <code>>>struct('first','Fred', ...<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'last','Jones', ... <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'phone','(123) 555-1212', ...<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'birth', struct( 'day', 31, 'month', 'February', 'year', 1965 ))<br>
 ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;first: 'Fred'<br>
&nbsp;&nbsp;&nbsp;&nbsp;last: 'Jones'<br>
&nbsp;&nbsp;&nbsp;&nbsp;phone: '(123) 555-1212'<br>
&nbsp;&nbsp;&nbsp;&nbsp;birth: [1x1 struct]<br>
</code> <br>
<div class="container">
  <div class="sidebar_R">
<h4>Exercise 7.3: A Custom CD structure</h4>
Create one entry of CD information:<br>
<code>>> CD = makeCD('Blues', 'Charles, Ray', ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;'Genius Loves Company', 2004, 4.5, 15.35 )<br>
CD =<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre: 'Blues'<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist: 'Charles, Ray'<br>
&nbsp;&nbsp;&nbsp;&nbsp;title: 'Genius Loves Company'<br>
&nbsp;&nbsp;&nbsp;&nbsp;year: 2004<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars: 4.5000<br>
&nbsp;&nbsp;&nbsp;&nbsp;price: 15.3500<br>
>> flds = fieldnames(CD)<br>
flds =<br>
&nbsp;&nbsp;&nbsp;&nbsp;'genre'<br>
&nbsp;&nbsp;&nbsp;&nbsp;'artist'<br>
&nbsp;&nbsp;&nbsp;&nbsp;'title'<br>
&nbsp;&nbsp;&nbsp;&nbsp;'year'<br>
&nbsp;&nbsp;&nbsp;&nbsp;'stars'<br>
&nbsp;&nbsp;&nbsp;&nbsp;'price'<br>
>> field = flds{2}<br>
field =<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist<br>
>> CD.(field)<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;Charles, Ray<br>
</code>
</div>
<b>Custom Constructor:</b>The <code>struct(...)</code> constructor is useful in general to create structures, but the need to repeat the field names makes this general-purpose approach a little annoying. We can create a special-purpose function that “knows” the necessary field names to create multiple structures in an organized way.  Listing 7.3 shows the code for a function that consumes parameters that describe a CD and assembles a structure containing those attributes by name.<br>

<h4>Listing 7.3: a CD constructor</h4>
<code><strong>
<font color="#0000ff">function</font> ans = makeCD(gn, ar, ti, yr, st, pr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% integrate CD data into a structure</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;ans.genre = gn ;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ans.artist = ar ;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ans.title = ti;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ans.year = yr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ans.stars = st;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ans.price = pr;<br>
<font color="#0000ff">end</font><br>
</strong></code>
  In Exercise 7.3, you can try your hand at using this function to construct a CD structure and then verify the structure contents.  
  
<h2><a name="7_4">7.4 Structure Arrays</a></h2>
 To be useful, collections like address books or CD collections require multiple structure entries with the same fields. This is accomplished by forming an array of data items, each of which contains the same fields of information.  MATLAB implements the concept of structure arrays with the properties described in the following paragraphs.  
<h3><a name="7_4_1">7.4.1	Constructing Structure Arrays</a></h3>
 Structure arrays can be created either by using MATLAB’s <code>struct(...)</code> function to build the whole structure array, or by using a custom function to create each individual structure. <br>
 
<b>Built-in Constructor:</b> Listing 7.4 illustrates these concepts by implementing a collection of CDs as a structure array using the function <code>struct(...)</code> from Listing 7.3.<br>
 <h4>Listing 7.4: Building a structure <i>array</i> using <code>struct(...)</code></h4>
 <code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;clear; clc<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Build cell arrays containing field values for three CDs.</font><br>

&nbsp;&nbsp;&nbsp;&nbsp;genres = {<font color="#c000c0">'Blues'</font>, <font color="#c000c0">'Classical'</font>, <font color="#c000c0">'Country'</font> };<br>
&nbsp;&nbsp;&nbsp;&nbsp;artists = {<font color="#c000c0">'Clapton, Eric'</font>, <font color="#c000c0">'Bocelli, Andrea'</font>, <font color="#c000c0">'Twain, Shania'</font> };<br>
&nbsp;&nbsp;&nbsp;&nbsp;years = { <font color="#ff8000">2004</font>, <font color="#ff8000">2017</font>, <font color="#ff8000">1984</font> };<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars = { <font color="#ff8000">2</font>, <font color="#ff8000">4.6</font>, <font color="#ff8000">3.9</font> };<br>
&nbsp;&nbsp;&nbsp;&nbsp;prices = { <font color="#ff8000">18.95</font>, <font color="#ff8000">14.89</font>, <font color="#ff8000">13.49</font> };<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds = struct( <font color="#c000c0">'genre'</font>, genres, <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#c000c0">'artist'</font>, artists, <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#c000c0">'year'</font>, years, <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#c000c0">'stars'</font>, stars, <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#c000c0">'price'</font>, prices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
</strong></code>

 When using the built-in <code>struct(...)</code> function to create a structure array, the form of the function call is identical to that used in Para 7.3.2. The only difference is the usage of the second parameter of each field_name/value pair. If the value is a cell array, the structure to be created becomes a structure array whose size (in the general sense) is the size of that cell array. Then, each field of the structure array receives the corresponding value from the cell array. If the field content is anything other than a cell array, the content of each structure array field becomes a copy of that item.  It is possible that the first field may not have a cell array as its value such as, for example, a last_name field. The first field whose value is a cell array will define the size of the structure array.  Subsequent fields may have the same size, but it is illegal for any subsequent fields to have cell array of a different size.<br>

<b>Built-in Constructor:</b> Listing 7.5 illustrates these concepts by implementing a collection of CDs as a structure array using the function <code>makeCD(...)</code> from Listing 7.3.<br>
 <h4>Listing 7.5: Building a structure <i>array</i> using a custom constructor</h4>
<code><strong>
&nbsp;&nbsp;&nbsp;&nbsp;clear; clc<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Data from www.cduniverse.com on 1/21/06</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;cds( <font color="#ff8000">1</font>) = makeCD( <font color="#c000c0">'Punk'</font>, 'Get Behind Me Satan', <font color="#c000c0">'White Stripes'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">3.7</font>, <font color="#ff8000">14.59</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds( <font color="#ff8000">2</font>) = makeCD( <font color="#c000c0">'Punk'</font>, 'Complete Discography', <font color="#c000c0">'Minor Threat'</font>, <font color="#ff8000">1990</font>, <font color="#ff8000">4.4</font>, <font color="#ff8000">10.39</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds( <font color="#ff8000">3</font>) = makeCD( <font color="#c000c0">'Punk'</font>, 'Fresh Fruit For Rotting Vegetables', <font color="#c000c0">'Dead Kennedys'</font>, <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ff8000">1980</font>, <font color="#ff8000">5</font>,  <font color="#ff8000">14.29</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds( <font color="#ff8000">4</font>) = makeCD( <font color="#c000c0">'Punk'</font>, 'Take This To Your Grave', <font color="#c000c0">'Fall Out Boy'</font>, <font color="#ff8000">2003</font>, <font color="#ff8000">4.4</font>, <font color="#ff8000">9.75</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds( <font color="#ff8000">5</font>) = makeCD( <font color="#c000c0">'Punk'</font>, 'Stories And Alibis', <font color="#c000c0">'Matchbook Romance'</font>, <font color="#ff8000">2003</font>, <font color="#ff8000">4.4</font>, <font color="#ff8000">9.75</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds( <font color="#ff8000">6</font>) = makeCD( <font color="#c000c0">'Heavy metal'</font>, 'Rosenrot', <font color="#c000c0">'Rammstein'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">4.1</font>, <font color="#ff8000">17.79</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds( <font color="#ff8000">7</font>) = makeCD( <font color="#c000c0">'Heavy metal'</font>, 'Elements Of Persuasion', <font color="#c000c0">'James Labrie'</font>, <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ff8000">2005</font>, <font color="#ff8000">4.4</font>, <font color="#ff8000">14.29</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds( <font color="#ff8000">8</font>) = makeCD( <font color="#c000c0">'Heavy metal'</font>, 'Second Life Syndrome', <font color="#c000c0">'Riverside'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">4.1</font>, <font color="#ff8000">13.89</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds( <font color="#ff8000">9</font>) = makeCD( <font color="#c000c0">'Heavy metal'</font>, 'Still Life', <font color="#c000c0">'Opeth'</font>, <font color="#ff8000">2000</font>, <font color="#ff8000">4.8</font>, <font color="#ff8000">10.29</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">10</font>) = makeCD( <font color="#c000c0">'Heavy metal'</font>, 'Rough Cutt Wants You', <font color="#c000c0">'Rough Cutt'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">4.7</font>, <font color="#ff8000">13.29</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">11</font>) = makeCD( <font color="#c000c0">'Rap'</font>, 'Unpredictable', <font color="#c000c0">'Jamie Foxx'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">4.5</font>,<font color="#ff8000">16.19</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">12</font>) = makeCD( <font color="#c000c0">'Rap'</font>, 'The Breakthrough', <font color="#c000c0">'Blige, Mary J'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">4.4</font>, <font color="#ff8000">13.65</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">13</font>) = makeCD( <font color="#c000c0">'Rap'</font>, 'Curtain Call: The Hits', <font color="#c000c0">'Eminem'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">4.5</font>, <font color="#ff8000">12.69</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">14</font>) = makeCD( <font color="#c000c0">'Rap'</font>, '13 Blue Magic Lane', <font color="#c000c0">'Blue Magic'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">5</font>, <font color="#ff8000">9.09</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">15</font>) = makeCD( <font color="#c000c0">'Rap'</font>, 'Duets: The Final Chapter', <font color="#c000c0">'Notorious '</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">4.1</font>, <font color="#ff8000">15.05</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">16</font>) = makeCD( <font color="#c000c0">'Blues'</font>, 'Bronx In Blue', <font color="#c000c0">'Dion'</font>, <font color="#ff8000">2006</font>, <font color="#ff8000">4.3</font>, <font color="#ff8000">9.50</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">17</font>) = makeCD( <font color="#c000c0">'Blues'</font>, 'Super Session', <font color="#c000c0">'Bloomfield, Mike et al'</font>, <font color="#ff8000">1968</font>, <font color="#ff8000">4.5</font>, <font color="#ff8000">9.75</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">18</font>) = makeCD( <font color="#c000c0">'Blues'</font>, 'It Ain''t Easy', <font color="#c000c0">'Baldry, Long John'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">5</font>, <font color="#ff8000">15.69</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">19</font>) = makeCD( <font color="#c000c0">'Blues'</font>, 'Mourning In The Morning', <font color="#c000c0">'Otis Rush'</font>, <font color="#ff8000">1969</font>, <font color="#ff8000">1</font>, <font color="#ff8000">9.09</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">20</font>) = makeCD( <font color="#c000c0">'Blues'</font>, 'Had To Cry Today', <font color="#c000c0">'Joe Bonamassa'</font>, <font color="#ff8000">2004</font>, <font color="#ff8000">4.3</font>, <font color="#ff8000">14.29</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">21</font>) = makeCD( <font color="#c000c0">'Classical'</font>, 'Tchaikovsky: Suite no <font color="#ff8000">3'</font>, <font color="#c000c0">' Jurowski et al'</font>, <font color="#ff8000">2006</font>, <font color="#ff8000">5</font>, <font color="#ff8000">13.99</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">22</font>) = makeCD( <font color="#c000c0">'Classical'</font>, 'Most Relaxing Classical Album in the World...Ever!<font color="#c000c0">', ... <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '</font>Most Relaxing Classical Album In World Ever', <font color="#ff8000">1999</font>, <font color="#ff8000">4</font>, <font color="#ff8000">15.79</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">23</font>) = makeCD( <font color="#c000c0">'Classical'</font>, 'Phantom Of The Opera', <font color="#c000c0">'Hybrid'</font>, <font color="#ff8000">2004</font>, <font color="#ff8000">5</font>, <font color="#ff8000">15.79</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">24</font>) = makeCD( <font color="#c000c0">'Classical'</font>, 'Mozart: Wind Concertos', <font color="#ff8000">...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#c000c0">'Concertgebouw Chamber Orchestra'</font>, <font color="#ff8000">2006</font>, <font color="#ff8000">1</font>, <font color="#ff8000">13.99</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">25</font>) = makeCD( <font color="#c000c0">'Classical'</font>, 'Wicked', <font color="#c000c0">'Original Cast'</font>, <font color="#ff8000">2003</font>, <font color="#ff8000">4.8</font>, <font color="#ff8000">15.49</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">26</font>) = makeCD( <font color="#c000c0">'Oldies'</font>, 'Bronx In Blue', <font color="#c000c0">'Dion'</font>, <font color="#ff8000">2006</font>, <font color="#ff8000">4.3</font>, <font color="#ff8000">9.50</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">27</font>) = makeCD( <font color="#c000c0">'Oldies'</font>, 'Gold', <font color="#c000c0">'Righteous Brothers'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">1</font>, <font color="#ff8000">13.99</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">28</font>) = makeCD( <font color="#c000c0">'Oldies'</font>, 'Greatest Hits', <font color="#c000c0">'Ricky Nelson'</font>, <font color="#ff8000">2005</font>, <font color="#ff8000">5</font>, <font color="#ff8000">15.79</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">29</font>) = makeCD( <font color="#c000c0">'Oldies'</font>, 'Black & White Night', <font color="#c000c0">'Roy Orbison'</font>, <font color="#ff8000">1989</font>, <font color="#ff8000">4.8</font>, <font color="#ff8000">11.29</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">30</font>) = makeCD( <font color="#c000c0">'Oldies'</font>, 'Retrospective', <font color="#c000c0">'Animals'</font>, <font color="#ff8000">2004</font>, <font color="#ff8000">4.3</font>, <font color="#ff8000">14.49</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds(<font color="#ff8000">31</font>) = makeCD( <font color="#c000c0">'Oldies'</font>, 'Very Best Of Frankie Valli & The Four Seasons', <font color="#c000c0">'Frankie Valli'</font>, <font color="#ff8000">2002</font>, <font color="#ff8000">5</font>, <font color="#ff8000">15.69</font> );<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;cds<br>
</strong></code>



  
<h3><a name="7_4_2">7.4.2	Accessing Structure Elements</a></h3>

 Like normal arrays or cell arrays, items can be stored and retrieved by their index in the array. As structures are added to the array, MATLAB forces all elements in the structure array to implement the same field names in the same order, even if the inserted structure has the fields in the wrong order, or with some missing. Fields in the original structure not changed by the addition are filled with empty vector, <code>[]</code>. If you are trying to add a non-existent field, you should first add that field to the whole structure array before adding another structure containing that field. <br>
Elements can be accessed in three ways:
<ul>
<li>individually either:
<ul>
<li>manually (not recommended) or</li>
<li>by creating new structures with a constructor and adding them (recommended).</li>
</ul>
<li>or by collectively accessing specific fields across the whole structure array</li>
</ul>
</code>


<b>Manually:</b> If you elect to manipulate the elements of a structure array manually, you merely identify the array element by indexing and use the <code>.field</code> operator. For example, for the CD collection <code>cds</code>, we could change the price of one of them as follows:<br>
<code>>> cds(3).price = 11.95<br>
cds = <br>
&nbsp;&nbsp;1x3 struct array with fields:<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist<br>
&nbsp;&nbsp;&nbsp;&nbsp;title<br>
&nbsp;&nbsp;&nbsp;&nbsp;year<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars<br>
&nbsp;&nbsp;&nbsp;&nbsp;price<br>
</code>This is a little hazardous when making manual additions to a structure array. A typographical error while entering a field name results in all the structures having that bad field name. For example, consider this error:<br>
<code>>> cds(3).prce = 11.95<br>
cds = <br>
&nbsp;&nbsp;1x31 struct array with fields:<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist<br>
&nbsp;&nbsp;&nbsp;&nbsp;title<br>
&nbsp;&nbsp;&nbsp;&nbsp;year<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars<br>
&nbsp;&nbsp;&nbsp;&nbsp;price<br>
&nbsp;&nbsp;&nbsp;&nbsp;prce<br>
</code> You have accidentally added a new field to the whole collection. You can check this by looking at one entry:<br>
<code>>> cds(1)<br>
ans = <br>
&nbsp;&nbsp;struct with fields:<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre: 'Blues'<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist: 'Sessions For Robert J'<br>
&nbsp;&nbsp;&nbsp;&nbsp;title: 'Clapton, Eric'<br>
&nbsp;&nbsp;&nbsp;&nbsp;year: 2004<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars: 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;price: 18.95<br>
&nbsp;&nbsp;&nbsp;&nbsp;prce: []<br>
</code> If this happens, you can use the <code>fieldnames(...)</code> function to determine the situation and then the <code>rmfield(...)</code> function to remove the offending entry.<br>
<code>>> fieldnames(cds)<br>
ans =  <br>
&nbsp;&nbsp;&nbsp;&nbsp;{'genre'}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{'artist'}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{'title'}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{'year'}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{'stars'}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{'price'}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{'prce'}<br>
>> cds = rmfield(cds,'prce')<font color="#00A000">    % recall that the result must be assigned to replace the original. </font><br>
cds = 1x32 struct array with fields:<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist<br>
&nbsp;&nbsp;&nbsp;&nbsp;title<br>
&nbsp;&nbsp;&nbsp;&nbsp;year<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars<br>
&nbsp;&nbsp;&nbsp;&nbsp;price</code><br>
</code><br>
<b>Custom Constructor:</b> It is best to use the custom constructor to make a complete structure and then insert it into the structure array. For example:<br>
<code>>> newCD = makeCD( 'Oldies', 'Greatest Hits', ... 'Ricky Nelson', 2005, 5, 15.79 );<br>
>> cds = [cds  newCD]<br>
cds =<br>
&nbsp;&nbsp;1x3 struct array with fields:<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist<br>
&nbsp;&nbsp;&nbsp;&nbsp;title<br>
&nbsp;&nbsp;&nbsp;&nbsp;year<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars<br>
&nbsp;&nbsp;&nbsp;&nbsp;price<br>
</code>  If you insert that new CD beyond the end of the array, as one might expect, MATLAB fills out the array with empty structures:<br>
<code>>> cds(end+2) = newCD<br>
cds =<br>
&nbsp;&nbsp;1&#215;5 struct array with fields:<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist<br>
&nbsp;&nbsp;&nbsp;&nbsp;title<br>
&nbsp;&nbsp;&nbsp;&nbsp;year<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars<br>
&nbsp;&nbsp;&nbsp;&nbsp;price<br>
<br>
>> cds(end-1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre []<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist []<br>
&nbsp;&nbsp;&nbsp;&nbsp;title []<br>
&nbsp;&nbsp;&nbsp;&nbsp;year []<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars []<br>
&nbsp;&nbsp;&nbsp;&nbsp;price []<br>
<br></code>

<div class="container">
  <div class="sidebar_R">
<h4>Exercise 7.5 The CD collection</h4>
Run the script in Listing 7.5.
Then, in the Interactions window, enter the following commands to create
your collection of CD information:<br>
<code>
<font color="#00A000">% Look at the 5th CD entry</font><br>
>> cds(5)<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre: 'Rock/Pop'<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist: 'Ludacris'<br>
&nbsp;&nbsp;&nbsp;&nbsp;title: 'The Red Light District'<br>
&nbsp;&nbsp;&nbsp;&nbsp;year: 2004<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars: 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;price: 13.49<br>
<font color="#00A000">% Look at the field names</font><br>
>> flds = fieldnames(collection)<br>
flds =<br>
&nbsp;&nbsp;&nbsp;&nbsp;'genre'<br>
&nbsp;&nbsp;&nbsp;&nbsp;'artist'<br>
&nbsp;&nbsp;&nbsp;&nbsp;'title'<br>
&nbsp;&nbsp;&nbsp;&nbsp;'year'<br>
&nbsp;&nbsp;&nbsp;&nbsp;'stars'<br>
&nbsp;&nbsp;&nbsp;&nbsp;'price' <br>
<font color="#00A000">% Typo: bad field name</font><br>
cds(5).strs = 0.5;<br>
>> cds(5)<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre: 'Rock/Pop'<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist: 'Ludacris'<br>
&nbsp;&nbsp;&nbsp;&nbsp;title: 'The Red Light District'<br>
&nbsp;&nbsp;&nbsp;&nbsp;year: 2004<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars: 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;price: 13.4900<br>
&nbsp;&nbsp;&nbsp;&nbsp;strs: 0.5<br>
<font color="#00A000">% All CDs now have a bad field</font><br>
>> cds(1)<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre: 'Blues'<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist: 'Clapton, Eric'<br>
&nbsp;&nbsp;&nbsp;&nbsp;title: 'Sessions For Robert J'<br>
&nbsp;&nbsp;&nbsp;&nbsp;year: 2004<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars: 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;price: 18.9500<br>
&nbsp;&nbsp;&nbsp;&nbsp;strs: []<br>
<font color="#00A000">% remove that field from cds</font><br>
>> cds = rmfield(cds, 'strs');<br>
>> cds(1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;genre: 'Blues'<br>
&nbsp;&nbsp;&nbsp;&nbsp;artist: 'Clapton, Eric'<br>
&nbsp;&nbsp;&nbsp;&nbsp;title: 'Sessions For Robert J'<br>
&nbsp;&nbsp;&nbsp;&nbsp;year: 2004<br>
&nbsp;&nbsp;&nbsp;&nbsp;stars: 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;price: 18.9500<br>
<font color="#00A000">% extract all their prices and sum them</font><br>
>> sum([cds.price])<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;409.1100<br>
</code>
</div>

<b>Accessing one field from the whole structure array</b>: Suppose we really want to extract, for example, all the prices from the cd array. Let's try the obvious way first:<br>
<code>>> prices = cds.price;<br>
prices =<br>
&nbsp;&nbsp;&nbsp;&nbsp;18.9500<br>
</code>
Hmmm - seems to have given me just the first one.  How about letting <code>ans</code> have them all?<br>

<code>>> cds.price;<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;18.9500<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;14.8900<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;13.4900<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;[]<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;15.7900<br>
</code>
That looks familiar - sending too many results (in this case, one result for each of the structures in the array) to the default variable.  See the beginning of Exercise 7.1 above. There, we solved the problem by providing at least one actual variable to capture a result, just as we did in our first try above. But what if we actually want all the values of a field? Since the number of structures is variable, we can't really provide the right number of variables to save all the results. So we use a different strategy: "catching" all the values in a collection of the appropriate type: a vector for fields containing only single numbers, a cell array for everything else.  For example,<br>
<code>
>> [cds.price]<br>
ans =<br>
&nbsp;&nbsp;&nbsp;&nbsp;18.9500   14.8900   13.4900   15.7900<br>
<font color="#00A000">% Be careful here - since the 4th structure has an empty vector for price,<br>
%    it was ignored by the concatenation</font><br>
>> {cds.genre}<br>
ans =<br>
&nbsp;&nbsp;1&#215;5 cell array<br>
&nbsp;&nbsp;&nbsp;&nbsp;{'Blues'}    {'Classical'}    {'Country'}    {0&#215;0 double}    {'Oldies'}

</code>.
<h3><a name="7_4_3">7.4.3	Manipulating Structures</a></h3>
 Structures and structure arrays can be manipulated in the following ways:
 <ul>
 <li>Single values can be changed using the '.' (dot) notation directly with a field name:<br>
 <code>>> cds(5).price = 19.95;</code></li>
 <li>or indirectly using the "." (dot) notation with a variable containing the field name:<br> <code>>> fld = 'price';<br>
 >> cds(5).(fld) = 19.95;</li> </code>
 <li>or by using built-in functions:<br>
 <ul>
 <li> <code>nms = fieldnames(str)</code>returns a cell array containing the names of the fields in a structure or structure array.<br>
  <code>>> flds = fieldnames(cds);</li>
 <li>it = isfield(str, <fldname>) </code>determines whether the given name is a field in this structure or structure array.<br>
  <code>>> if isfield(cds, 'price') ... </li>
 <li>str = setfield(str, &lt;fldname&gt;, &lt;value&gt;) </code> returns a new structure array with the specified field set to the specified value.<br>
  <code>>> cds(1) = setfield(cds(1), 'price', 19.95); </code></li>
 <li> <code>val = getfield(str, &lt;fldname&gt;) </code> returns the value of the specified field.<br>
  <code>>> disp(getfield(cds(1), 'price') );</li>
 <li>str = rmfield(str, &lt;fldname&gt;) </code> returns a new structure array with the specified field removed.<br>
  <code>>> noprice = rmfield(cds, 'price');</li> </code>
 <li>Values across the whole array can be retrieved using the “.” notation by accumulating them into either arrays or cell arrays:<br>
  <code>>> titles = {cds.title};<br>>> [alpha order] = sort(titles); </li> </code>
 <li>or, if the values are all numeric, into a vector:<br>
  <code>>> prices = [cds.price];<br>
  >> total = sum(prices);<br>
   </code>Notice that after extracting the price values into a cell array or vector, all the normal operations - in this case,  <code>sort(...) </code> and  <code>sum(...) </code> - can be utilized.</li>
</ul>
</ul>
 Exercise 7.5 provides some practice in manipulating structure arrays using the above CD collection as an example.  
 </div>
 
 
<h2><a name="7_5">7.5  Comparing Cell Arrays to Structure Arrays</a></h2>

To provide some context for this discussion, compare the cell array illustrated in Fig 7.1 with the structure array in Fig 7.2.<br>
<strong>Cell Array:</strong>  To access, for example, the year of the birthday of the third person in the Cell Array, you would need to:<br>
<ul>
<li>figure out from some design document beyond the code itself which column contained the date structure and which row of the date structure contained the year.</li>
<li>then you would enter this: <br><code>it = Obj{3}{3}{3}</code></li>
</ul>

<strong>Structure Array:</strong>  To access the same item, you would just enter this:<br>
 <code>it = Obj(3).birth.year</code><br>
Most people would greatly prefer the simplicity and clarity of the Structure Array, and that seems appropriate.  Unfortunately, as you have seen already in this chapter, and will see even more in the next chapter, cell arrays are built into the infrastructure of Matlab and are frequently necessary to extract data from collections or files.


<h2><a name="7_6">7.6 Engineering Example: Assembling a Physical Structure</a></h2>

Many large bridges today have steel frames as their basic structure. Engineers perform the analysis and design work for each steel component and deliver these designs to the steel company. The steel company manufactures all the components, and prepares them for delivery to the building site. At this point, each component is identified only by a unique identifier string stamped and/or chalked onto that component. For even a modest-sized bridge, this transportation may require a significant number of truckloads of components. The question we address here is how to decide the sequence in which the components are delivered to the building site so that components are available when needed, but not piled up waiting to be used.<br>

Consider the relatively simple structure shown in Figure 7.3. The components have individual labels, and we can obtain from the architect the identities of the components that are connected together. The construction needs to start from the fixed point A. We need to analyze this information and compute the order in which the components would be used to assemble the structure.

The data will be organized as a structure array with one entry for each component. One of the fields in that structure will be a cell array of the names of the components to which this component is connected.

The code in Listing 7.6 shows the solution to this problem. When you run this, the output should be:<br>
<code>group 1 = { A B E F }<br>
group 2 = { C G }<br>
group 3 = { D }<br>
Beams should arrive in this order:<br>
E-A E-B E-F A-B B-F F-C F-G B-C C-G G-D C-D<br></code><br>
Although this seems to be simple problem, there is not a natural ordering of the components.  The goal of algorithm cited within the listing is to identify small groups of components that do have natural ordering and then schedule the beams that make up each group for delivery.
<center><figure style="margin-left: 10px; margin_bottom: 5px">
<p><img alt="image" height="600" src="Fig_7_3.jpg" width="800" /></p>
<figcaption><b><center>Fig 7.3 Simple Bridge Structure</center></b></figcaption></figure></center>
<h3>Listing 7.6: Connectivity of a structure</h3>
<code>&nbsp;&nbsp;&nbsp;&nbsp;clear; clc<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> adj<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> beams<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% describe the structure as an adjacency list identifying for each</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% node 'A'-'G' the nodes to which it directly connects</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;adj = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;adj = [adj, struct(<font color="#c000c0">'from'</font>, <font color="#c000c0">'A'</font>, <font color="#c000c0">'to'</font>, {{<font color="#c000c0">'B'</font>, <font color="#c000c0">'E'</font>}})];<br>
&nbsp;&nbsp;&nbsp;&nbsp;adj = [adj, struct(<font color="#c000c0">'from'</font>, <font color="#c000c0">'B'</font>, <font color="#c000c0">'to'</font>, {{<font color="#c000c0">'A'</font>, <font color="#c000c0">'C'</font>, <font color="#c000c0">'E'</font>, <font color="#c000c0">'F'</font>}})];<br>
&nbsp;&nbsp;&nbsp;&nbsp;adj = [adj, struct(<font color="#c000c0">'from'</font>, <font color="#c000c0">'C'</font>, <font color="#c000c0">'to'</font>, {{<font color="#c000c0">'B'</font>, <font color="#c000c0">'D'</font>, <font color="#c000c0">'F'</font>, <font color="#c000c0">'G'</font>}})];<br>
&nbsp;&nbsp;&nbsp;&nbsp;adj = [adj, struct(<font color="#c000c0">'from'</font>, <font color="#c000c0">'D'</font>, <font color="#c000c0">'to'</font>, {{<font color="#c000c0">'C'</font>, <font color="#c000c0">'G'</font>}})];<br>
&nbsp;&nbsp;&nbsp;&nbsp;adj = [adj, struct(<font color="#c000c0">'from'</font>, <font color="#c000c0">'E'</font>, <font color="#c000c0">'to'</font>, {{<font color="#c000c0">'A'</font>, <font color="#c000c0">'B'</font>, <font color="#c000c0">'F'</font>}})];<br>
&nbsp;&nbsp;&nbsp;&nbsp;adj = [adj, struct(<font color="#c000c0">'from'</font>, <font color="#c000c0">'F'</font>, <font color="#c000c0">'to'</font>, {{<font color="#c000c0">'B'</font>, <font color="#c000c0">'C'</font>, <font color="#c000c0">'E'</font>, <font color="#c000c0">'G'</font>}})];<br>
&nbsp;&nbsp;&nbsp;&nbsp;adj = [adj, struct(<font color="#c000c0">'from'</font>, <font color="#c000c0">'G'</font>, <font color="#c000c0">'to'</font>, {{<font color="#c000c0">'C'</font>, <font color="#c000c0">'D'</font>, <font color="#c000c0">'F'</font>}})];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% Don't worry about exactly why this algorithm works</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% It is actually a search for "strongly connected components" (SCC's)</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% described in the Corman, Leiserson, Rivest text</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% "Introduction to Algorithms" pp 488-493</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% this is the algorithm:</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% 1. compute u, a Depth First Search (DFS: Para 7.4.2), storing the</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    finish order f(u)</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% 2. compute a DFS using f(u) in descending order finish times d(u)</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% 3. compute fi(u), the forefather of each node in u defined as that</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    node w connected to u with the maximum value of f(w). Note: to</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    get this right, u can connect to itself</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% 4. all the nodes in u with the same forefather form one of the</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    groups of SCC's </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% 5. select the beams for each group that connect the group's </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    forefather to all the other nodes. </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% so here we go</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    set all nodes to 'not used' except A</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;at = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;finish = <font color="#ff8000">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;N = length(adj);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ndx = <font color="#ff8000">1</font>:N<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adj(ndx)<font color="#ff8000">.used</font> = false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% construct a list of beams</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;beams = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ndx = <font color="#ff8000">1</font>:length(adj)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr = adj(ndx)<font color="#ff8000">.from</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ca = adj(ndx)<font color="#ff8000">.to</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> c = ca<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bm = [fr c{<font color="#ff8000">1</font>}];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> ~is_beam(bm)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beams = [beams {bm}]; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;adj(<font color="#ff8000">1</font>)<font color="#ff8000">.used</font> = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;adj(<font color="#ff8000">1</font>)<font color="#ff8000">.f</font> = finish;<br>
&nbsp;&nbsp;&nbsp;&nbsp;u(<font color="#ff8000">1</font>) = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;nxt = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% fprintf('u(%d) = %c; f(%d) = %d\n', 1, adj(1).from, 1, adj(1).f); </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% 1. DFS starting at A, choosing the first child reachable from </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    the current node u storing the finish time f(u)</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ndx = <font color="#ff8000">2</font>:N<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nxt = get_DFS_next(nxt);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish = finish + <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adj(nxt)<font color="#ff8000">.used</font> = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u(nxt) = nxt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adj(nxt)<font color="#ff8000">.f</font> = finish;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%     fprintf('u(%d) = %c; f(%d) = %d\n', ...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%         ndx, adj(nxt).from, ndx, adj(nxt).f); </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% 2. compute a DFS using f(u) in descending order finish times d(u)</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;f_vals = [adj.f];<br>
&nbsp;&nbsp;&nbsp;&nbsp;finish = <font color="#ff8000">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ndx = <font color="#ff8000">1</font>:N<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at = find(f_vals == (<font color="#ff8000">7</font> - ndx));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(ndx) = at;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adj(at)<font color="#ff8000">.d</font> = finish;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish = finish + <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%     fprintf('v(%d) = %c; d(%d) = %d\n', ...</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%         ndx, adj(at).from, ndx, adj(at).d); </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% 3. compute fi(u), the forefather of each node in u defined as that</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    node w connected to u with the maximum value of f(w). Note: to</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    get this right, u can connect to itself</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ndx = <font color="#ff8000">1</font>:N<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ca = [{adj(ndx)<font color="#ff8000">.from</font>, adj(ndx)<font color="#ff8000">.to</font>{:}}];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ord = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> c = ca<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jk = c{<font color="#ff8000">1</font>} - <font color="#c000c0">'A'</font> + <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ord = [ord jk];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it = [it adj(jk)<font color="#ff8000">.f</font>];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[~, at] = max(it);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;choice = ca{at} - <font color="#c000c0">'A'</font> + <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adj(ndx)<font color="#ff8000">.fi</font> = choice;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;finx = [adj.fi];<br>
&nbsp;&nbsp;&nbsp;&nbsp;fi = char(finx + <font color="#c000c0">'A'</font> - <font color="#ff8000">1</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% 4. all the nodes in u with the same forefather form one of the</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    groups of SCC's </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;at = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;ca = {adj.from};<br>
&nbsp;&nbsp;&nbsp;&nbsp;foref = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ndx = <font color="#ff8000">1</font>:<font color="#ff8000">7</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> any(finx == ndx)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grp = ca(finx == ndx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at = [at {grp}];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foref = [foref ndx];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% 5. a. select the beams for each group that connect the group's </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    forefather to all the other nodes. </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    b. select the beams totally within the emerging collection</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">%    of nodes</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;save_bms = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_nodes = [];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> gndx = <font color="#ff8000">1</font>:length(at)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ff = foref(gndx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ca = at{gndx};<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_nodes = [all_nodes ca];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'group %d = {'</font>, gndx);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> nx = <font color="#ff8000">1</font>:length(ca)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">' %s'</font>, ca{nx});<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beam = [adj(ff)<font color="#ff8000">.from</font>, ca{nx}];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;save_bms = add_beam(save_bms, beam);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">' }\n'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% also save all beams with both ends in all_nodes</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> nx = <font color="#ff8000">1</font>:length(all_nodes)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ny = nx+<font color="#ff8000">1</font>:length(all_nodes)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bm = [all_nodes{nx} all_nodes{ny}];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;save_bms = add_beam(save_bms, bm);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% display the answers</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'Beams should arrive in this order:\n'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> bm = save_bms<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = bm{:};<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'%c-%c '</font>, b(<font color="#ff8000">1</font>), b(<font color="#ff8000">2</font>));<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(<font color="#c000c0">'\n'</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
<font color="#0000ff">function</font> bms = add_beam(bms, beam)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> is_beam(beam)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00A000">% check if it's already there</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rev = [beam(<font color="#ff8000">2</font>) beam(<font color="#ff8000">1</font>)];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> ~(any(strcmp(bms, beam))||any(strcmp(bms, rev)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bms = [bms {beam}];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> is = is_beam(str)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> beams<br>
&nbsp;&nbsp;&nbsp;&nbsp;is = false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;rev = [str(<font color="#ff8000">2</font>) str(<font color="#ff8000">1</font>)];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> ndx = <font color="#ff8000">1</font>:length(beams)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> strcmp(beams{ndx}, str) || strcmp(beams{ndx},rev)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">break</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
<font color="#0000ff">end</font><br>
<br>
<font color="#0000ff">function</font> res = get_DFS_next(u)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">global</font> adj;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ca = adj(u)<font color="#ff8000">.to</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;to_ndx = <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;at = ca{to_ndx} - <font color="#c000c0">'A'</font> + <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">while</font> adj(at)<font color="#ff8000">.used</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_ndx = to_ndx + <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at = ca{to_ndx} - <font color="#c000c0">'A'</font> + <font color="#ff8000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;res = at;<br>
<font color="#0000ff">end</font><br>
</strong></code>

<h2>Chapter Summary</h2>

This chapter covered the nature, implementation, and behavior of two heterogeneous collections:
<ul>
<li>Cell arrays are vectors of containers; their elements can be manipulated either as vectors of containers, or individually by inserting or extracting the contents of the container using braces in place of parentheses</li>
<li>The elements of a structure are accessed by name rather than by indexing, using the dot operator, ‘.’, to specify the field name to be used</li>
<li>Structures can be collected into structure arrays whose elements are structures all with the same field names. These elements can then be indexed and manipulated in the same manner as the cells in a cell array<li>
</ul>
[Special Characters]

[Problems]




<table align="center"> 
<tbody> 
<tr> 
<td><a href="06_Strings.htm">previous</a></td> 
<td><a href="Contents.htm">home</a></td> 
<td><a href="08_File_I_O.htm">next</a></td> 
</tr> 
</tbody> 
</table> 

<p align="center"><font size="1">This Web Page was Built with PageBreeze </font><a href="http://pagebreeze.com" target="_blank"><font size="1">Free HTML Editor</font></a><font size="1"> </font></p> 
</body> 
</html> 
-1.000000e+00 
