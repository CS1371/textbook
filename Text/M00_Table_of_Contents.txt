

Chapter 1	Introduction to Computers and Programming	1
1.1	Background    2
1.2	History of Computer Architectures      3
1.2.1	Babbage’s Difference Engine  3
1.2.2	Colossus     3
1.2.3	The von Neumann Architecture    4
1.3	Computing Systems Today    5
1.3.1	Computer Hardware     5
1.3.2	Computer Memory     6
1.3.3	Computer Software    8
1.3.4	Running a Computer Program    11
1.4	Running an Interpreted Program    13
1.5	Anticipated Outcomes    13
1.5.1	Introduction to MATLAB      13
1.5.2	Learning Programming Concepts    14
1.5.3	Problem-Solving Skills    14

Chapter 2	Getting Started	17
2.1	Programming Language Background   18
2.1.1	Abstraction    18
2.1.2	Algorithms    19
2.1.3	Programming Paradigms   20
2.2	Basic Data Manipulation   20
2.2.1	Starting and Stopping MATLAB     20
2.2.2	Assigning Values to Variables  21
2.2.3	Data Typing    22
2.2.4	Classes and Objects     24
2.3	MATLAB User Interface   24
2.3.1	Command Window    25
2.3.2	Command History     26
2.3.3	Workspace Window    27
2.3.4	Current Directory Window   30
2.3.5	Variable Editor    31
2.3.6	Figure Window    31
2.3.7	Editor Window    32
2.4	Scripts    33
2.4.1	Text  Files    33
2.4.2	Creating Scripts    33
2.4.3	The Current Directory    34
2.4.4	Running Scripts    35
2.4.5	Punctuating Scripts   35
2.4.6	Debugging Scripts    36
2.5	Engineering Example—Spacecraft Launch   36

Chapter 3	Vectors and Arrays	45
3.1	Concept: Using Built-in Functions    46
3.2	Concept: Data Collections      46
3.2.1	Data Abstraction    46
3.2.2	Homogeneous Collection     46
3.3	Vectors    46
3.3.1	Creating a Vector    47
3.3.2	Size of a Vector    48
3.3.3	Indexing a Vector    48
3.3.4	Shortening a Vector    50
3.3.5	Operating on Vectors     51
3.4	Engineering Example—Forces and Moments   58
3.5	Arrays    60
3.5.1	Properties of an Array     61
3.5.2	Creating an Array     62
3.5.3	Accessing Elements of an Array    62
3.5.4	Removing Elements of an Array    63
3.5.5	Operating on Arrays    64
3.6	Engineering Example—Computing Soil Volume    71

Chapter 4	Execution Control	81
4.1	Concept: Code Blocks   82
4.2	Conditional Execution in General     82
4.3	if Statements  83
4.3.1	General Template    84
4.3.2	MATLAB Implementation     84
4.3.3	Important Ideas   86
4.4	switch Statements   88
4.4.1	General Template    88
4.4.2	MATLAB Implementation     89
4.5	Iteration in General    90
4.6	for Loops   90
4.6.1	General for Loop Template   91
4.6.2	MATLAB Implementation     91
4.6.3	Indexing Implementation   93
4.6.4	Breaking out of a for Loop   94
4.7	while Loops   94
4.7.1	General while Template  94
4.7.2	MATLAB while Loop Implementation    95
4.7.3	Loop-and-a-Half Implementation   96
4.7.4	Breaking a while Loop   97
4.8	Engineering Example—Computing Liquid Levels    97

Chapter 5	Functions	105
5.1	Concepts: Abstraction and Encapsulation    106
5.2	Black Box View of a Function     106
5.3	MATLAB Implementation    107
5.3.1	General Template    107
5.3.2	Function Definition    107
5.3.3	Storing and Using Functions    109
5.3.4	Calling Functions    109
5.3.5	Variable Numbers of Parameters    109
5.3.6	Returning Multiple Results   110
5.3.7	Auxiliary Local Functions     111
5.3.8	Encapsulation in MATLAB   Functions    111
5.3.9	Global Variables   112
5.4	Engineering Example—Measuring a Solid Object   113

Chapter 6	Character Strings	121
6.1	Character String Concepts: Mapping Casting, Tokens, and Delimiting	122
6.2	MATLAB Implementation    123
6.2.1	Slicing and Concatenating Strings   124
6.2.2	Arithmetic and Logical Operations     125
6.2.3	Useful Functions    125
6.3	Format Conversion Functions     125
6.3.1	Conversion from Numbers to Strings     125
6.3.2	Conversion from Strings to Numbers     127
6.4	Character String Operations     129
6.4.1	Simple Data Output: The disp(...) Function   129
6.4.2	Complex Output     129
6.4.3	Comparing Strings    129
6.5	Arrays of Strings    131
6.6	Engineering Example—Encryption   132

Chapter 7	Cell Arrays and Structures	141
7.1	Concept: Collecting Dissimilar Objects      142
7.2	Cell Arrays    142
7.2.1	Creating Cell Arrays   142
7.2.2	Accessing Cell Arrays     143
7.2.3	Using Cell Arrays   145
7.2.4	Processing Cell Arrays    145
7.3	Structures    146
7.3.1	Constructing and Accessing One Structure     147
7.3.2	Constructor Functions     148
7.4	Structure Arrays     150
7.4.1	Constructing Structure Arrays     150
7.4.2	Accessing Structure Elements    152
7.4.3	Manipulating Structures   154
7.5	Engineering Example—Assembling a Physical Structure   156

Chapter 8	File Input and Output	167
8.1	Concept: Serial Input and Output (I/O)     168
8.2	Workspace I/O     168
8.3	High-Level I/O Functions     169
8.3.1	Exploration    169
8.3.2	Spreadsheets   170
8.3.3	Delimited Text  Files    172
8.4	Lower-Level File I/O     174
8.4.1	Opening and Closing Files    174
8.4.2	Reading Text Files    174
8.4.3	Examples of Reading Text Files    175
8.4.4	Writing Text Files   176
8.5	Engineering Example—Spreadsheet Data   177

Chapter 9	Recursion	185
9.1	Concept: The Activation Stack     186
9.1.1	A Stack    186
9.1.2	Activation Stack    186
9.1.3	Function Instances   187
9.2	Recursion Defined    187
9.3	Implementing a Recursive Function   188
9.4	Exceptions    190
9.4.1	Historical Approaches    191
9.4.2	Generic Exception Implementation    191
9.4.3	MATLAB Implementation    193
9.5	Wrapper Functions    195
9.6	Examples of Recursion    197
9.6.1	Detecting Palindromes    197
9.6.2	Fibonacci Series    198
9.6.3	Zeros of a Function     199
9.7	Engineering Example—Robot Arm Motion     202

Chapter 10	Principles of Problem Solving	211
10.1	Solving Simple Problems   212
10.2	Assembling Solution Steps    212
10.3	Summary of Operations    212
10.3.1	Basic Arithmetic Operations    213
10.3.2	Inserting into a Collection     213
10.3.3	Traversing a Collection     215
10.3.4	Building a Collection    216
10.3.5	Mapping a Collection    216
10.3.6	Filtering a Collection    217
10.3.7	Summarizing a Collection    218
10.3.8	Searching a Collection    219
10.3.9	Sorting a Collection     220
10.4	Solving Larger Problems    220
10.5	Engineering Example—Processing Geopolitical Data    221

Chapter 11	Plotting	231
11.1	Plotting in General    232
11.1.1	A Figure—The Plot Container   232
11.1.2	Simple Functions for Enhancing Plots   232
11.1.3	Multiple Plots on One Figure—Subplots    233
11.1.4	Manually Editing Plots   234
11.2	2-D Plotting    235
11.2.1	Simple Plots    235
11.2.2	Plot Options     237
11.2.3	Parametric Plots    237
11.2.4	Other 2-D Plot Capabilities      239
11.3	3-D Plotting    239
11.3.1	Linear 3-D Plots     239
11.3.2	Linear Parametric 3-D Plots     241
11.3.3	Other 3-D Plot Capabilities      242
11.4	Surface Plots    243
11.4.1	Basic Capabilities    243
11.4.2	Simple Exercises    243
11.4.3	3-D Parametric Surfaces    248
11.4.4	Bodies of Rotation	250
11.4.5	Other 3-D Surface  Plot Capabilities	255
11.4.6	Assembling Compound Surfaces	256
11.5	Manipulating Plotted Data	256
11.6	Engineering Example—Visualizing Geographic Data	256
11.6.1	Analyzing the Data	257
11.6.2	Displaying the Data	258

Chapter 12	Matrices	267
12.1	Concept: Behavioral Abstraction	268
12.2	Matrix Operations	268
12.2.1	Matrix  Multiplication	268
12.2.2	Matrix Division	271
12.2.3	Matrix Exponentiation	271
12.3	Implementation	271
12.3.1	Matrix  Multiplication	272
12.3.2	Matrix Division	273
12.4	Rotating Coordinates	274
12.4.1	2-D Rotation	275
12.4.2	3-D Rotation	278
12.5	Solving Simultaneous Linear Equations	281
12.5.1	Intersecting Lines	282
12.6	Engineering  Examples	283
12.6.1	Ceramic  Composition	283
12.6.2	Analyzing an Electrical Circuit	285

Chapter 13	Images	291
13.1	Nature of an Image	292
13.2	Image Types	293
13.2.1	True Color Images	293
13.2.2	Gray Scale Images	293
13.2.3	Color Mapped Images	294
13.2.4	Preferred Image Format	294
13.3	Reading, Displaying, and Writing Images	295
13.4	Operating on Images	295
13.4.1	Stretching or Shrinking Images	295
13.4.2	Color Masking	296
13.4.3	Creating a Kaleidoscope	301
13.4.4	Images on a Surface	303
13.5	Engineering Example—Detecting Edges	306

Chapter 14	Processing Sound	315
14.1	The Physics of Sound	316
14.2	Recording and Playback	316
14.3	Implementation	317
14.4	Time Domain Operations	318
14.4.1	Slicing and Concatenating Sound	318
14.4.2	Musical  Background	321
14.4.3	Changing Sound Frequency	322
14.5	The Fast Fourier Transform	324
14.5.1	Background	325
14.5.2	Implementation	326
14.5.3	Simple Spectral Analysis	327
14.6	Frequency Domain Operations     328
14.7	Engineering Example—Music Synthesizer   332

Chapter 15	Numerical Methods	339
15.1	Interpolation   340
15.1.1	Linear Interpolation    340
15.1.2	Cubic Spline Interpolation    343
15.1.3	Extrapolation    344
15.2	Curve Fitting    345
15.2.1	Linear Regression    345
15.2.2	Polynomial Regression   347
15.2.3	Practical Application   349
15.3	Numerical Integration    351
15.3.1	Determination of the Complete Integral    351
15.3.2	Continuous Integration Problems    353
15.4	Numerical Differentiation    356
15.4.1	Difference Expressions    356
15.5	Analytical Operations    357
15.5.1	Analytical Integration   357
15.5.2	Analytical Differentiation   357
15.6	Implementation   357
15.7	Engineering Example—Shaping the Synthesizer Notes    359

Chapter 16	Sorting	367
16.1	Measuring Algorithm Cost    368
16.1.1	Specific Big O Examples  369
16.1.2	Analyzing Complex Algorithms    370
16.2	Algorithms for Sorting Data     371
16.2.1	Insertion Sort    371
16.2.2	Bubble Sort	373
16.2.3	Quick Sort	375
16.2.4	Merge Sort	377
16.2.5	Radix Sort	379
16.3	Performance Analysis    380
16.4	Applications of Sorting Algorithms    382
16.4.1	Using sort(…)    382
16.4.2	Insertion Sort    382
16.4.3	Bubble Sort    383
16.4.4	Quick Sort    383
16.4.5	Merge Sort    383
16.4.6	Radix Sort     383
16.5	Engineering Example—A Selection of Countries     384

Chapter 17	Processing Graphs	389
17.1	Queues    390
17.1.1	The Nature of a Queue     390
17.1.2	Implementing Queues   390
17.1.3	Priority Queues     391
17.1.4	Testing Queues    393
17.2	Graphs    396
17.2.1	Graph Examples    396
17.2.2	Processing Graphs    397
17.2.3	Building Graphs    398
17.2.4	Traversing Graphs	401
17.2.5	Searching Graphs	403
17.3	Minimum Spanning Trees	404
17.4	Finding Paths through a Graph	406
17.4.1	Exact Algorithms	407
17.4.2	Breadth-First Search (BFS)	407
17.4.3	Dijkstra’s Algorithm	408
17.4.4	Approximation Algorithm	411
17.4.5	Testing Graph Search Algorithms	413
17.5	Engineering  Applications	415
17.5.1	Simple Applications	415
17.5.2	Complex  Extensions	415



	 

